From da867df017554897771e22f001a05b57af841159 Mon Sep 17 00:00:00 2001
From: Leon Romanovsky <leonro@nvidia.com>
Date: Thu, 5 May 2022 13:06:39 +0300
Subject: [PATCH 064/105] xfrm: delete not used number of external headers

num_exthdrs is set but never used, so delete it.

Reviewed-by: Raed Salem <raeds@nvidia.com>
Signed-off-by: Leon Romanovsky <leonro@nvidia.com>
Acked-by: David S. Miller <davem@davemloft.net>
Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>
---
 include/net/xfrm.h     | 45 +++++++++---------------------------------
 net/xfrm/xfrm_device.c |  2 --
 2 files changed, 9 insertions(+), 38 deletions(-)

diff --git a/include/net/xfrm.h b/include/net/xfrm.h
index 8ee4f482b526..1467337dde2e 100644
--- a/include/net/xfrm.h
+++ b/include/net/xfrm.h
@@ -76,18 +76,22 @@
    many rules with priority of 0x7fffffff are allowed to exist and
    such rules are ordered in an unpredictable way, thanks to bsd folks.)
 
+   Lookup is plain linear search until the first match with selector.
+
    If "action" is "block", then we prohibit the flow, otherwise:
    if "xfrms_nr" is zero, the flow passes untransformed. Otherwise,
    policy entry has list of up to XFRM_MAX_DEPTH transformations,
    described by templates xfrm_tmpl. Each template is resolved
    to a complete xfrm_state (see below) and we pack bundle of transformations
-   to a dst_entry returned to requester.
+   to a dst_entry returned to requestor.
 
    dst -. xfrm  .-> xfrm_state #1
     |---. child .-> dst -. xfrm .-> xfrm_state #2
                      |---. child .-> dst -. xfrm .-> xfrm_state #3
                                       |---. child .-> NULL
 
+   Bundles are cached at xrfm_policy struct (field ->bundles).
+
 
    Resolution of xrfm_tmpl
    -----------------------
@@ -148,9 +152,9 @@ struct xfrm_dev_offload {
 	struct net_device	*dev;
 	struct net_device	*real_dev;
 	unsigned long		offload_handle;
-	u8			dir : 2;
-	u8			type : 2;
-	u8			flags : 2;
+	u8                  	dir : 2;
+	u8                  	type : 2;
+	u8                  	flags : 2;
 };
 
 struct xfrm_mode {
@@ -527,37 +531,6 @@ struct xfrm_policy_queue {
 	unsigned long		timeout;
 };
 
-/**
- *	struct xfrm_policy - xfrm policy
- *	@xp_net: network namespace the policy lives in
- *	@bydst: hlist node for SPD hash table or rbtree list
- *	@byidx: hlist node for index hash table
- *	@state_cache_list: hlist head for policy cached xfrm states
- *	@lock: serialize changes to policy structure members
- *	@refcnt: reference count, freed once it reaches 0
- *	@pos: kernel internal tie-breaker to determine age of policy
- *	@timer: timer
- *	@genid: generation, used to invalidate old policies
- *	@priority: priority, set by userspace
- *	@index:  policy index (autogenerated)
- *	@if_id: virtual xfrm interface id
- *	@mark: packet mark
- *	@selector: selector
- *	@lft: liftime configuration data
- *	@curlft: liftime state
- *	@walk: list head on pernet policy list
- *	@polq: queue to hold packets while aqcuire operaion in progress
- *	@bydst_reinsert: policy tree node needs to be merged
- *	@type: XFRM_POLICY_TYPE_MAIN or _SUB
- *	@action: XFRM_POLICY_ALLOW or _BLOCK
- *	@flags: XFRM_POLICY_LOCALOK, XFRM_POLICY_ICMP
- *	@xfrm_nr: number of used templates in @xfrm_vec
- *	@family: protocol family
- *	@security: SELinux security label
- *	@xfrm_vec: array of templates to resolve state
- *	@rcu: rcu head, used to defer memory release
- *	@xdo: hardware offload state
- */
 struct xfrm_policy {
 	possible_net_t		xp_net;
 	struct hlist_node	bydst;
@@ -1076,7 +1049,7 @@ struct xfrm_offload {
 #define	CRYPTO_NEXT_DONE	4
 #define	CRYPTO_FALLBACK		8
 #define	XFRM_GSO_SEGMENT	16
-#define XFRM_GRO 	32
+#define	XFRM_GRO		32
 #define XFRM_ESP_NO_TRAILER 	64
 #define	XFRM_DEV_RESUME		128
 #define	XFRM_XMIT		256
diff --git a/net/xfrm/xfrm_device.c b/net/xfrm/xfrm_device.c
index da105b62315a..07b2828e0eff 100644
--- a/net/xfrm/xfrm_device.c
+++ b/net/xfrm/xfrm_device.c
@@ -288,13 +288,11 @@ int xfrm_dev_state_add(struct net *net, struct xfrm_state *x,
 
 	xso->dev = dev;
 	xso->real_dev = dev;
-	xso->num_exthdrs = 1;
 	/* Don't forward bit that is not implemented */
 	xso->flags = xuo->flags & ~XFRM_OFFLOAD_IPV6;
 
 	err = dev->xfrmdev_ops->xdo_dev_state_add(x);
 	if (err) {
-		xso->num_exthdrs = 0;
 		xso->flags = 0;
 		xso->dev = NULL;
 		xso->real_dev = NULL;
-- 
2.25.1

