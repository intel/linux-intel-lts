From 4acb81cdc84d08e217f8c558e85c3ac5dc38dd4b Mon Sep 17 00:00:00 2001
From: Sean Lim <sean@127.0.0.1localhost>
Date: Fri, 21 Mar 2025 11:14:53 +0800
Subject: [PATCH 063/105] Fixing CVE backport issue

The following mainline patches are missing in 5.15 kernel
Neccessary changes are cherry-pick from patche below.

e1b539bd73a76 xfrm: add net device refcount tracker to struct xfrm_state_offload
2b1dc6285c3f6 xfrm: pass struct net to xfrm_decode_session wrappers
abc340b38ba25 xfrm: interface: support collect metadata mode
---
 include/net/xfrm.h             | 112 ++++++------------
 include/uapi/linux/if_link.h   |   1 +
 net/ipv4/esp4_offload.c        |  38 +-----
 net/ipv6/esp6_offload.c        |  28 +----
 net/xfrm/xfrm_device.c         |   2 +
 net/xfrm/xfrm_input.c          |   7 +-
 net/xfrm/xfrm_interface_core.c |  27 +++--
 net/xfrm/xfrm_output.c         |   2 +-
 net/xfrm/xfrm_policy.c         |  10 +-
 net/xfrm/xfrm_state.c          | 210 ++++++++-------------------------
 10 files changed, 124 insertions(+), 313 deletions(-)

diff --git a/include/net/xfrm.h b/include/net/xfrm.h
index 3029ac038f99..8ee4f482b526 100644
--- a/include/net/xfrm.h
+++ b/include/net/xfrm.h
@@ -146,7 +146,6 @@ enum {
 
 struct xfrm_dev_offload {
 	struct net_device	*dev;
-	netdevice_tracker	dev_tracker;
 	struct net_device	*real_dev;
 	unsigned long		offload_handle;
 	u8			dir : 2;
@@ -352,25 +351,20 @@ struct xfrm_if_cb {
 void xfrm_if_register_cb(const struct xfrm_if_cb *ifcb);
 void xfrm_if_unregister_cb(void);
 
-struct xfrm_dst_lookup_params {
-	struct net *net;
-	int tos;
-	int oif;
-	xfrm_address_t *saddr;
-	xfrm_address_t *daddr;
-	u32 mark;
-	__u8 ipproto;
-	union flowi_uli uli;
-};
-
 struct net_device;
 struct xfrm_type;
 struct xfrm_dst;
 struct xfrm_policy_afinfo {
 	struct dst_ops		*dst_ops;
-	struct dst_entry	*(*dst_lookup)(const struct xfrm_dst_lookup_params *params);
-	int			(*get_saddr)(xfrm_address_t *saddr,
-					     const struct xfrm_dst_lookup_params *params);
+	struct dst_entry	*(*dst_lookup)(struct net *net,
+						int tos, int oif,
+						const xfrm_address_t *saddr,
+						const xfrm_address_t *daddr,
+						u32 mark);
+	int	(*get_saddr)(struct net *net, int oif,
+						xfrm_address_t *saddr,
+						xfrm_address_t *daddr,
+						u32 mark);
 	int			(*fill_dst)(struct xfrm_dst *xdst,
 					    struct net_device *dev,
 					    const struct flowi *fl);
@@ -436,8 +430,7 @@ struct xfrm_type {
 #define XFRM_TYPE_LOCAL_COADDR	4
 #define XFRM_TYPE_REMOTE_COADDR	8
 
-	int			(*init_state)(struct xfrm_state *x,
-					      struct netlink_ext_ack *extack);
+	int			(*init_state)(struct xfrm_state *x);
 	void			(*destructor)(struct xfrm_state *);
 	int			(*input)(struct xfrm_state *, struct sk_buff *skb);
 	int			(*output)(struct xfrm_state *, struct sk_buff *pskb);
@@ -596,6 +589,7 @@ struct xfrm_policy {
 	u16			family;
 	struct xfrm_sec_ctx	*security;
 	struct xfrm_tmpl       	xfrm_vec[XFRM_MAX_DEPTH];
+	struct hlist_node       bydst_inexact_list;
 	struct rcu_head		rcu;
 
 	struct xfrm_dev_offload xdo;
@@ -655,8 +649,8 @@ struct xfrm_mgr {
 	bool			(*is_alive)(const struct km_event *c);
 };
 
-void xfrm_register_km(struct xfrm_mgr *km);
-void xfrm_unregister_km(struct xfrm_mgr *km);
+int xfrm_register_km(struct xfrm_mgr *km);
+int xfrm_unregister_km(struct xfrm_mgr *km);
 
 struct xfrm_tunnel_skb_cb {
 	union {
@@ -1082,8 +1076,8 @@ struct xfrm_offload {
 #define	CRYPTO_NEXT_DONE	4
 #define	CRYPTO_FALLBACK		8
 #define	XFRM_GSO_SEGMENT	16
-#define	XFRM_GRO		32
-/* 64 is free */
+#define XFRM_GRO 	32
+#define XFRM_ESP_NO_TRAILER 	64
 #define	XFRM_DEV_RESUME		128
 #define	XFRM_XMIT		256
 
@@ -1631,26 +1625,16 @@ struct xfrm_state *xfrm_state_lookup_byspi(struct net *net, __be32 spi,
 					      unsigned short family);
 int xfrm_state_check_expire(struct xfrm_state *x);
 void xfrm_state_update_stats(struct net *net);
-#ifdef CONFIG_XFRM_OFFLOAD
-static inline void xfrm_dev_state_update_stats(struct xfrm_state *x)
-{
-	struct xfrm_dev_offload *xdo = &x->xso;
-	struct net_device *dev = READ_ONCE(xdo->dev);
-
-	if (dev && dev->xfrmdev_ops &&
-	    dev->xfrmdev_ops->xdo_dev_state_update_stats)
-		dev->xfrmdev_ops->xdo_dev_state_update_stats(x);
-
-}
-#else
-static inline void xfrm_dev_state_update_stats(struct xfrm_state *x) {}
-#endif
 void xfrm_state_insert(struct xfrm_state *x);
 int xfrm_state_add(struct xfrm_state *x);
 int xfrm_state_update(struct xfrm_state *x);
 struct xfrm_state *xfrm_state_lookup(struct net *net, u32 mark,
 				     const xfrm_address_t *daddr, __be32 spi,
 				     u8 proto, unsigned short family);
+struct xfrm_state *xfrm_input_state_lookup(struct net *net, u32 mark,
+						const xfrm_address_t *daddr,
+						__be32 spi, u8 proto,
+						unsigned short family);
 struct xfrm_state *xfrm_state_lookup_byaddr(struct net *net, u32 mark,
 					    const xfrm_address_t *daddr,
 					    const xfrm_address_t *saddr,
@@ -1690,7 +1674,7 @@ struct xfrmk_spdinfo {
 	u32 spdhmcnt;
 };
 
-struct xfrm_state *xfrm_find_acq_byseq(struct net *net, u32 mark, u32 seq, u32 pcpu_num);
+struct xfrm_state *xfrm_find_acq_byseq(struct net *net, u32 mark, u32 seq);
 int xfrm_state_delete(struct xfrm_state *x);
 int xfrm_state_flush(struct net *net, u8 proto, bool task_valid, bool sync);
 int xfrm_dev_state_flush(struct net *net, struct net_device *dev, bool task_valid);
@@ -1699,10 +1683,9 @@ int xfrm_dev_policy_flush(struct net *net, struct net_device *dev,
 void xfrm_sad_getinfo(struct net *net, struct xfrmk_sadinfo *si);
 void xfrm_spd_getinfo(struct net *net, struct xfrmk_spdinfo *si);
 u32 xfrm_replay_seqhi(struct xfrm_state *x, __be32 net_seq);
-int xfrm_init_replay(struct xfrm_state *x, struct netlink_ext_ack *extack);
+int xfrm_init_replay(struct xfrm_state *x);
 u32 xfrm_state_mtu(struct xfrm_state *x, int mtu);
-int __xfrm_init_state(struct xfrm_state *x, bool init_replay, bool offload,
-		      struct netlink_ext_ack *extack);
+int __xfrm_init_state(struct xfrm_state *x, bool init_replay, bool offload);
 int xfrm_init_state(struct xfrm_state *x);
 int xfrm_input(struct sk_buff *skb, int nexthdr, __be32 spi, int encap_type);
 int xfrm_input_resume(struct sk_buff *skb, int nexthdr);
@@ -1712,7 +1695,7 @@ int xfrm_trans_queue_net(struct net *net, struct sk_buff *skb,
 int xfrm_trans_queue(struct sk_buff *skb,
 		     int (*finish)(struct net *, struct sock *,
 				   struct sk_buff *));
-int xfrm_output_resume(struct sock *sk, struct sk_buff *skb, int err);
+int xfrm_output_resume(struct sk_buff *skb, int err);
 int xfrm_output(struct sock *sk, struct sk_buff *skb);
 
 #if IS_ENABLED(CONFIG_NET_PKTGEN)
@@ -1775,7 +1758,10 @@ static inline int xfrm_user_policy(struct sock *sk, int optname,
 }
 #endif
 
-struct dst_entry *__xfrm_dst_lookup(int family, const struct xfrm_dst_lookup_params *params);
+struct dst_entry *__xfrm_dst_lookup(struct net *net, int tos, int oif,
+	                                   const xfrm_address_t *saddr,
+	                                   const xfrm_address_t *daddr,
+	                                   int family, u32 mark);
 
 struct xfrm_policy *xfrm_policy_alloc(struct net *net, gfp_t gfp);
 
@@ -1798,11 +1784,10 @@ struct xfrm_policy *xfrm_policy_byid(struct net *net,
 int xfrm_policy_flush(struct net *net, u8 type, bool task_valid);
 void xfrm_policy_hash_rebuild(struct net *net);
 u32 xfrm_get_acqseq(void);
-int verify_spi_info(u8 proto, u32 min, u32 max, struct netlink_ext_ack *extack);
-int xfrm_alloc_spi(struct xfrm_state *x, u32 minspi, u32 maxspi,
-		   struct netlink_ext_ack *extack);
+int verify_spi_info(u8 proto, u32 min, u32 max);
+int xfrm_alloc_spi(struct xfrm_state *x, u32 minspi, u32 maxspi);
 struct xfrm_state *xfrm_find_acq(struct net *net, const struct xfrm_mark *mark,
-				 u8 mode, u32 reqid, u32 if_id, u32 pcpu_num, u8 proto,
+				 u8 mode, u32 reqid, u32 if_id, u8 proto,
 				 const xfrm_address_t *daddr,
 				 const xfrm_address_t *saddr, int create,
 				 unsigned short family);
@@ -1821,8 +1806,7 @@ struct xfrm_state *xfrm_state_migrate(struct xfrm_state *x,
 int xfrm_migrate(const struct xfrm_selector *sel, u8 dir, u8 type,
 		 struct xfrm_migrate *m, int num_bundles,
 		 struct xfrm_kmaddress *k, struct net *net,
-		 struct xfrm_encap_tmpl *encap, u32 if_id,
-		 struct netlink_ext_ack *extack);
+		 struct xfrm_encap_tmpl *encap, u32 if_id);
 #endif
 
 int km_new_mapping(struct xfrm_state *x, xfrm_address_t *ipaddr, __be16 sport);
@@ -1984,8 +1968,7 @@ void xfrm_dev_resume(struct sk_buff *skb);
 void xfrm_dev_backlog(struct softnet_data *sd);
 struct sk_buff *validate_xmit_xfrm(struct sk_buff *skb, netdev_features_t features, bool *again);
 int xfrm_dev_state_add(struct net *net, struct xfrm_state *x,
-		       struct xfrm_user_offload *xuo,
-		       struct netlink_ext_ack *extack);
+		       struct xfrm_user_offload *xuo);
 int xfrm_dev_policy_add(struct net *net, struct xfrm_policy *xp,
 			struct xfrm_user_offload *xuo, u8 dir,
 			struct netlink_ext_ack *extack);
@@ -2020,27 +2003,6 @@ static inline bool xfrm_dst_offload_ok(struct dst_entry *dst)
 	return false;
 }
 
-static inline void xfrm_dev_policy_delete(struct xfrm_policy *x)
-{
-	struct xfrm_dev_offload *xdo = &x->xdo;
-	struct net_device *dev = xdo->dev;
-
-	if (dev && dev->xfrmdev_ops && dev->xfrmdev_ops->xdo_dev_policy_delete)
-		dev->xfrmdev_ops->xdo_dev_policy_delete(x);
-}
-
-static inline void xfrm_dev_policy_free(struct xfrm_policy *x)
-{
-	struct xfrm_dev_offload *xdo = &x->xdo;
-	struct net_device *dev = xdo->dev;
-
-	if (dev && dev->xfrmdev_ops) {
-		if (dev->xfrmdev_ops->xdo_dev_policy_free)
-			dev->xfrmdev_ops->xdo_dev_policy_free(x);
-		xdo->dev = NULL;
-		netdev_put(dev, &xdo->dev_tracker);
-	}
-}
 #else
 static inline void xfrm_dev_resume(struct sk_buff *skb)
 {
@@ -2055,7 +2017,7 @@ static inline struct sk_buff *validate_xmit_xfrm(struct sk_buff *skb, netdev_fea
 	return skb;
 }
 
-static inline int xfrm_dev_state_add(struct net *net, struct xfrm_state *x, struct xfrm_user_offload *xuo, struct netlink_ext_ack *extack)
+static inline int xfrm_dev_state_add(struct net *net, struct xfrm_state *x, struct xfrm_user_offload *xuo)
 {
 	return 0;
 }
@@ -2075,13 +2037,7 @@ static inline int xfrm_dev_policy_add(struct net *net, struct xfrm_policy *xp,
 	return 0;
 }
 
-static inline void xfrm_dev_policy_delete(struct xfrm_policy *x)
-{
-}
 
-static inline void xfrm_dev_policy_free(struct xfrm_policy *x)
-{
-}
 
 static inline bool xfrm_dev_offload_ok(struct sk_buff *skb, struct xfrm_state *x)
 {
@@ -2197,7 +2153,7 @@ static inline bool xfrm6_local_dontfrag(const struct sock *sk)
 
 	proto = sk->sk_protocol;
 	if (proto == IPPROTO_UDP || proto == IPPROTO_RAW)
-		return inet6_test_bit(DONTFRAG, sk);
+		return inet6_sk(sk)->dontfrag;
 
 	return false;
 }
diff --git a/include/uapi/linux/if_link.h b/include/uapi/linux/if_link.h
index cc126982fa3c..3f24464c2b4e 100644
--- a/include/uapi/linux/if_link.h
+++ b/include/uapi/linux/if_link.h
@@ -670,6 +670,7 @@ enum {
 	IFLA_XFRM_UNSPEC,
 	IFLA_XFRM_LINK,
 	IFLA_XFRM_IF_ID,
+	IFLA_XFRM_COLLECT_METADATA,
 	__IFLA_XFRM_MAX
 };
 
diff --git a/net/ipv4/esp4_offload.c b/net/ipv4/esp4_offload.c
index 80c4ea0e12f4..ab6fe94b8fd9 100644
--- a/net/ipv4/esp4_offload.c
+++ b/net/ipv4/esp4_offload.c
@@ -16,8 +16,6 @@
 #include <crypto/authenc.h>
 #include <linux/err.h>
 #include <linux/module.h>
-#include <net/gro.h>
-#include <net/gso.h>
 #include <net/ip.h>
 #include <net/xfrm.h>
 #include <net/esp.h>
@@ -33,7 +31,6 @@ static struct sk_buff *esp4_gro_receive(struct list_head *head,
 	int offset = skb_gro_offset(skb);
 	struct xfrm_offload *xo;
 	struct xfrm_state *x;
-	int encap_type = 0;
 	__be32 seq;
 	__be32 spi;
 
@@ -56,13 +53,6 @@ static struct sk_buff *esp4_gro_receive(struct list_head *head,
 		x = xfrm_state_lookup(dev_net(skb->dev), skb->mark,
 				      (xfrm_address_t *)&ip_hdr(skb)->daddr,
 				      spi, IPPROTO_ESP, AF_INET);
-
-		if (unlikely(x && x->dir && x->dir != XFRM_SA_DIR_IN)) {
-			/* non-offload path will record the error and audit log */
-			xfrm_state_put(x);
-			x = NULL;
-		}
-
 		if (!x)
 			goto out_reset;
 
@@ -78,9 +68,6 @@ static struct sk_buff *esp4_gro_receive(struct list_head *head,
 
 	xo->flags |= XFRM_GRO;
 
-	if (NAPI_GRO_CB(skb)->proto == IPPROTO_UDP)
-		encap_type = UDP_ENCAP_ESPINUDP;
-
 	XFRM_TUNNEL_SKB_CB(skb)->tunnel.ip4 = NULL;
 	XFRM_SPI_SKB_CB(skb)->family = AF_INET;
 	XFRM_SPI_SKB_CB(skb)->daddroff = offsetof(struct iphdr, daddr);
@@ -88,7 +75,7 @@ static struct sk_buff *esp4_gro_receive(struct list_head *head,
 
 	/* We don't need to handle errors from xfrm_input, it does all
 	 * the error handling and frees the resources on error. */
-	xfrm_input(skb, IPPROTO_ESP, spi, encap_type);
+	xfrm_input(skb, IPPROTO_ESP, spi, -2);
 
 	return ERR_PTR(-EINPROGRESS);
 out_reset:
@@ -122,10 +109,8 @@ static struct sk_buff *xfrm4_tunnel_gso_segment(struct xfrm_state *x,
 						struct sk_buff *skb,
 						netdev_features_t features)
 {
-	__be16 type = x->inner_mode.family == AF_INET6 ? htons(ETH_P_IPV6)
-						       : htons(ETH_P_IP);
-
-	return skb_eth_gso_segment(skb, features, type);
+	__skb_push(skb, skb->mac_len);
+	return skb_mac_gso_segment(skb, features);
 }
 
 static struct sk_buff *xfrm4_transport_gso_segment(struct xfrm_state *x,
@@ -271,7 +256,6 @@ static int esp_xmit(struct xfrm_state *x, struct sk_buff *skb,  netdev_features_
 	struct esp_info esp;
 	bool hw_offload = true;
 	__u32 seq;
-	int encap_type = 0;
 
 	esp.inplace = true;
 
@@ -304,10 +288,8 @@ static int esp_xmit(struct xfrm_state *x, struct sk_buff *skb,  netdev_features_
 
 	esp.esph = ip_esp_hdr(skb);
 
-	if (x->encap)
-		encap_type = x->encap->encap_type;
 
-	if (!hw_offload || !skb_is_gso(skb) || (hw_offload && encap_type == UDP_ENCAP_ESPINUDP)) {
+	if (!hw_offload || !skb_is_gso(skb)) {
 		esp.nfrags = esp_output_head(x, skb, &esp);
 		if (esp.nfrags < 0)
 			return esp.nfrags;
@@ -334,18 +316,6 @@ static int esp_xmit(struct xfrm_state *x, struct sk_buff *skb,  netdev_features_
 
 	esp.seqno = cpu_to_be64(seq + ((u64)xo->seq.hi << 32));
 
-	if (hw_offload && encap_type == UDP_ENCAP_ESPINUDP) {
-		/* In the XFRM stack, the encapsulation protocol is set to iphdr->protocol by
-		 * setting *skb_mac_header(skb) (see esp_output_udp_encap()) where skb->mac_header
-		 * points to iphdr->protocol (see xfrm4_tunnel_encap_add()).
-		 * However, in esp_xmit(), skb->mac_header doesn't point to iphdr->protocol.
-		 * Therefore, the protocol field needs to be corrected.
-		 */
-		ip_hdr(skb)->protocol = IPPROTO_UDP;
-
-		esph->seq_no = htonl(seq);
-	}
-
 	ip_hdr(skb)->tot_len = htons(skb->len);
 	ip_send_check(ip_hdr(skb));
 
diff --git a/net/ipv6/esp6_offload.c b/net/ipv6/esp6_offload.c
index 919ebfabbe4e..6b30f34c7978 100644
--- a/net/ipv6/esp6_offload.c
+++ b/net/ipv6/esp6_offload.c
@@ -16,8 +16,6 @@
 #include <crypto/authenc.h>
 #include <linux/err.h>
 #include <linux/module.h>
-#include <net/gro.h>
-#include <net/gso.h>
 #include <net/ip.h>
 #include <net/xfrm.h>
 #include <net/esp.h>
@@ -34,9 +32,7 @@ static __u16 esp6_nexthdr_esp_offset(struct ipv6hdr *ipv6_hdr, int nhlen)
 	int off = sizeof(struct ipv6hdr);
 	struct ipv6_opt_hdr *exthdr;
 
-	/* ESP or ESPINUDP */
-	if (likely(ipv6_hdr->nexthdr == NEXTHDR_ESP ||
-		   ipv6_hdr->nexthdr == NEXTHDR_UDP))
+	if (likely(ipv6_hdr->nexthdr == NEXTHDR_ESP))
 		return offsetof(struct ipv6hdr, nexthdr);
 
 	while (off < nhlen) {
@@ -56,18 +52,15 @@ static struct sk_buff *esp6_gro_receive(struct list_head *head,
 	int offset = skb_gro_offset(skb);
 	struct xfrm_offload *xo;
 	struct xfrm_state *x;
-	int encap_type = 0;
 	__be32 seq;
 	__be32 spi;
 	int nhoff;
-
-	if (NAPI_GRO_CB(skb)->proto == IPPROTO_UDP)
-		encap_type = UDP_ENCAP_ESPINUDP;
+	int err;
 
 	if (!pskb_pull(skb, offset))
 		return NULL;
 
-	if (xfrm_parse_spi(skb, IPPROTO_ESP, &spi, &seq) != 0)
+	if ((err = xfrm_parse_spi(skb, IPPROTO_ESP, &spi, &seq)) != 0)
 		goto out;
 
 	xo = xfrm_offload(skb);
@@ -83,13 +76,6 @@ static struct sk_buff *esp6_gro_receive(struct list_head *head,
 		x = xfrm_state_lookup(dev_net(skb->dev), skb->mark,
 				      (xfrm_address_t *)&ipv6_hdr(skb)->daddr,
 				      spi, IPPROTO_ESP, AF_INET6);
-
-		if (unlikely(x && x->dir && x->dir != XFRM_SA_DIR_IN)) {
-			/* non-offload path will record the error and audit log */
-			xfrm_state_put(x);
-			x = NULL;
-		}
-
 		if (!x)
 			goto out_reset;
 
@@ -117,7 +103,7 @@ static struct sk_buff *esp6_gro_receive(struct list_head *head,
 
 	/* We don't need to handle errors from xfrm_input, it does all
 	 * the error handling and frees the resources on error. */
-	xfrm_input(skb, IPPROTO_ESP, spi, encap_type);
+	xfrm_input(skb, IPPROTO_ESP, spi, -2);
 
 	return ERR_PTR(-EINPROGRESS);
 out_reset:
@@ -158,10 +144,8 @@ static struct sk_buff *xfrm6_tunnel_gso_segment(struct xfrm_state *x,
 						struct sk_buff *skb,
 						netdev_features_t features)
 {
-	__be16 type = x->inner_mode.family == AF_INET ? htons(ETH_P_IP)
-						      : htons(ETH_P_IPV6);
-
-	return skb_eth_gso_segment(skb, features, type);
+	__skb_push(skb, skb->mac_len);
+	return skb_mac_gso_segment(skb, features);
 }
 
 static struct sk_buff *xfrm6_transport_gso_segment(struct xfrm_state *x,
diff --git a/net/xfrm/xfrm_device.c b/net/xfrm/xfrm_device.c
index fa0a84ed09db..da105b62315a 100644
--- a/net/xfrm/xfrm_device.c
+++ b/net/xfrm/xfrm_device.c
@@ -132,6 +132,7 @@ struct sk_buff *validate_xmit_xfrm(struct sk_buff *skb, netdev_features_t featur
 	if (xo->flags & XFRM_GRO || x->xso.flags & XFRM_OFFLOAD_INBOUND)
 		return skb;
 
+#ifdef CONFIG_XFRM_OFFLOAD
 	/* The packet was sent to HW IPsec packet offload engine,
 	 * but to wrong device. Drop the packet, so it won't skip
 	 * XFRM stack.
@@ -141,6 +142,7 @@ struct sk_buff *validate_xmit_xfrm(struct sk_buff *skb, netdev_features_t featur
 		dev_core_stats_tx_dropped_inc(dev);
 		return NULL;
 	}
+#endif
 
 	/* This skb was already validated on the upper/virtual dev */
 	if ((x->xso.dev != dev) && (x->xso.real_dev == dev))
diff --git a/net/xfrm/xfrm_input.c b/net/xfrm/xfrm_input.c
index 992b48023226..62eec8272b24 100644
--- a/net/xfrm/xfrm_input.c
+++ b/net/xfrm/xfrm_input.c
@@ -20,6 +20,7 @@
 #include <net/xfrm.h>
 #include <net/ip_tunnels.h>
 #include <net/ip6_tunnel.h>
+#include <net/dst_metadata.h>
 
 #include "xfrm_inout.h"
 
@@ -728,7 +729,8 @@ int xfrm_input(struct sk_buff *skb, int nexthdr, __be32 spi, int encap_type)
 		sp = skb_sec_path(skb);
 		if (sp)
 			sp->olen = 0;
-		skb_dst_drop(skb);
+		if (skb_valid_dst(skb))
+			skb_dst_drop(skb);
 		gro_cells_receive(&gro_cells, skb);
 		return 0;
 	} else {
@@ -746,7 +748,8 @@ int xfrm_input(struct sk_buff *skb, int nexthdr, __be32 spi, int encap_type)
 			sp = skb_sec_path(skb);
 			if (sp)
 				sp->olen = 0;
-			skb_dst_drop(skb);
+			if (skb_valid_dst(skb))
+				skb_dst_drop(skb);
 			gro_cells_receive(&gro_cells, skb);
 			return err;
 		}
diff --git a/net/xfrm/xfrm_interface_core.c b/net/xfrm/xfrm_interface_core.c
index 2092425738de..240bfc65b4f7 100644
--- a/net/xfrm/xfrm_interface_core.c
+++ b/net/xfrm/xfrm_interface_core.c
@@ -80,8 +80,9 @@ static struct xfrm_if *xfrmi_lookup(struct net *net, struct xfrm_state *x)
 	return NULL;
 }
 
-static struct xfrm_if *xfrmi_decode_session(struct sk_buff *skb,
-					    unsigned short family)
+static bool xfrmi_decode_session(struct sk_buff *skb,
+	                              unsigned short family,
+                                struct xfrm_if_decode_session_result *res)
 {
 	struct net_device *dev;
 	int ifindex = 0;
@@ -158,7 +159,6 @@ static int xfrmi_create(struct net_device *dev)
 		goto out;
 
 	xfrmi_link(xfrmn, xi);
-
 	return 0;
 
 out:
@@ -186,6 +186,7 @@ static void xfrmi_dev_uninit(struct net_device *dev)
 	struct xfrmi_net *xfrmn = net_generic(xi->net, xfrmi_net_id);
 
 	xfrmi_unlink(xfrmn, xi);
+
 }
 
 static void xfrmi_scrub_packet(struct sk_buff *skb, bool xnet)
@@ -633,6 +634,7 @@ static void xfrmi_netlink_parms(struct nlattr *data[],
 
 	if (data[IFLA_XFRM_IF_ID])
 		parms->if_id = nla_get_u32(data[IFLA_XFRM_IF_ID]);
+
 }
 
 static int xfrmi_newlink(struct net *src_net, struct net_device *dev,
@@ -645,14 +647,14 @@ static int xfrmi_newlink(struct net *src_net, struct net_device *dev,
 	int err;
 
 	xfrmi_netlink_parms(data, &p);
-	if (!p.if_id) {
+  if (!p.if_id) {
 		NL_SET_ERR_MSG(extack, "if_id must be non zero");
-		return -EINVAL;
-	}
+	    return -EINVAL;
+  }
 
-	xi = xfrmi_locate(net, &p);
-	if (xi)
-		return -EEXIST;
+  xi = xfrmi_locate(net, &p);
+  if (xi)
+    return -EEXIST;
 
 	xi = netdev_priv(dev);
 	xi->p = p;
@@ -709,7 +711,8 @@ static int xfrmi_fill_info(struct sk_buff *skb, const struct net_device *dev)
 	struct xfrm_if_parms *parm = &xi->p;
 
 	if (nla_put_u32(skb, IFLA_XFRM_LINK, parm->link) ||
-	    nla_put_u32(skb, IFLA_XFRM_IF_ID, parm->if_id))
+		nla_put_u32(skb, IFLA_XFRM_IF_ID, parm->if_id))
+
 		goto nla_put_failure;
 	return 0;
 
@@ -725,8 +728,8 @@ static struct net *xfrmi_get_link_net(const struct net_device *dev)
 }
 
 static const struct nla_policy xfrmi_policy[IFLA_XFRM_MAX + 1] = {
-	[IFLA_XFRM_LINK]	= { .type = NLA_U32 },
-	[IFLA_XFRM_IF_ID]	= { .type = NLA_U32 },
+	[IFLA_XFRM_LINK]        = { .type = NLA_U32 },
+	[IFLA_XFRM_IF_ID]       = { .type = NLA_U32 },
 };
 
 static struct rtnl_link_ops xfrmi_link_ops __read_mostly = {
diff --git a/net/xfrm/xfrm_output.c b/net/xfrm/xfrm_output.c
index 7909ef9e2267..81769a03e3c5 100644
--- a/net/xfrm/xfrm_output.c
+++ b/net/xfrm/xfrm_output.c
@@ -723,7 +723,7 @@ int xfrm_output(struct sock *sk, struct sk_buff *skb)
 			return -EHOSTUNREACH;
 		}
 
-		return xfrm_output_resume(sk, skb, 0);
+		return xfrm_output_resume(skb, 0);
 	}
 
 	secpath_reset(skb);
diff --git a/net/xfrm/xfrm_policy.c b/net/xfrm/xfrm_policy.c
index 4f37ddb459b3..7943110d2346 100644
--- a/net/xfrm/xfrm_policy.c
+++ b/net/xfrm/xfrm_policy.c
@@ -3525,17 +3525,17 @@ int __xfrm_policy_check(struct sock *sk, int dir, struct sk_buff *skb,
 	int xerr_idx = -1;
 	const struct xfrm_if_cb *ifcb;
 	struct sec_path *sp;
-	struct xfrm_if *xi;
 	u32 if_id = 0;
 
 	rcu_read_lock();
 	ifcb = xfrm_if_get_cb();
 
 	if (ifcb) {
-		xi = ifcb->decode_session(skb, family);
-		if (xi) {
-			if_id = xi->p.if_id;
-			net = xi->net;
+		struct xfrm_if_decode_session_result r;
+
+		if (ifcb->decode_session(skb, family, &r)) {
+			if_id = r.if_id;
+			net = r.net;
 		}
 	}
 	rcu_read_unlock();
diff --git a/net/xfrm/xfrm_state.c b/net/xfrm/xfrm_state.c
index 1471ffffc4a8..6b4caa11eb31 100644
--- a/net/xfrm/xfrm_state.c
+++ b/net/xfrm/xfrm_state.c
@@ -51,7 +51,6 @@ static struct kmem_cache *xfrm_state_cache __ro_after_init;
 
 static DECLARE_WORK(xfrm_state_gc_work, xfrm_state_gc_task);
 static HLIST_HEAD(xfrm_state_gc_list);
-static HLIST_HEAD(xfrm_state_dev_gc_list);
 
 static inline bool xfrm_state_hold_rcu(struct xfrm_state __rcu *x)
 {
@@ -223,7 +222,6 @@ static DEFINE_SPINLOCK(xfrm_state_afinfo_lock);
 static struct xfrm_state_afinfo __rcu *xfrm_state_afinfo[NPROTO];
 
 static DEFINE_SPINLOCK(xfrm_state_gc_lock);
-static DEFINE_SPINLOCK(xfrm_state_dev_gc_lock);
 
 int __xfrm_state_delete(struct xfrm_state *x);
 
@@ -580,7 +578,6 @@ static enum hrtimer_restart xfrm_timer_handler(struct hrtimer *me)
 	int err = 0;
 
 	spin_lock(&x->lock);
-	xfrm_dev_state_update_stats(x);
 
 	if (x->km.state == XFRM_STATE_DEAD)
 		goto out;
@@ -859,7 +856,6 @@ EXPORT_SYMBOL(xfrm_state_flush);
 int xfrm_dev_state_flush(struct net *net, struct net_device *dev, bool task_valid)
 {
 	struct xfrm_state *x;
-	struct hlist_node *tmp;
 	struct xfrm_dev_offload *xso;
 	int i, err = 0, cnt = 0;
 
@@ -1077,51 +1073,53 @@ static struct xfrm_state *__xfrm_state_lookup(const struct xfrm_hash_state_ptrs
 }
 
 struct xfrm_state *xfrm_input_state_lookup(struct net *net, u32 mark,
-					   const xfrm_address_t *daddr,
-					   __be32 spi, u8 proto,
-					   unsigned short family)
-{
-	struct xfrm_hash_state_ptrs state_ptrs;
-	struct hlist_head *state_cache_input;
-	struct xfrm_state *x = NULL;
-
-	state_cache_input =  per_cpu_ptr(net->xfrm.state_cache_input, cpu);
-
-	rcu_read_lock();
-	hlist_for_each_entry_rcu(x, state_cache_input, state_cache_input) {
-		if (x->props.family != family ||
-		    x->id.spi       != spi ||
-		    x->id.proto     != proto ||
-		    !xfrm_addr_equal(&x->id.daddr, daddr, family))
-			continue;
-
-		if ((mark & x->mark.m) != x->mark.v)
-			continue;
-		if (!xfrm_state_hold_rcu(x))
-			continue;
-		goto out;
-	}
-
-	xfrm_hash_ptrs_get(net, &state_ptrs);
-
-	x = __xfrm_state_lookup(&state_ptrs, mark, daddr, spi, proto, family);
-
-	if (x && x->km.state == XFRM_STATE_VALID) {
-		spin_lock_bh(&net->xfrm.xfrm_state_lock);
-		if (hlist_unhashed(&x->state_cache_input)) {
-			hlist_add_head_rcu(&x->state_cache_input, state_cache_input);
-		} else {
-			hlist_del_rcu(&x->state_cache_input);
-			hlist_add_head_rcu(&x->state_cache_input, state_cache_input);
-		}
-		spin_unlock_bh(&net->xfrm.xfrm_state_lock);
-	}
-
-out:
-	rcu_read_unlock();
-	return x;
-}
-EXPORT_SYMBOL(xfrm_input_state_lookup);
+                                           const xfrm_address_t *daddr,
+                                           __be32 spi, u8 proto,
+                                           unsigned short family)
+ {
+        struct xfrm_hash_state_ptrs state_ptrs;
+        struct hlist_head *state_cache_input;
+        struct xfrm_state *x = NULL;
+        int cpu = get_cpu();
+
+        state_cache_input =  per_cpu_ptr(net->xfrm.state_cache_input, cpu);
+
+        rcu_read_lock();
+        hlist_for_each_entry_rcu(x, state_cache_input, state_cache_input) {
+                if (x->props.family != family ||
+                        x->id.spi       != spi ||
+                        x->id.proto     != proto ||
+                        !xfrm_addr_equal(&x->id.daddr, daddr, family))
+                        continue;
+
+                if ((mark & x->mark.m) != x->mark.v)
+                        continue;
+                if (!xfrm_state_hold_rcu(x))
+                        continue;
+                goto out;
+        }
+
+        xfrm_hash_ptrs_get(net, &state_ptrs);
+
+        x = __xfrm_state_lookup(&state_ptrs, mark, daddr, spi, proto, family);
+
+        if (x && x->km.state == XFRM_STATE_VALID) {
+                spin_lock_bh(&net->xfrm.xfrm_state_lock);
+                if (hlist_unhashed(&x->state_cache_input)) {
+                        hlist_add_head_rcu(&x->state_cache_input, state_cache_input);
+                } else {
+                        hlist_del_rcu(&x->state_cache_input);
+                        hlist_add_head_rcu(&x->state_cache_input, state_cache_input);
+                }
+                spin_unlock_bh(&net->xfrm.xfrm_state_lock);
+        }
+
+ out:
+        rcu_read_unlock();
+        put_cpu();
+        return x;
+ }
+ EXPORT_SYMBOL(xfrm_input_state_lookup);
 
 static struct xfrm_state *__xfrm_state_lookup_byaddr(const struct xfrm_hash_state_ptrs *state_ptrs,
 						     u32 mark,
@@ -1218,6 +1216,7 @@ static void xfrm_state_look_at(struct xfrm_policy *pol, struct xfrm_state *x,
 	}
 }
 
+
 struct xfrm_state *
 xfrm_state_find(const xfrm_address_t *daddr, const xfrm_address_t *saddr,
 		const struct flowi *fl, struct xfrm_tmpl *tmpl,
@@ -1242,67 +1241,12 @@ xfrm_state_find(const xfrm_address_t *daddr, const xfrm_address_t *saddr,
 	sequence = read_seqcount_begin(&net->xfrm.xfrm_state_hash_generation);
 
 	rcu_read_lock();
-	hlist_for_each_entry_rcu(x, &pol->state_cache_list, state_cache) {
-		if (x->props.family == encap_family &&
-		    x->props.reqid == tmpl->reqid &&
-		    (mark & x->mark.m) == x->mark.v &&
-		    x->if_id == if_id &&
-		    !(x->props.flags & XFRM_STATE_WILDRECV) &&
-		    xfrm_state_addr_check(x, daddr, saddr, encap_family) &&
-		    tmpl->mode == x->props.mode &&
-		    tmpl->id.proto == x->id.proto &&
-		    (tmpl->id.spi == x->id.spi || !tmpl->id.spi))
-			xfrm_state_look_at(pol, x, fl, encap_family,
-					   &best, &acquire_in_progress, &error);
-	}
-
-	if (best)
-		goto cached;
-
-	hlist_for_each_entry_rcu(x, &pol->state_cache_list, state_cache) {
-		if (x->props.family == encap_family &&
-		    x->props.reqid == tmpl->reqid &&
-		    (mark & x->mark.m) == x->mark.v &&
-		    x->if_id == if_id &&
-		    !(x->props.flags & XFRM_STATE_WILDRECV) &&
-		    xfrm_addr_equal(&x->id.daddr, daddr, encap_family) &&
-		    tmpl->mode == x->props.mode &&
-		    tmpl->id.proto == x->id.proto &&
-		    (tmpl->id.spi == x->id.spi || !tmpl->id.spi))
-			xfrm_state_look_at(pol, x, fl, family,
-					   &best, &acquire_in_progress, &error);
-	}
-
-cached:
-	cached = true;
-	if (best)
-		goto found;
-	else if (error)
-		best = NULL;
-	else if (acquire_in_progress) /* XXX: acquire_in_progress should not happen */
-		WARN_ON(1);
 
 	xfrm_hash_ptrs_get(net, &state_ptrs);
 
 	h = __xfrm_dst_hash(daddr, saddr, tmpl->reqid, encap_family, state_ptrs.hmask);
 	hlist_for_each_entry_rcu(x, state_ptrs.bydst + h, bydst) {
-#ifdef CONFIG_XFRM_OFFLOAD
-		if (pol->xdo.type == XFRM_DEV_OFFLOAD_PACKET) {
-			if (x->xso.type != XFRM_DEV_OFFLOAD_PACKET)
-				/* HW states are in the head of list, there is
-				 * no need to iterate further.
-				 */
-				break;
 
-			/* Packet offload: both policy and SA should
-			 * have same device.
-			 */
-			if (pol->xdo.dev != x->xso.dev)
-				continue;
-		} else if (x->xso.type == XFRM_DEV_OFFLOAD_PACKET)
-			/* Skip HW policy for SW lookups */
-			continue;
-#endif
 		if (x->props.family == encap_family &&
 		    x->props.reqid == tmpl->reqid &&
 		    (mark & x->mark.m) == x->mark.v &&
@@ -1319,25 +1263,8 @@ xfrm_state_find(const xfrm_address_t *daddr, const xfrm_address_t *saddr,
 		goto found;
 
 	h_wildcard = __xfrm_dst_hash(daddr, &saddr_wildcard, tmpl->reqid,
-				     encap_family, state_ptrs.hmask);
+			encap_family, state_ptrs.hmask);
 	hlist_for_each_entry_rcu(x, state_ptrs.bydst + h_wildcard, bydst) {
-#ifdef CONFIG_XFRM_OFFLOAD
-		if (pol->xdo.type == XFRM_DEV_OFFLOAD_PACKET) {
-			if (x->xso.type != XFRM_DEV_OFFLOAD_PACKET)
-				/* HW states are in the head of list, there is
-				 * no need to iterate further.
-				 */
-				break;
-
-			/* Packet offload: both policy and SA should
-			 * have same device.
-			 */
-			if (pol->xdo.dev != x->xso.dev)
-				continue;
-		} else if (x->xso.type == XFRM_DEV_OFFLOAD_PACKET)
-			/* Skip HW policy for SW lookups */
-			continue;
-#endif
 		if (x->props.family == encap_family &&
 		    x->props.reqid == tmpl->reqid &&
 		    (mark & x->mark.m) == x->mark.v &&
@@ -1392,31 +1319,7 @@ xfrm_state_find(const xfrm_address_t *daddr, const xfrm_address_t *saddr,
 			x = NULL;
 			goto out;
 		}
-#ifdef CONFIG_XFRM_OFFLOAD
-		if (pol->xdo.type == XFRM_DEV_OFFLOAD_PACKET) {
-			struct xfrm_dev_offload *xdo = &pol->xdo;
-			struct xfrm_dev_offload *xso = &x->xso;
-
-			xso->type = XFRM_DEV_OFFLOAD_PACKET;
-			xso->dir = xdo->dir;
-			xso->dev = xdo->dev;
-			xso->real_dev = xdo->real_dev;
-			netdev_tracker_alloc(xso->dev, &xso->dev_tracker,
-					     GFP_ATOMIC);
-			error = xso->dev->xfrmdev_ops->xdo_dev_state_add(x);
-			if (error) {
-				xso->dir = 0;
-				netdev_put(xso->dev, &xso->dev_tracker);
-				xso->dev = NULL;
-				xso->real_dev = NULL;
-				xso->type = XFRM_DEV_OFFLOAD_UNSPECIFIED;
-				x->km.state = XFRM_STATE_DEAD;
-				to_put = x;
-				x = NULL;
-				goto out;
-			}
-		}
-#endif
+
 		if (km_query(x, tmpl, pol) == 0) {
 			spin_lock_bh(&net->xfrm.xfrm_state_lock);
 			x->km.state = XFRM_STATE_ACQ;
@@ -1440,18 +1343,6 @@ xfrm_state_find(const xfrm_address_t *daddr, const xfrm_address_t *saddr,
 			xfrm_hash_grow_check(net, x->bydst.next != NULL);
 			spin_unlock_bh(&net->xfrm.xfrm_state_lock);
 		} else {
-#ifdef CONFIG_XFRM_OFFLOAD
-			struct xfrm_dev_offload *xso = &x->xso;
-
-			if (xso->type == XFRM_DEV_OFFLOAD_PACKET) {
-				xso->dev->xfrmdev_ops->xdo_dev_state_delete(x);
-				xso->dir = 0;
-				netdev_put(xso->dev, &xso->dev_tracker);
-				xso->dev = NULL;
-				xso->real_dev = NULL;
-				xso->type = XFRM_DEV_OFFLOAD_UNSPECIFIED;
-			}
-#endif
 			x->km.state = XFRM_STATE_DEAD;
 			to_put = x;
 			x = NULL;
@@ -2267,6 +2158,7 @@ static struct xfrm_state *__xfrm_find_acq_byseq(struct net *net, u32 mark, u32 s
 	return NULL;
 }
 
+
 struct xfrm_state *xfrm_find_acq_byseq(struct net *net, u32 mark, u32 seq)
 {
 	struct xfrm_state *x;
-- 
2.25.1

