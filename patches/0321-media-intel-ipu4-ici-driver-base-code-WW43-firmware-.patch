From 9ffff8270a1993413c04917a6a2d14cdc369d419 Mon Sep 17 00:00:00 2001
From: "Yew, Chang Ching" <chang.ching.yew@intel.com>
Date: Tue, 23 Oct 2018 13:23:05 +0800
Subject: [PATCH 0321/1132] media: intel-ipu4: ici driver base code; WW43
 firmware f61e455.

Base code for IPU ICI driver (Image Capture Interface).
These patches add input system driver for Camera IPU interface.
Squash of following patches from
https://github.com/intel/linux-intel-lts/tree/4.14/base/drivers/media/pci/intel/ici/

153823 media: ici: Remove set_pipeline_format when setting stream format
e54253 media-intel-ipu4: ICI: Use standard values for memory type enums
ef18ca media: intel-ipu4: ici: YUYV format support for HDMI
ec4a1c Add dependencies in Kconfig for ICI
f50ea8 ici: Change fourcc value for ICI_FORMAT_RGB888
9f77cd media: ici: fix for mem-leak pointed out by KW
e6c0df ici: Check null pointer to avoid null pointer dereferencing
79f804 media:intel-ipu: dma functions for ici driver
8c08f8 media: intel-ipu: ICI camera driver WW16 2018 FW version: 20180412

Change-Id: I7a5bf16cfccc11ab9a0e4d32fdb31f0355e8c50a
Signed-off-by: Yew, Chang Ching <chang.ching.yew@intel.com>
---
 drivers/media/pci/intel/Kconfig                    |   33 +
 drivers/media/pci/intel/Makefile                   |   13 +-
 drivers/media/pci/intel/ici-fw-isys.h              |   25 +
 drivers/media/pci/intel/ici/Makefile               |   73 +
 drivers/media/pci/intel/ici/ici-dma.c              |  417 ++++++
 drivers/media/pci/intel/ici/ici-isys-csi2-be.c     |  280 ++++
 drivers/media/pci/intel/ici/ici-isys-csi2-be.h     |   36 +
 drivers/media/pci/intel/ici/ici-isys-csi2.c        |  532 +++++++
 drivers/media/pci/intel/ici/ici-isys-csi2.h        |  156 +++
 drivers/media/pci/intel/ici/ici-isys-frame-buf.c   |  950 +++++++++++++
 drivers/media/pci/intel/ici/ici-isys-frame-buf.h   |  139 ++
 .../media/pci/intel/ici/ici-isys-pipeline-device.c |  493 +++++++
 .../media/pci/intel/ici/ici-isys-pipeline-device.h |   62 +
 drivers/media/pci/intel/ici/ici-isys-pipeline.c    |  174 +++
 drivers/media/pci/intel/ici/ici-isys-pipeline.h    |   98 ++
 .../media/pci/intel/ici/ici-isys-stream-device.c   |  397 ++++++
 .../media/pci/intel/ici/ici-isys-stream-device.h   |   58 +
 drivers/media/pci/intel/ici/ici-isys-stream.c      | 1450 ++++++++++++++++++++
 drivers/media/pci/intel/ici/ici-isys-stream.h      |   85 ++
 drivers/media/pci/intel/ici/ici-isys-subdev.c      |  548 ++++++++
 drivers/media/pci/intel/ici/ici-isys-subdev.h      |  110 ++
 drivers/media/pci/intel/ici/ici-isys-tpg.c         |  214 +++
 drivers/media/pci/intel/ici/ici-isys-tpg.h         |   47 +
 drivers/media/pci/intel/ici/ici-isys.c             | 1367 ++++++++++++++++++
 drivers/media/pci/intel/ici/ici-isys.h             |  212 +++
 drivers/media/pci/intel/ici/libintel-ipu4_ici.c    |  403 ++++++
 include/media/ici.h                                |  141 ++
 include/uapi/linux/ici.h                           |  203 +++
 28 files changed, 8714 insertions(+), 2 deletions(-)
 create mode 100644 drivers/media/pci/intel/ici-fw-isys.h
 create mode 100644 drivers/media/pci/intel/ici/Makefile
 create mode 100644 drivers/media/pci/intel/ici/ici-dma.c
 create mode 100644 drivers/media/pci/intel/ici/ici-isys-csi2-be.c
 create mode 100644 drivers/media/pci/intel/ici/ici-isys-csi2-be.h
 create mode 100644 drivers/media/pci/intel/ici/ici-isys-csi2.c
 create mode 100644 drivers/media/pci/intel/ici/ici-isys-csi2.h
 create mode 100644 drivers/media/pci/intel/ici/ici-isys-frame-buf.c
 create mode 100644 drivers/media/pci/intel/ici/ici-isys-frame-buf.h
 create mode 100644 drivers/media/pci/intel/ici/ici-isys-pipeline-device.c
 create mode 100644 drivers/media/pci/intel/ici/ici-isys-pipeline-device.h
 create mode 100644 drivers/media/pci/intel/ici/ici-isys-pipeline.c
 create mode 100644 drivers/media/pci/intel/ici/ici-isys-pipeline.h
 create mode 100644 drivers/media/pci/intel/ici/ici-isys-stream-device.c
 create mode 100644 drivers/media/pci/intel/ici/ici-isys-stream-device.h
 create mode 100644 drivers/media/pci/intel/ici/ici-isys-stream.c
 create mode 100644 drivers/media/pci/intel/ici/ici-isys-stream.h
 create mode 100644 drivers/media/pci/intel/ici/ici-isys-subdev.c
 create mode 100644 drivers/media/pci/intel/ici/ici-isys-subdev.h
 create mode 100644 drivers/media/pci/intel/ici/ici-isys-tpg.c
 create mode 100644 drivers/media/pci/intel/ici/ici-isys-tpg.h
 create mode 100644 drivers/media/pci/intel/ici/ici-isys.c
 create mode 100644 drivers/media/pci/intel/ici/ici-isys.h
 create mode 100644 drivers/media/pci/intel/ici/libintel-ipu4_ici.c
 create mode 100644 include/media/ici.h
 create mode 100644 include/uapi/linux/ici.h

diff --git a/drivers/media/pci/intel/Kconfig b/drivers/media/pci/intel/Kconfig
index f9fcbc6..714a668 100644
--- a/drivers/media/pci/intel/Kconfig
+++ b/drivers/media/pci/intel/Kconfig
@@ -57,3 +57,36 @@ config VIDEO_INTEL_IPU_WERROR
 	  Recommended for driver developers only.
 
 	  If in doubt, say "N".
+
+config VIDEO_INTEL_ICI
+        depends on VIDEO_INTEL_IPU
+        bool "Compile for ICI driver"
+        ---help---
+        If selected ICI driver will be compiled
+
+config VIDEO_INTEL_UOS
+        bool "Compile driver per UOS"
+        ---help---
+        If selected UOS driver components will be compiled
+
+config VIDEO_INTEL_IPU_ACRN
+        depends on X86_64
+        bool "Compile for virtio mediation"
+
+choice
+    prompt "Virtio driver type"
+    depends on VIDEO_INTEL_IPU_ACRN
+    default VIDEO_INTEL_IPU_VIRTIO_BE
+
+config VIDEO_INTEL_IPU_VIRTIO_BE
+    bool "Configure IPU4 as virtio backend"
+    depends on VBS
+        ---help---
+    Configuring IPU4 driver as virtio backend
+
+config VIDEO_INTEL_IPU_VIRTIO_FE
+    bool "Configure IPU4 as virtio frontend"
+    ---help---
+    Configuring IPU4 driver as virtio frontend
+
+endchoice
diff --git a/drivers/media/pci/intel/Makefile b/drivers/media/pci/intel/Makefile
index f269618..d46da91c 100644
--- a/drivers/media/pci/intel/Makefile
+++ b/drivers/media/pci/intel/Makefile
@@ -1,5 +1,11 @@
 # SPDX-License-Identifier: GPL-2.0
 # Copyright (c) 2010 - 2018, Intel Corporation.
+#
+#
+# Makefile for the IPU3 cio2, ImGU and IPU4 drivers
+#
+
+obj-y	+= ipu3/
 
 # force check the compile warning to make sure zero warnings
 # note we may have build issue when gcc upgraded.
@@ -9,6 +15,9 @@ subdir-ccflags-y += $(call cc-disable-warning, implicit-fallthrough)
 subdir-ccflags-y += $(call cc-disable-warning, missing-field-initializers)
 subdir-ccflags-$(CONFIG_VIDEO_INTEL_IPU_WERROR) += -Werror
 
-obj-$(CONFIG_VIDEO_INTEL_IPU4)	+= ipu4/
+ifndef CONFIG_VIDEO_INTEL_ICI
+obj-$(CONFIG_VIDEO_INTEL_IPU4)  += ipu4/
 obj-$(CONFIG_VIDEO_INTEL_IPU4P)	+= ipu4/
-obj-y	+= ipu3/
+endif
+obj-$(CONFIG_VIDEO_INTEL_ICI)   += ici/
+obj-$(CONFIG_VIDEO_INTEL_IPU_ACRN)      += virtio/
diff --git a/drivers/media/pci/intel/ici-fw-isys.h b/drivers/media/pci/intel/ici-fw-isys.h
new file mode 100644
index 0000000..afd7537
--- /dev/null
+++ b/drivers/media/pci/intel/ici-fw-isys.h
@@ -0,0 +1,25 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (C) 2013 - 2018 Intel Corporation */
+
+#ifndef ICI_FW_ISYS_H
+#define ICI_FW_ISYS_H
+
+#include "ipu-fw-com.h"
+
+struct ici_isys;
+int ici_fw_isys_init(struct ici_isys *isys, unsigned int num_streams);
+int ici_fw_isys_close(struct ici_isys *isys);
+int ici_fw_isys_simple_cmd(struct ici_isys *isys,
+                           const unsigned int stream_handle,
+                           enum ipu_fw_isys_send_type send_type);
+int ici_fw_isys_complex_cmd(struct ici_isys *isys,
+                            const unsigned int stream_handle,
+                            void *cpu_mapped_buf,
+                            dma_addr_t dma_mapped_buf,
+                            size_t size, enum ipu_fw_isys_send_type send_type);
+int ici_fw_isys_send_proxy_token(struct ici_isys *isys,
+                                 unsigned int req_id,
+                                 unsigned int index,
+                                 unsigned int offset, u32 value);
+void ici_fw_isys_cleanup(struct ici_isys *isys);
+#endif
diff --git a/drivers/media/pci/intel/ici/Makefile b/drivers/media/pci/intel/ici/Makefile
new file mode 100644
index 0000000..59a2561
--- /dev/null
+++ b/drivers/media/pci/intel/ici/Makefile
@@ -0,0 +1,73 @@
+# SPDX-License-Identifier: GPL-2.0
+# Copyright (c) 2010 - 2018, Intel Corporation.
+
+ifneq ($(EXTERNAL_BUILD), 1)
+srcpath := $(srctree)
+endif
+
+ifdef CONFIG_VIDEO_INTEL_ICI
+ccflags-y += -DHAS_DUAL_CMD_CTX_SUPPORT=0 -DIPU_VC_SUPPORT -DIPU_HAS_ISA -DIPU_PSYS_LEGACY -Wframe-larger-than=4096
+
+
+# work-around to re-use ipu4-css and libintel-ipu4_ici.c together when
+# compiling ICI-ISYS
+$(shell cp -r $(srcpath)/$(src)/../ipu4/ipu4-css/ $(srcpath)/$(src)/)
+$(shell cp -f $(srcpath)/$(src)/libintel-ipu4_ici.c $(srcpath)/$(src)/ipu4-css/libintel-ipu4.c)
+$(shell cp -f $(srcpath)/$(src)/../ipu4/ipu-platform-resources.h $(srcpath)/$(src)/)
+
+intel-ipu4-objs			+=../ipu.o \
+				  ../ipu-bus.o \
+				  ici-dma.o \
+				  ../ipu-buttress.o \
+				  ../ipu-trace.o \
+				  ../ipu-cpd.o \
+				  ../ipu-fw-com.o \
+				  ../ipu4/ipu4.o
+
+obj-$(CONFIG_VIDEO_INTEL_IPU)		+= intel-ipu4.o
+
+intel-ipu4-mmu-objs			+= ../ipu-mmu.o
+obj-$(CONFIG_VIDEO_INTEL_IPU)		+= intel-ipu4-mmu.o
+
+ici-isys-mod-objs += \
+                       ici-isys.o \
+                       ici-isys-csi2.o \
+                       ici-isys-tpg.o \
+                       ici-isys-csi2-be.o \
+                       ici-isys-stream.o \
+                       ici-isys-frame-buf.o \
+                       ici-isys-subdev.o \
+                       ici-isys-pipeline.o \
+                       ici-isys-pipeline-device.o \
+                       ici-isys-stream-device.o
+obj-$(CONFIG_VIDEO_INTEL_IPU)          += ici-isys-mod.o
+
+intel-ipu4-psys-objs	+= ../ipu-psys.o \
+			   ../ipu4/ipu4-resources.o \
+			   ../ipu4/ipu4-psys.o \
+
+ifndef CONFIG_VIDEO_INTEL_IPU_FW_LIB
+intel-ipu4-psys-objs	+= ipu4-fw-resources.o \
+			../ipu-fw-psys.o
+endif
+
+ifeq ($(CONFIG_COMPAT),y)
+intel-ipu4-psys-objs	+= ../ipu-psys-compat32.o
+endif
+
+obj-$(CONFIG_VIDEO_INTEL_IPU)		+= intel-ipu4-psys.o
+
+ifdef CONFIG_VIDEO_INTEL_IPU_FW_LIB
+include $(srcpath)/$(src)/ipu4-css/Makefile.isyslib
+include $(srcpath)/$(src)/ipu4-css/Makefile.psyslib
+endif
+
+subdir-ccflags-y += -I$(srcpath)/$(src)/../../../../../include/
+subdir-ccflags-y += -I$(srcpath)/$(src)/../
+subdir-ccflags-y += -I$(srcpath)/$(src)/../ipu4/
+subdir-ccflags-y += -I$(srcpath)/$(src)/
+subdir-ccflags-y += -I$(srcpath)/$(src)/ipu4-css
+
+ccflags-y += -DPARAMETER_INTERFACE_V2
+
+endif
diff --git a/drivers/media/pci/intel/ici/ici-dma.c b/drivers/media/pci/intel/ici/ici-dma.c
new file mode 100644
index 0000000..da501a2
--- /dev/null
+++ b/drivers/media/pci/intel/ici/ici-dma.c
@@ -0,0 +1,417 @@
+// SPDX-License-Identifier: (BSD-3-Clause OR GPL-2.0)
+/*
+ * Copyright (C) 2018 Intel Corporation
+ */
+
+#include <asm/cacheflush.h>
+
+#include <linux/device.h>
+#include <linux/dma-mapping.h>
+#include <linux/gfp.h>
+#include <linux/highmem.h>
+#include <linux/iommu.h>
+#include <linux/iova.h>
+#include <linux/module.h>
+#include <linux/scatterlist.h>
+#include <linux/vmalloc.h>
+
+#include "ipu-dma.h"
+#include "ipu-mmu.h"
+
+static struct page **__intel_ipu4_dma_alloc(struct device *dev,
+					    size_t buf_size,
+					    gfp_t gfp,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0)
+					    struct dma_attrs *attrs
+#else
+					    unsigned long attrs
+#endif
+					 )
+{
+	int num_pages = buf_size >> PAGE_SHIFT;
+	int array_size = num_pages * sizeof(struct page *);
+	struct page **page_list;
+	int i = 0;
+
+	if (array_size <= PAGE_SIZE)
+		page_list = kzalloc(array_size, GFP_KERNEL);
+	else
+		page_list = vzalloc(array_size);
+	if (!page_list)
+		return NULL;
+
+	gfp |= __GFP_NOWARN;
+
+	while (num_pages) {
+		int j, order = __fls(num_pages);
+
+		page_list[i] = alloc_pages(gfp, order);
+		while (!page_list[i] && order)
+			page_list[i] = alloc_pages(gfp, --order);
+		if (!page_list[i])
+			goto error;
+
+		if (order) {
+			split_page(page_list[i], order);
+			j = 1 << order;
+			while (--j)
+				page_list[i + j] = page_list[i] + j;
+		}
+
+		i += 1 << order;
+		num_pages -= 1 << order;
+	}
+
+	return page_list;
+error:
+	while (i--)
+		if (page_list[i])
+			__free_pages(page_list[i], 0);
+	if (array_size <= PAGE_SIZE)
+		kfree(page_list);
+	else
+		vfree(page_list);
+	return NULL;
+}
+
+static int __intel_ipu4_dma_free(struct device *dev, struct page **page_list,
+			       size_t buf_size,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0)
+			       struct dma_attrs *attrs
+#else
+			       unsigned long attrs
+#endif
+			      )
+{
+	int num_pages = buf_size >> PAGE_SHIFT;
+	int array_size = num_pages * sizeof(struct page *);
+	int i;
+
+	for (i = 0; i < num_pages; i++) {
+		if (page_list[i]) {
+			__free_pages(page_list[i], 0);
+		}
+	}
+
+	if (array_size <= PAGE_SIZE)
+		kfree(page_list);
+	else
+		vfree(page_list);
+	return 0;
+}
+
+static void intel_ipu4_dma_sync_single_for_cpu(
+	struct device *dev, dma_addr_t dma_handle, size_t size,
+	enum dma_data_direction dir)
+{
+	struct device *aiommu = to_ipu_bus_device(dev)->iommu;
+	struct ipu_mmu *mmu = dev_get_drvdata(aiommu);
+
+	clflush_cache_range(
+		phys_to_virt(iommu_iova_to_phys(
+				     mmu->dmap->domain, dma_handle)), size);
+}
+
+static void intel_ipu4_dma_sync_sg_for_cpu(
+	struct device *dev, struct scatterlist *sglist, int nents,
+	enum dma_data_direction dir)
+{
+	struct device *aiommu = to_ipu_bus_device(dev)->iommu;
+	struct ipu_mmu *mmu = dev_get_drvdata(aiommu);
+	struct scatterlist *sg;
+	int i;
+
+	for_each_sg(sglist, sg, nents, i) {
+		clflush_cache_range(
+			phys_to_virt(iommu_iova_to_phys(
+					     mmu->dmap->domain,
+					     sg_dma_address(sg))),
+			sg->length);
+	}
+}
+
+static void *intel_ipu4_dma_alloc(struct device *dev, size_t size,
+			       dma_addr_t *dma_handle, gfp_t gfp,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0)
+			       struct dma_attrs *attrs
+#else
+			       unsigned long attrs
+#endif
+				 )
+{
+	struct device *aiommu = to_ipu_bus_device(dev)->iommu;
+	struct ipu_mmu *mmu = dev_get_drvdata(aiommu);
+	struct page **pages;
+	struct iova *iova;
+	struct vm_struct *area;
+	int i;
+	int rval;
+
+	size = PAGE_ALIGN(size);
+
+	iova = alloc_iova(&mmu->dmap->iovad, size >> PAGE_SHIFT,
+			  dma_get_mask(dev) >> PAGE_SHIFT, 0);
+	if (!iova)
+		return NULL;
+
+	pages = __intel_ipu4_dma_alloc(dev, size, gfp, attrs);
+	if (!pages)
+		goto out_free_iova;
+
+	for (i = 0; iova->pfn_lo + i <= iova->pfn_hi; i++) {
+		rval = iommu_map(mmu->dmap->domain,
+				 (iova->pfn_lo + i) << PAGE_SHIFT,
+				 page_to_phys(pages[i]), PAGE_SIZE, 0);
+		if (rval)
+			goto out_unmap;
+	}
+
+	area = __get_vm_area(size, 0, VMALLOC_START, VMALLOC_END);
+	if (!area)
+		goto out_unmap;
+
+	area->pages = pages;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 17, 0)
+	if (map_vm_area(area, PAGE_KERNEL, &pages))
+#else
+	if (map_vm_area(area, PAGE_KERNEL, pages))
+#endif
+		goto out_vunmap;
+
+	*dma_handle = iova->pfn_lo << PAGE_SHIFT;
+
+	mmu->tlb_invalidate(mmu);
+
+	return area->addr;
+
+out_vunmap:
+	vunmap(area->addr);
+
+out_unmap:
+	__intel_ipu4_dma_free(dev, pages, size, attrs);
+	for (i--; i >= 0; i--) {
+		iommu_unmap(mmu->dmap->domain, (iova->pfn_lo + i) << PAGE_SHIFT,
+			    PAGE_SIZE);
+	}
+out_free_iova:
+	__free_iova(&mmu->dmap->iovad, iova);
+
+	return NULL;
+}
+
+static void intel_ipu4_dma_free(struct device *dev, size_t size, void *vaddr,
+				dma_addr_t dma_handle,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0)
+				struct dma_attrs *attrs
+#else
+				unsigned long attrs
+#endif
+			       )
+{
+	struct device *aiommu = to_ipu_bus_device(dev)->iommu;
+	struct ipu_mmu *mmu = dev_get_drvdata(aiommu);
+	struct vm_struct *area = find_vm_area(vaddr);
+	struct iova *iova = find_iova(&mmu->dmap->iovad,
+				dma_handle >> PAGE_SHIFT);
+
+	if (WARN_ON(!area))
+		return;
+
+	if (WARN_ON(!area->pages))
+		return;
+
+	BUG_ON(!iova);
+
+	size = PAGE_ALIGN(size);
+
+	vunmap(vaddr);
+
+	iommu_unmap(mmu->dmap->domain, iova->pfn_lo << PAGE_SHIFT,
+		(iova->pfn_hi - iova->pfn_lo + 1) << PAGE_SHIFT);
+
+	__intel_ipu4_dma_free(dev, area->pages, size, attrs);
+
+	__free_iova(&mmu->dmap->iovad, iova);
+
+	mmu->tlb_invalidate(mmu);
+}
+
+static int intel_ipu4_dma_mmap(struct device *dev, struct vm_area_struct *vma,
+			void *addr, dma_addr_t iova, size_t size,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0)
+			struct dma_attrs *attrs
+#else
+			unsigned long attrs
+#endif
+			       )
+{
+	struct vm_struct *area = find_vm_area(addr);
+	size_t count = PAGE_ALIGN(size) >> PAGE_SHIFT;
+	size_t i;
+
+	if (!area)
+		return -EFAULT;
+
+	if (vma->vm_start & ~PAGE_MASK)
+		return -EINVAL;
+
+	if (size > area->size)
+		return -EFAULT;
+
+	for (i = 0; i < count; i++)
+		vm_insert_page(vma, vma->vm_start + (i << PAGE_SHIFT),
+			area->pages[i]);
+
+	return 0;
+}
+
+static void intel_ipu4_dma_unmap_sg(struct device *dev,
+				struct scatterlist *sglist,
+				int nents, enum dma_data_direction dir,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0)
+				struct dma_attrs *attrs
+#else
+				unsigned long attrs
+#endif
+				   )
+{
+	struct device *aiommu = to_ipu_bus_device(dev)->iommu;
+	struct ipu_mmu *mmu = dev_get_drvdata(aiommu);
+	struct iova *iova = find_iova(&mmu->dmap->iovad,
+				sg_dma_address(sglist) >> PAGE_SHIFT);
+
+	if (!nents)
+		return;
+
+	BUG_ON(!iova);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0)
+	if (!dma_get_attr(DMA_ATTR_SKIP_CPU_SYNC, attrs))
+#else
+	if ((attrs & DMA_ATTR_SKIP_CPU_SYNC) == 0)
+#endif
+		intel_ipu4_dma_sync_sg_for_cpu(dev, sglist, nents,
+					       DMA_BIDIRECTIONAL);
+
+	iommu_unmap(mmu->dmap->domain, iova->pfn_lo << PAGE_SHIFT,
+		    (iova->pfn_hi - iova->pfn_lo + 1) << PAGE_SHIFT);
+
+	mmu->tlb_invalidate(mmu);
+
+	__free_iova(&mmu->dmap->iovad, iova);
+}
+
+static int intel_ipu4_dma_map_sg(struct device *dev, struct scatterlist *sglist,
+			      int nents, enum dma_data_direction dir,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0)
+			      struct dma_attrs *attrs
+#else
+			      unsigned long attrs
+#endif
+				)
+{
+	struct device *aiommu = to_ipu_bus_device(dev)->iommu;
+	struct ipu_mmu *mmu = dev_get_drvdata(aiommu);
+	struct scatterlist *sg;
+	struct iova *iova;
+	size_t size = 0;
+	uint32_t iova_addr;
+	int i;
+
+	for_each_sg(sglist, sg, nents, i)
+		size += PAGE_ALIGN(sg->length) >> PAGE_SHIFT;
+
+	dev_dbg(dev, "dmamap: mapping sg %d entries, %zu pages\n", nents, size);
+
+	iova = alloc_iova(&mmu->dmap->iovad, size,
+			  dma_get_mask(dev) >> PAGE_SHIFT, 0);
+	if (!iova)
+		return 0;
+
+	dev_dbg(dev, "dmamap: iova low pfn %lu, high pfn %lu\n", iova->pfn_lo,
+		iova->pfn_hi);
+
+	iova_addr = iova->pfn_lo;
+
+	for_each_sg(sglist, sg, nents, i) {
+		int rval;
+
+		dev_dbg(dev,
+			"dmamap details: mapping entry %d: iova 0x%8.8x, \
+			physical 0x%16.16llx\n",
+			i, iova_addr << PAGE_SHIFT, page_to_phys(sg_page(sg)));
+		rval = iommu_map(mmu->dmap->domain, iova_addr << PAGE_SHIFT,
+				 page_to_phys(sg_page(sg)),
+				 PAGE_ALIGN(sg->length), 0);
+		if (rval)
+			goto out_fail;
+		sg_dma_address(sg) = iova_addr << PAGE_SHIFT;
+#ifdef CONFIG_NEED_SG_DMA_LENGTH
+		sg_dma_len(sg) = sg->length;
+#endif /* CONFIG_NEED_SG_DMA_LENGTH */
+
+		iova_addr += PAGE_ALIGN(sg->length) >> PAGE_SHIFT;
+	}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0)
+	if (!dma_get_attr(DMA_ATTR_SKIP_CPU_SYNC, attrs))
+#else
+	if ((attrs & DMA_ATTR_SKIP_CPU_SYNC) == 0)
+#endif
+		intel_ipu4_dma_sync_sg_for_cpu(dev, sglist, nents,
+					       DMA_BIDIRECTIONAL);
+
+	mmu->tlb_invalidate(mmu);
+
+	return nents;
+
+out_fail:
+	intel_ipu4_dma_unmap_sg(dev, sglist, i, dir, attrs);
+
+	return 0;
+}
+
+/*
+* Create scatter-list for the already allocated DMA buffer
+*/
+static int intel_ipu4_dma_get_sgtable(struct device *dev, struct sg_table *sgt,
+				void *cpu_addr, dma_addr_t handle, size_t size,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0)
+				struct dma_attrs *attrs
+#else
+				unsigned long attrs
+#endif
+				     )
+{
+	struct vm_struct *area = find_vm_area(cpu_addr);
+	int n_pages;
+	int ret = 0;
+
+	if (WARN_ON(!area->pages))
+		return -ENOMEM;
+
+	n_pages = PAGE_ALIGN(size) >> PAGE_SHIFT;
+
+	ret = sg_alloc_table_from_pages(sgt, area->pages, n_pages, 0, size,
+						GFP_KERNEL);
+	if (ret)
+		dev_dbg(dev, "IPU get sgt table fail\n");
+
+	return ret;
+}
+
+const struct dma_map_ops ipu_dma_ops = {
+	.alloc = intel_ipu4_dma_alloc,
+	.free = intel_ipu4_dma_free,
+	.mmap = intel_ipu4_dma_mmap,
+	.map_sg = intel_ipu4_dma_map_sg,
+	.unmap_sg = intel_ipu4_dma_unmap_sg,
+	.sync_single_for_cpu = intel_ipu4_dma_sync_single_for_cpu,
+	.sync_single_for_device = intel_ipu4_dma_sync_single_for_cpu,
+	.sync_sg_for_cpu = intel_ipu4_dma_sync_sg_for_cpu,
+	.sync_sg_for_device = intel_ipu4_dma_sync_sg_for_cpu,
+	.get_sgtable = intel_ipu4_dma_get_sgtable,
+};
+EXPORT_SYMBOL_GPL(ipu_dma_ops);
+
diff --git a/drivers/media/pci/intel/ici/ici-isys-csi2-be.c b/drivers/media/pci/intel/ici/ici-isys-csi2-be.c
new file mode 100644
index 0000000..6841263
--- /dev/null
+++ b/drivers/media/pci/intel/ici/ici-isys-csi2-be.c
@@ -0,0 +1,280 @@
+// SPDX-License-Identifier: (BSD-3-Clause OR GPL-2.0)
+/*
+ * Copyright (C) 2018 Intel Corporation
+ */
+
+#include "./ici/ici-isys.h"
+#ifdef ICI_ENABLED
+
+#ifndef IPU4_DEBUG
+#define IPU4_DEBUG 1
+#endif
+
+#include "./ici/ici-isys-csi2-be.h"
+#include "isysapi/interface/ia_css_isysapi_fw_types.h"
+
+#define ici_asd_to_csi2_be(__asd) \
+	container_of(__asd, struct ici_isys_csi2_be, asd)
+
+static const uint32_t ici_csi2_be_supported_codes_pad[] = {
+	ICI_FORMAT_SBGGR12,
+	ICI_FORMAT_SGBRG12,
+	ICI_FORMAT_SGRBG12,
+	ICI_FORMAT_SRGGB12,
+	ICI_FORMAT_SBGGR10,
+	ICI_FORMAT_SGBRG10,
+	ICI_FORMAT_SGRBG10,
+	ICI_FORMAT_SRGGB10,
+	ICI_FORMAT_SBGGR8,
+	ICI_FORMAT_SGBRG8,
+	ICI_FORMAT_SGRBG8,
+	ICI_FORMAT_SRGGB8,
+	0,
+};
+
+static const uint32_t ici_csi2_be_soc_supported_codes_pad[] = {
+	ICI_FORMAT_RGB888,
+	ICI_FORMAT_RGB565,
+	ICI_FORMAT_UYVY,
+	ICI_FORMAT_YUYV,
+	ICI_FORMAT_SBGGR12,
+	ICI_FORMAT_SGBRG12,
+	ICI_FORMAT_SGRBG12,
+	ICI_FORMAT_SRGGB12,
+	ICI_FORMAT_SBGGR10,
+	ICI_FORMAT_SGBRG10,
+	ICI_FORMAT_SGRBG10,
+	ICI_FORMAT_SRGGB10,
+	ICI_FORMAT_SBGGR8,
+	ICI_FORMAT_SGBRG8,
+	ICI_FORMAT_SGRBG8,
+	ICI_FORMAT_SRGGB8,
+	0,
+};
+
+static const uint32_t *ici_csi2_be_supported_codes[] = {
+	ici_csi2_be_supported_codes_pad,
+	ici_csi2_be_supported_codes_pad,
+};
+
+static const uint32_t *ici_csi2_be_soc_supported_codes[] = {
+	ici_csi2_be_soc_supported_codes_pad,
+	ici_csi2_be_soc_supported_codes_pad,
+};
+
+static int get_supported_code_index(uint32_t code)
+{
+	int i;
+
+	for (i = 0; ici_csi2_be_supported_codes_pad[i]; i++) {
+		if (ici_csi2_be_supported_codes_pad[i] == code)
+			return i;
+	}
+	return -EINVAL;
+}
+
+void ici_csi2_be_set_ffmt(struct ici_isys_subdev *asd,
+			unsigned pad,
+			struct ici_framefmt *ffmt)
+{
+	struct ici_framefmt *cur_ffmt =
+		__ici_isys_subdev_get_ffmt(asd, pad);
+	int idx=0;
+	if (!cur_ffmt)
+	    return;
+
+	ffmt->colorspace = 0;
+	memset(ffmt->reserved, 0, sizeof(ffmt->reserved));
+	switch (pad) {
+	case CSI2_BE_ICI_PAD_SINK:
+		DEBUGK("%s: sink pad %u\n", __func__, pad);
+		if (ffmt->field != ICI_FIELD_ALTERNATE)
+			ffmt->field = ICI_FIELD_NONE;
+		*cur_ffmt = *ffmt;
+
+		ici_isys_subdev_fmt_propagate(asd, pad, NULL,
+				ICI_ISYS_SUBDEV_PROP_TGT_SINK_FMT,
+							  ffmt);
+		break;
+	case CSI2_BE_ICI_PAD_SOURCE: {
+		struct ici_framefmt *sink_ffmt =
+			__ici_isys_subdev_get_ffmt(asd,
+					CSI2_BE_ICI_PAD_SINK);
+
+		struct ici_rect *r =
+			&asd->crop[CSI2_BE_ICI_PAD_SOURCE];
+
+		u32 code = 0;
+		if (sink_ffmt)
+		    code = sink_ffmt->pixelformat;
+
+		idx = get_supported_code_index(code);
+
+		DEBUGK("%s: source pad %u\n", __func__, pad);
+
+		if (asd->valid_tgts[CSI2_BE_ICI_PAD_SOURCE].crop
+			&& idx >= 0) {
+			int crop_info = 0;
+
+			DEBUGK("%s: setting CROP, pad %u\n", __func__,
+				pad);
+
+			if (r->top & 1)
+				crop_info |= CSI2_BE_ICI_CROP_VER;
+			if (r->left & 1)
+				crop_info |= CSI2_BE_ICI_CROP_HOR;
+			code = ici_csi2_be_supported_codes_pad[((
+					idx &
+					CSI2_BE_ICI_CROP_MASK)
+					^
+					crop_info)
+					+
+					(idx &
+					~CSI2_BE_ICI_CROP_MASK)];
+		}
+
+		DEBUGK("%s: setting to w:%u,h:%u,pf:%u,field:%u\n",
+			__func__, r->width,
+			r->height, code, sink_ffmt->field);
+		cur_ffmt->width = r->width;
+		cur_ffmt->height = r->height;
+		cur_ffmt->pixelformat = code;
+		cur_ffmt->field = sink_ffmt->field;
+		*ffmt = *cur_ffmt;
+		break;
+		}
+	default:
+		BUG_ON(1);
+	}
+}
+
+static int ici_csi2_be_set_stream(
+	struct ici_isys_node *node,
+	void* ip,
+	int state)
+{
+	return 0;
+}
+
+static int ici_csi2_be_pipeline_validate(
+	struct node_pipeline *inp,
+	struct ici_isys_node *node)
+{
+	struct ici_isys_subdev* asd = node->sd;
+	struct ici_isys_csi2_be *csi2_be =
+		ici_asd_to_csi2_be(asd);
+	struct ici_isys_pipeline *ip =
+		ici_nodepipe_to_pipeline(inp);
+
+        ip->csi2_be = csi2_be;
+        return 0;
+}
+
+int ici_isys_csi2_be_init(struct ici_isys_csi2_be
+					*csi2_be,
+					struct ici_isys *isys,
+					unsigned int type)
+{
+	struct ici_pad_framefmt pff = {
+		.pad.pad_idx = CSI2_BE_ICI_PAD_SINK,
+		.ffmt = {
+			.width = 4096,
+			.height = 3072,
+		},
+	};
+	int rval;
+	char name[ICI_MAX_NODE_NAME];
+
+	dev_info(&isys->adev->dev, "ici_isys_csi2_be_init\n");
+
+	csi2_be->asd.isys = isys;
+	if (type == ICI_BE_RAW) {
+		csi2_be->as.buf_list.css_pin_type =
+			IA_CSS_ISYS_PIN_TYPE_RAW_NS;
+		snprintf(name, sizeof(name),
+			IPU_ISYS_ENTITY_PREFIX " CSI2 BE");
+	} else if (type >= ICI_BE_SOC) {
+		csi2_be->as.buf_list.css_pin_type =
+			IA_CSS_ISYS_PIN_TYPE_RAW_SOC;
+		snprintf(name, sizeof(name),
+			IPU_ISYS_ENTITY_PREFIX " CSI2 BE SOC %u", type-1);
+	} else {
+		return -EINVAL;
+	}
+
+	rval = ici_isys_subdev_init(&csi2_be->asd,
+						name,
+						NR_OF_CSI2_BE_ICI_PADS,
+						0);
+	if (rval) {
+		dev_err(&isys->adev->dev, "can't init subdevice\n");
+		goto fail_subdev;
+	}
+
+	csi2_be->asd.pads[CSI2_BE_ICI_PAD_SINK].flags = ICI_PAD_FLAGS_SINK
+		| ICI_PAD_FLAGS_MUST_CONNECT;
+	csi2_be->asd.pads[CSI2_BE_ICI_PAD_SOURCE].flags =
+		ICI_PAD_FLAGS_SOURCE;
+
+	if (type == ICI_BE_RAW)
+		csi2_be->asd.valid_tgts[CSI2_BE_ICI_PAD_SOURCE].crop = true;
+	else
+		csi2_be->asd.valid_tgts[CSI2_BE_ICI_PAD_SOURCE].crop = false;
+
+	csi2_be->asd.set_ffmt_internal = ici_csi2_be_set_ffmt;
+
+	if (type == ICI_BE_RAW) {
+		csi2_be->asd.supported_codes = ici_csi2_be_supported_codes;
+		csi2_be->asd.be_mode = ICI_BE_RAW;
+		csi2_be->asd.isl_mode = ICI_ISL_CSI2_BE;
+	} else {
+		csi2_be->asd.supported_codes = ici_csi2_be_soc_supported_codes;
+		csi2_be->asd.be_mode = ICI_BE_SOC;
+		csi2_be->asd.isl_mode = ICI_ISL_OFF;
+	}
+
+	csi2_be->asd.node.node_set_pad_ffmt(&csi2_be->asd.node, &pff);
+	/* ipu4_isys_csi2_be2_set_sel(&csi2_be->asd.sd, NULL, &sel); */
+	/* csi2_be->asd.sd.internal_ops = &csi2_be_sd_internal_ops; */
+	csi2_be->asd.node.node_set_streaming =
+		ici_csi2_be_set_stream;
+	csi2_be->asd.node.node_pipeline_validate =
+		ici_csi2_be_pipeline_validate;
+
+
+	csi2_be->as.isys = isys;
+	if (type == ICI_BE_RAW)
+		csi2_be->as.pfmts = ici_isys_pfmts;
+	else
+		csi2_be->as.pfmts = ici_isys_pfmts_be_soc;
+
+	csi2_be->as.try_fmt_vid_mplane =
+		ici_isys_video_try_fmt_vid_mplane_default;
+	csi2_be->as.prepare_firmware_stream_cfg =
+		ici_isys_prepare_firmware_stream_cfg_default;
+
+	rval = ici_isys_stream_init(&csi2_be->as, &csi2_be->asd,
+				&csi2_be->asd.node, CSI2_BE_ICI_PAD_SOURCE,
+				ICI_PAD_FLAGS_SINK);
+	if (rval) {
+		dev_err(&isys->adev->dev, "can't init stream node\n");
+		goto fail_stream;
+	}
+	return 0;
+
+fail_stream:
+	ici_isys_subdev_cleanup(&csi2_be->asd);
+fail_subdev:
+	return rval;
+}
+EXPORT_SYMBOL(ici_isys_csi2_be_init);
+
+void ici_isys_csi2_be_cleanup(struct ici_isys_csi2_be
+					  *csi2_be)
+{
+	ici_isys_subdev_cleanup(&csi2_be->asd);
+	ici_isys_stream_cleanup(&csi2_be->as);
+}
+EXPORT_SYMBOL(ici_isys_csi2_be_cleanup);
+
+#endif /* ICI_ENABLED */
diff --git a/drivers/media/pci/intel/ici/ici-isys-csi2-be.h b/drivers/media/pci/intel/ici/ici-isys-csi2-be.h
new file mode 100644
index 0000000..428619d2
--- /dev/null
+++ b/drivers/media/pci/intel/ici/ici-isys-csi2-be.h
@@ -0,0 +1,36 @@
+/* SPDX-License-Identifier: (BSD-3-Clause OR GPL-2.0) */
+/*
+ * Copyright (C) 2018 Intel Corporation
+ */
+
+#ifndef ICI_ISYS_CSI2_BE_H
+#define ICI_ISYS_CSI2_BE_H
+
+#include "ici-isys-subdev.h"
+#include "ici-isys-stream.h"
+
+#define CSI2_BE_ICI_PAD_SINK			0
+#define CSI2_BE_ICI_PAD_SOURCE			1
+#define NR_OF_CSI2_BE_ICI_PADS			2
+
+#define CSI2_BE_ICI_CROP_HOR        (1 << 0)
+#define CSI2_BE_ICI_CROP_VER        (1 << 1)
+#define CSI2_BE_ICI_CROP_MASK       (CSI2_BE_ICI_CROP_VER | CSI2_BE_ICI_CROP_HOR)
+
+struct ici_isys_csi2_be_pdata;
+/*
+ * struct ici_isys_csi2_be
+ */
+struct ici_isys_csi2_be {
+	struct ici_isys_csi2_be_pdata *pdata;
+	struct ici_isys_subdev asd;
+	struct ici_isys_stream as;
+};
+
+int ici_isys_csi2_be_init(struct ici_isys_csi2_be
+					*csi2_be,
+			  struct ici_isys *isys, unsigned int type);
+void ici_isys_csi2_be_cleanup(struct ici_isys_csi2_be
+					*csi2_be);
+
+#endif /* ICI_ISYS_CSI2_BE_H */
diff --git a/drivers/media/pci/intel/ici/ici-isys-csi2.c b/drivers/media/pci/intel/ici/ici-isys-csi2.c
new file mode 100644
index 0000000..65416dd
--- /dev/null
+++ b/drivers/media/pci/intel/ici/ici-isys-csi2.c
@@ -0,0 +1,532 @@
+// SPDX-License-Identifier: (BSD-3-Clause OR GPL-2.0)
+/*
+ * Copyright (C) 2018 Intel Corporation
+ */
+
+#include "./ici/ici-isys.h"
+#ifdef ICI_ENABLED
+#include <media/ici.h>
+#include "./ici/ici-isys-subdev.h"
+#include "./ici/ici-isys-stream.h"
+#include "./ici/ici-isys-csi2.h"
+#include "isysapi/interface/ia_css_isysapi_fw_types.h"
+#include "ipu-platform-isys-csi2-reg.h"
+//#include "intel-ipu-isys-csi2-common.h"
+
+#define CSI2_ACCINV 8
+
+#define ici_asd_to_csi2(__asd, index) \
+	container_of(__asd, struct ici_isys_csi2, asd[index])
+
+static const uint32_t ici_csi2_supported_codes_pad_sink[] = {
+	ICI_FORMAT_RGB888,
+	ICI_FORMAT_RGB565,
+	ICI_FORMAT_UYVY,
+	ICI_FORMAT_YUYV,
+	ICI_FORMAT_SBGGR12,
+	ICI_FORMAT_SGBRG12,
+	ICI_FORMAT_SGRBG12,
+	ICI_FORMAT_SRGGB12,
+	ICI_FORMAT_SBGGR10,
+	ICI_FORMAT_SGBRG10,
+	ICI_FORMAT_SGRBG10,
+	ICI_FORMAT_SRGGB10,
+	ICI_FORMAT_SBGGR8,
+	ICI_FORMAT_SGBRG8,
+	ICI_FORMAT_SGRBG8,
+	ICI_FORMAT_SRGGB8,
+	ICI_FORMAT_SBGGR10_DPCM8,
+	ICI_FORMAT_SGBRG10_DPCM8,
+	ICI_FORMAT_SGRBG10_DPCM8,
+	ICI_FORMAT_SRGGB10_DPCM8,
+	0,
+};
+
+static const uint32_t ici_csi2_supported_codes_pad_source[] = {
+	ICI_FORMAT_RGB888,
+	ICI_FORMAT_RGB565,
+	ICI_FORMAT_UYVY,
+	ICI_FORMAT_YUYV,
+	ICI_FORMAT_SBGGR12,
+	ICI_FORMAT_SGBRG12,
+	ICI_FORMAT_SGRBG12,
+	ICI_FORMAT_SRGGB12,
+	ICI_FORMAT_SBGGR10,
+	ICI_FORMAT_SGBRG10,
+	ICI_FORMAT_SGRBG10,
+	ICI_FORMAT_SRGGB10,
+	ICI_FORMAT_SBGGR8,
+	ICI_FORMAT_SGBRG8,
+	ICI_FORMAT_SGRBG8,
+	ICI_FORMAT_SRGGB8,
+	0,
+};
+
+static const uint32_t *ici_csi2_supported_codes[] = {
+	ici_csi2_supported_codes_pad_sink,
+	ici_csi2_supported_codes_pad_source,
+};
+
+void ici_csi2_set_ffmt(struct ici_isys_subdev *asd,
+			unsigned pad,
+			struct ici_framefmt *ffmt)
+{
+	struct ici_framefmt *cur_ffmt =
+		__ici_isys_subdev_get_ffmt(asd, pad);
+
+	if (ffmt->field != ICI_FIELD_ALTERNATE)
+		ffmt->field = ICI_FIELD_NONE;
+	ffmt->colorspace = 0;
+	memset(ffmt->reserved, 0, sizeof(ffmt->reserved));
+
+	switch (pad) {
+	case CSI2_ICI_PAD_SINK:
+		if (cur_ffmt)
+			*cur_ffmt = *ffmt;
+		ici_isys_subdev_fmt_propagate(asd, pad, NULL,
+				ICI_ISYS_SUBDEV_PROP_TGT_SINK_FMT,
+				ffmt);
+		break;
+	case CSI2_ICI_PAD_SOURCE:{
+			struct ici_framefmt *sink_ffmt =
+				__ici_isys_subdev_get_ffmt(asd,
+						CSI2_ICI_PAD_SINK);
+			if (sink_ffmt) {
+			    *cur_ffmt = *sink_ffmt;
+			    cur_ffmt->pixelformat =
+			        ici_isys_subdev_code_to_uncompressed
+				(sink_ffmt->pixelformat);
+			    *ffmt = *cur_ffmt;
+			}
+			break;
+		}
+	default:
+		BUG_ON(1);
+	}
+}
+
+static void ici_isys_csi2_error(struct ici_isys_csi2
+						*csi2)
+{
+	/*
+	 * Strings corresponding to CSI-2 receiver errors are here.
+	 * Corresponding macros are defined in the header file.
+	 */
+	static const struct ici_isys_csi2_error {
+		const char *error_string;
+		bool is_info_only;
+	} errors[] = {
+		{
+		"Single packet header error corrected", true}, {
+		"Multiple packet header errors detected", true}, {
+		"Payload checksum (CRC) error", true}, {
+		"FIFO overflow", false}, {
+		"Reserved short packet data type detected", true}, {
+		"Reserved long packet data type detected", true}, {
+		"Incomplete long packet detected", false}, {
+		"Frame sync error", false}, {
+		"Line sync error", false}, {
+		"DPHY recoverable synchronization error", true}, {
+		"DPHY non-recoverable synchronization error", false}, {
+		"Escape mode error", true}, {
+		"Escape mode trigger event", true}, {
+		"Escape mode ultra-low power state for data lane(s)", true},
+		{
+		"Escape mode ultra-low power state exit for clock lane",
+				true}, {
+		"Inter-frame short packet discarded", true}, {
+	"Inter-frame long packet discarded", true},};
+	u32 status = csi2->receiver_errors;
+	unsigned int i;
+
+	csi2->receiver_errors = 0;
+
+	for (i = 0; i < ARRAY_SIZE(errors); i++) {
+		if (status & BIT(i)) {
+			if (errors[i].is_info_only)
+				dev_dbg(&csi2->isys->adev->dev,
+					"csi2-%i info: %s\n",
+					csi2->index, errors[i].error_string);
+			else
+				dev_err_ratelimited(&csi2->isys->adev->dev,
+							"csi2-%i error: %s\n",
+							csi2->index,
+							errors[i].error_string);
+		}
+	}
+}
+
+#define DIV_SHIFT   8
+
+static uint32_t calc_timing(int32_t a, int32_t b, int64_t link_freq,
+			    int32_t accinv)
+{
+	return accinv * a + (accinv * b * (500000000 >> DIV_SHIFT)
+			     / (int32_t) (link_freq >> DIV_SHIFT));
+}
+
+int ici_isys_csi2_calc_timing(struct ici_isys_csi2
+						*csi2, struct
+						ici_isys_csi2_timing
+						*timing, uint32_t accinv)
+{
+	int64_t link_frequency = 0;
+
+	int idx, rval;
+
+	struct ici_ext_subdev *sd =
+		(struct ici_ext_subdev*)csi2->ext_sd;
+
+	struct ici_ext_sd_param param = {
+		.sd = sd,
+		.id = ICI_EXT_SD_PARAM_ID_LINK_FREQ,
+		.type = ICI_EXT_SD_PARAM_TYPE_INT32,
+	};
+
+	if (!sd || !sd->get_param) {
+		dev_err(&csi2->isys->adev->dev,
+			"External device not available\n");
+		return -ENODEV;
+	}
+	rval = sd->get_param(&param);
+	if (rval) {
+		dev_info(&csi2->isys->adev->dev, "can't get link frequency\n");
+		return rval;
+	}
+
+	idx = param.val;
+	param.type = ICI_EXT_SD_PARAM_TYPE_INT64;
+
+	rval = sd->get_menu_item(&param, idx);
+	if (rval) {
+		dev_info(&csi2->isys->adev->dev, "can't get menu item\n");
+		return rval;
+	}
+
+	link_frequency = param.val;
+	dev_dbg(&csi2->isys->adev->dev, "%s: link frequency %lld\n", __func__,
+		link_frequency);
+
+	if (!link_frequency)
+		return -EINVAL;
+
+	timing->ctermen = calc_timing(CSI2_CSI_RX_DLY_CNT_TERMEN_CLANE_A,
+					CSI2_CSI_RX_DLY_CNT_TERMEN_CLANE_B,
+					link_frequency, accinv);
+	timing->csettle =
+		calc_timing(CSI2_CSI_RX_DLY_CNT_SETTLE_CLANE_A,
+			CSI2_CSI_RX_DLY_CNT_SETTLE_CLANE_B, link_frequency,
+			accinv);
+	dev_dbg(&csi2->isys->adev->dev, "ctermen %u\n", timing->ctermen);
+	dev_dbg(&csi2->isys->adev->dev, "csettle %u\n", timing->csettle);
+
+	timing->dtermen = calc_timing(CSI2_CSI_RX_DLY_CNT_TERMEN_DLANE_A,
+					CSI2_CSI_RX_DLY_CNT_TERMEN_DLANE_B,
+					link_frequency, accinv);
+	timing->dsettle =
+	    calc_timing(CSI2_CSI_RX_DLY_CNT_SETTLE_DLANE_A,
+			CSI2_CSI_RX_DLY_CNT_SETTLE_DLANE_B, link_frequency,
+			accinv);
+	dev_dbg(&csi2->isys->adev->dev, "dtermen %u\n", timing->dtermen);
+	dev_dbg(&csi2->isys->adev->dev, "dsettle %u\n", timing->dsettle);
+
+	return 0;
+}
+
+static void ici_isys_register_errors(struct
+						 ici_isys_csi2
+						 *csi2)
+{
+	u32 status = readl(csi2->base + CSI2_REG_CSIRX_IRQ_STATUS);
+
+	dev_dbg(&csi2->isys->adev->dev,
+		"ici_isys_register_errors\n");
+	writel(status, csi2->base + CSI2_REG_CSIRX_IRQ_CLEAR);
+	csi2->receiver_errors |= status;
+}
+
+static void ici_isys_csi2_sof_event(struct ici_isys_csi2
+						*csi2, unsigned int vc)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&csi2->isys->lock, flags);
+	csi2->in_frame = true;
+	spin_unlock_irqrestore(&csi2->isys->lock, flags);
+}
+
+static void ici_isys_csi2_eof_event(struct ici_isys_csi2
+						*csi2, unsigned int vc)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&csi2->isys->lock, flags);
+	csi2->in_frame = false;
+	if (csi2->wait_for_sync)
+		complete(&csi2->eof_completion);
+	spin_unlock_irqrestore(&csi2->isys->lock, flags);
+}
+
+void ici_isys_csi2_isr(struct ici_isys_csi2 *csi2)
+{
+	u32 status = readl(csi2->base + CSI2_REG_CSI2PART_IRQ_STATUS);
+	unsigned int i;
+
+	writel(status, csi2->base + CSI2_REG_CSI2PART_IRQ_CLEAR);
+
+	if (status & CSI2_CSI2PART_IRQ_CSIRX)
+		ici_isys_register_errors(csi2);
+
+	for (i = 0; i < NR_OF_CSI2_ICI_VC; i++) {
+		if ((status & CSI2_IRQ_FS_VC(i)))
+			ici_isys_csi2_sof_event(csi2, i);
+
+		if ((status & CSI2_IRQ_FE_VC(i)))
+			ici_isys_csi2_eof_event(csi2, i);
+	}
+
+}
+EXPORT_SYMBOL(ici_isys_csi2_isr);
+
+void ici_isys_csi2_wait_last_eof(struct ici_isys_csi2
+						*csi2)
+{
+	unsigned long flags;
+	int tout;
+
+	spin_lock_irqsave(&csi2->isys->lock, flags);
+	if (!csi2->in_frame) {
+		spin_unlock_irqrestore(&csi2->isys->lock, flags);
+		return;
+	}
+
+	reinit_completion(&csi2->eof_completion);
+	csi2->wait_for_sync = true;
+	spin_unlock_irqrestore(&csi2->isys->lock, flags);
+	tout = wait_for_completion_timeout(&csi2->eof_completion,
+						ICI_EOF_TIMEOUT_JIFFIES);
+	if (!tout) {
+		dev_err(&csi2->isys->adev->dev,
+			"csi2-%d: timeout at sync to eof\n", csi2->index);
+	}
+	csi2->wait_for_sync = false;
+}
+
+static void csi2_capture_done(struct ici_isys_pipeline *ip,
+			      struct ia_css_isys_resp_info *info)
+{
+	ici_isys_frame_buf_capture_done(ip, info);
+	if (ip->csi2)
+		ici_isys_csi2_error(ip->csi2);
+}
+
+int ici_csi2_set_stream(
+	struct ici_isys_node *node,
+	void* ip,
+	int state)
+{
+	struct ici_isys_subdev* asd = node->sd;
+	struct ici_isys_csi2 *csi2 =
+	    ici_asd_to_csi2(asd, asd->index);
+	struct ici_isys_csi2_timing timing = { 0 };
+	unsigned int i, nlanes;
+	int rval;
+	u32 csi2csirx = 0, csi2part = 0;
+
+	dev_dbg(&csi2->isys->adev->dev, "csi2 s_stream %d\n", state);
+
+	if (!state) {
+		ici_isys_csi2_error(csi2);
+		writel(0, csi2->base + CSI2_REG_CSI_RX_CONFIG);
+		writel(0, csi2->base + CSI2_REG_CSI_RX_ENABLE);
+
+		/* Disable interrupts */
+		writel(0, csi2->base + CSI2_REG_CSI2S2M_IRQ_MASK);
+		writel(0, csi2->base + CSI2_REG_CSI2S2M_IRQ_ENABLE);
+		writel(0, csi2->base + CSI2_REG_CSI2PART_IRQ_MASK);
+		writel(0, csi2->base + CSI2_REG_CSI2PART_IRQ_ENABLE);
+		return 0;
+	}
+
+	ici_isys_stream_add_capture_done(ip, csi2_capture_done);
+
+	nlanes = csi2->nlanes;
+
+	rval = ici_isys_csi2_calc_timing(csi2,
+							&timing,
+							CSI2_ACCINV);
+	if (rval)
+		return rval;
+
+	writel(timing.ctermen,
+		csi2->base + CSI2_REG_CSI_RX_DLY_CNT_TERMEN_CLANE);
+	writel(timing.csettle,
+		csi2->base + CSI2_REG_CSI_RX_DLY_CNT_SETTLE_CLANE);
+
+	for (i = 0; i < nlanes; i++) {
+		writel(timing.dtermen,
+			csi2->base + CSI2_REG_CSI_RX_DLY_CNT_TERMEN_DLANE(i));
+		writel(timing.dsettle,
+			csi2->base + CSI2_REG_CSI_RX_DLY_CNT_SETTLE_DLANE(i));
+	}
+	writel(CSI2_CSI_RX_CONFIG_DISABLE_BYTE_CLK_GATING |
+	CSI2_CSI_RX_CONFIG_RELEASE_LP11,
+		csi2->base + CSI2_REG_CSI_RX_CONFIG);
+
+	writel(nlanes, csi2->base + CSI2_REG_CSI_RX_NOF_ENABLED_LANES);
+
+	writel(CSI2_CSI_RX_ENABLE_ENABLE, csi2->base + CSI2_REG_CSI_RX_ENABLE);
+
+	/* SOF enabled from CSI2PART register in B0 */
+	for (i = 0; i < NR_OF_CSI2_ICI_VC; i++)
+		csi2part |= CSI2_IRQ_FS_VC(i) | CSI2_IRQ_FE_VC(i);
+
+	/* Enable csi2 receiver error interrupts */
+	csi2csirx = BIT(CSI2_CSIRX_NUM_ERRORS) - 1;
+	writel(csi2csirx, csi2->base + CSI2_REG_CSIRX_IRQ_EDGE);
+	writel(0, csi2->base + CSI2_REG_CSIRX_IRQ_LEVEL_NOT_PULSE);
+	writel(csi2csirx, csi2->base + CSI2_REG_CSIRX_IRQ_CLEAR);
+	writel(csi2csirx, csi2->base + CSI2_REG_CSIRX_IRQ_MASK);
+	writel(csi2csirx, csi2->base + CSI2_REG_CSIRX_IRQ_ENABLE);
+
+	/* Enable csi2 error and SOF-related irqs */
+	writel(csi2part, csi2->base + CSI2_REG_CSI2PART_IRQ_EDGE);
+	writel(0, csi2->base + CSI2_REG_CSI2PART_IRQ_LEVEL_NOT_PULSE);
+	writel(csi2part, csi2->base + CSI2_REG_CSI2PART_IRQ_CLEAR);
+	writel(csi2part, csi2->base + CSI2_REG_CSI2PART_IRQ_MASK);
+	writel(csi2part, csi2->base + CSI2_REG_CSI2PART_IRQ_ENABLE);
+
+	return 0;
+}
+
+unsigned int ici_isys_csi2_get_current_field(
+	struct device* dev,
+	struct ici_isys_mipi_packet_header *ph)
+{
+	unsigned int field;
+
+	/* Check if the first SOF packet is received. */
+	if ((ph->dtype & ICI_ISYS_SHORT_PACKET_DTYPE_MASK) != 0)
+		dev_warn(dev,
+			"First short packet is not SOF.\n");
+	field = (ph->word_count % 2) ? ICI_FIELD_TOP :
+		ICI_FIELD_BOTTOM;
+	dev_dbg(dev,
+		"Interlaced field ready. frame_num = %d field = %d\n",
+		ph->word_count, field);
+
+	return field;
+}
+
+static int ici_csi2_pipeline_validate(
+	struct node_pipeline *inp,
+	struct ici_isys_node *node)
+{
+	struct ici_isys_subdev* asd = node->sd;
+	struct ici_isys_csi2 *csi2 =
+		ici_asd_to_csi2(asd, asd->index);
+	struct ici_isys_pipeline *ip =
+		ici_nodepipe_to_pipeline(inp);
+
+	if (ip->csi2) {
+		dev_err(&csi2->isys->adev->dev,
+			"Pipeline does not support > 1 CSI2 node\n");
+		return -EINVAL;
+	}
+	node->pipe = inp;
+	ip->csi2 = csi2;
+	ip->asd_source = asd;
+	ip->vc = asd - csi2->asd; // index of asd element in csi2->asd array
+	ip->asd_source_pad_id = CSI2_ICI_PAD_SINK;
+	return 0;
+}
+
+int ici_isys_csi2_init(struct ici_isys_csi2 *csi2,
+					struct ici_isys *isys,
+					void __iomem *base, unsigned int index)
+{
+	struct ici_pad_framefmt fmt = {
+		.pad.pad_idx = CSI2_ICI_PAD_SINK,
+		.ffmt = {
+				.width = 4096,
+				.height = 3072,
+			},
+	};
+
+	int rval;
+	char name[ICI_MAX_NODE_NAME];
+	unsigned int i;
+
+	csi2->isys = isys;
+	csi2->base = base;
+	csi2->index = index;
+
+	for(i=0; i<NR_OF_CSI2_VC; i++)
+	{
+		snprintf(name, sizeof(name),
+			 IPU_ISYS_ENTITY_PREFIX " CSI-2 %u VC %u", index, i);
+
+		csi2->asd[i].isys = isys;
+		rval = ici_isys_subdev_init(&csi2->asd[i],
+						name,
+						NR_OF_CSI2_ICI_PADS,
+						i);
+		if (rval)
+			goto fail;
+
+		csi2->asd[i].pads[CSI2_ICI_PAD_SINK].flags = ICI_PAD_FLAGS_SINK;
+        	csi2->asd[i].pads[CSI2_ICI_PAD_SOURCE].flags = ICI_PAD_FLAGS_SOURCE;
+
+		csi2->asd[i].source = IA_CSS_ISYS_STREAM_SRC_CSI2_PORT0 + index;
+		csi2->asd[i].supported_codes = ici_csi2_supported_codes;
+		csi2->asd[i].set_ffmt_internal = ici_csi2_set_ffmt;
+		csi2->asd[i].node.node_set_streaming =
+			ici_csi2_set_stream;
+		csi2->asd[i].node.node_pipeline_validate =
+			ici_csi2_pipeline_validate;
+
+		csi2->asd[i].node.node_set_pad_ffmt(&csi2->asd[i].node, &fmt);
+
+		snprintf(csi2->as[i].node.name, sizeof(csi2->as[i].node.name),
+			IPU_ISYS_ENTITY_PREFIX " CSI-2 %u VC %u capture", index, i);
+		csi2->as[i].isys = isys;
+		csi2->as[i].try_fmt_vid_mplane =
+			ici_isys_video_try_fmt_vid_mplane_default;
+		csi2->as[i].prepare_firmware_stream_cfg =
+			ici_isys_prepare_firmware_stream_cfg_default;
+		csi2->as[i].packed = true;
+		csi2->as[i].buf_list.css_pin_type = IA_CSS_ISYS_PIN_TYPE_MIPI;
+		csi2->as[i].pfmts = ici_isys_pfmts_packed;
+		csi2->as[i].line_header_length =
+			INTEL_IPU4_ISYS_CSI2_LONG_PACKET_HEADER_SIZE;
+		csi2->as[i].line_footer_length =
+			INTEL_IPU4_ISYS_CSI2_LONG_PACKET_FOOTER_SIZE;
+		init_completion(&csi2->eof_completion);
+
+		rval = ici_isys_stream_init(&csi2->as[i], &csi2->asd[i],
+				&csi2->asd[i].node, CSI2_ICI_PAD_SOURCE,
+				ICI_PAD_FLAGS_SINK);
+		if (rval) {
+			dev_err(&isys->adev->dev, "can't init stream node\n");
+			goto fail;
+		}
+	}
+	init_completion(&csi2->eof_completion);
+
+	return 0;
+
+fail:
+	ici_isys_csi2_cleanup(csi2);
+
+	return rval;
+}
+EXPORT_SYMBOL(ici_isys_csi2_init);
+
+void ici_isys_csi2_cleanup(struct ici_isys_csi2 *csi2)
+{
+    ici_isys_subdev_cleanup(&csi2->asd[0]);
+	ici_isys_stream_cleanup(&csi2->as[0]);
+}
+EXPORT_SYMBOL(ici_isys_csi2_cleanup);
+
+#endif /* ICI_ENABLED */
diff --git a/drivers/media/pci/intel/ici/ici-isys-csi2.h b/drivers/media/pci/intel/ici/ici-isys-csi2.h
new file mode 100644
index 0000000..504e413a
--- /dev/null
+++ b/drivers/media/pci/intel/ici/ici-isys-csi2.h
@@ -0,0 +1,156 @@
+/* SPDX-License-Identifier: (BSD-3-Clause OR GPL-2.0) */
+/*
+ * Copyright (C) 2018 Intel Corporation
+ */
+
+#ifndef ICI_ISYS_CSI2_H
+#define ICI_ISYS_CSI2_H
+
+#include "ici-isys-frame-buf.h"
+#include "ici-isys-subdev.h"
+#include "ici-isys-stream.h"
+
+struct ici_isys_csi2_pdata;
+
+#define CSI2_ICI_PAD_SINK				0
+#define CSI2_ICI_PAD_SOURCE			1
+#define NR_OF_CSI2_ICI_PADS			2
+#define NR_OF_CSI2_ICI_VC				4
+
+#define ICI_ISYS_SHORT_PACKET_BUFFER_NUM	32
+#define ICI_ISYS_SHORT_PACKET_WIDTH	32
+#define ICI_ISYS_SHORT_PACKET_FRAME_PACKETS	2
+#define ICI_ISYS_SHORT_PACKET_EXTRA_PACKETS	64
+#define ICI_ISYS_SHORT_PACKET_UNITSIZE	8
+#define ICI_ISYS_SHORT_PACKET_GENERAL_DT	0
+#define ICI_ISYS_SHORT_PACKET_PT		0
+#define ICI_ISYS_SHORT_PACKET_FT		0
+#define ICI_ISYS_SHORT_PACKET_DTYPE_MASK	0x3f
+#define ICI_ISYS_SHORT_PACKET_STRIDE \
+	(ICI_ISYS_SHORT_PACKET_WIDTH * \
+	ICI_ISYS_SHORT_PACKET_UNITSIZE)
+#define ICI_ISYS_SHORT_PACKET_NUM(num_lines) \
+	((num_lines) * 2 + ICI_ISYS_SHORT_PACKET_FRAME_PACKETS + \
+	ICI_ISYS_SHORT_PACKET_EXTRA_PACKETS)
+#define ICI_ISYS_SHORT_PACKET_PKT_LINES(num_lines) \
+	DIV_ROUND_UP(ICI_ISYS_SHORT_PACKET_NUM(num_lines) * \
+	ICI_ISYS_SHORT_PACKET_UNITSIZE, \
+	ICI_ISYS_SHORT_PACKET_STRIDE)
+#define ICI_ISYS_SHORT_PACKET_BUF_SIZE(num_lines) \
+	(ICI_ISYS_SHORT_PACKET_WIDTH * \
+	ICI_ISYS_SHORT_PACKET_PKT_LINES(num_lines) * \
+	ICI_ISYS_SHORT_PACKET_UNITSIZE)
+#define IPU_ISYS_SHORT_PACKET_TRACE_MSG_NUMBER	256
+#define IPU_ISYS_SHORT_PACKET_TRACE_MSG_SIZE	16
+#define IPU_ISYS_SHORT_PACKET_TRACE_BUFFER_SIZE \
+	(IPU_ISYS_SHORT_PACKET_TRACE_MSG_NUMBER * \
+	IPU_ISYS_SHORT_PACKET_TRACE_MSG_SIZE)
+#define IPU_ISYS_SHORT_PACKET_TRACE_MAX_TIMESHIFT 100
+#define IPU_ISYS_SHORT_PACKET_FROM_RECEIVER	0
+#define IPU_ISYS_SHORT_PACKET_FROM_TUNIT		1
+
+#define ICI_EOF_TIMEOUT 1000
+#define ICI_EOF_TIMEOUT_JIFFIES msecs_to_jiffies(ICI_EOF_TIMEOUT)
+
+#define IPU_ISYS_SHORT_PACKET_TRACE_MAX_TIMESHIFT 100
+#define IPU_ISYS_SHORT_PACKET_TRACE_EVENT_MASK	0x2082
+#define IPU_SKEW_CAL_LIMIT_HZ (1500000000ul / 2)
+
+#define CSI2_CSI_RX_DLY_CNT_TERMEN_CLANE_A		0
+#define CSI2_CSI_RX_DLY_CNT_TERMEN_CLANE_B		0
+#define CSI2_CSI_RX_DLY_CNT_SETTLE_CLANE_A		95
+#define CSI2_CSI_RX_DLY_CNT_SETTLE_CLANE_B		-8
+
+#define CSI2_CSI_RX_DLY_CNT_TERMEN_DLANE_A		0
+#define CSI2_CSI_RX_DLY_CNT_TERMEN_DLANE_B		0
+#define CSI2_CSI_RX_DLY_CNT_SETTLE_DLANE_A		85
+#define CSI2_CSI_RX_DLY_CNT_SETTLE_DLANE_B		-2
+
+/*
+ * struct ici_isys_csi2
+ *
+ */
+struct ici_isys_csi2 {
+	struct ici_isys_csi2_pdata *pdata;
+	struct ici_isys *isys;
+	struct ici_isys_subdev asd[NR_OF_CSI2_ICI_VC];
+	struct ici_isys_stream as[NR_OF_CSI2_ICI_VC];
+	void *ext_sd;
+
+	void __iomem *base;
+	u32 receiver_errors;
+	unsigned int nlanes;
+	unsigned int index;
+	atomic_t sof_sequence;
+
+	bool wait_for_sync;
+	bool in_frame;
+	struct completion eof_completion;
+};
+
+struct ici_isys_csi2_timing {
+	uint32_t ctermen;
+	uint32_t csettle;
+	uint32_t dtermen;
+	uint32_t dsettle;
+};
+
+/*
+ * This structure defines the MIPI packet header output
+ * from IPU4 MIPI receiver. Due to hardware conversion,
+ * this structure is not the same as defined in CSI-2 spec.
+ */
+__packed struct ici_isys_mipi_packet_header {
+	uint32_t word_count : 16,
+		 dtype : 13,
+		 sync : 2,
+		 stype : 1;
+	uint32_t sid : 4,
+		 port_id : 4,
+		 reserved : 23,
+		 odd_even : 1;
+};
+
+/*
+ * This structure defines the trace message content
+ * for CSI2 receiver monitor messages.
+ */
+__packed struct ici_isys_csi2_monitor_message {
+	uint64_t fe : 1,
+		 fs : 1,
+		 pe : 1,
+		 ps : 1,
+		 le : 1,
+		 ls : 1,
+		 reserved1 : 2,
+		 sequence : 2,
+		 reserved2 : 2,
+		 flash_shutter : 4,
+		 error_cause : 12,
+		 fifo_overrun : 1,
+		 crc_error : 2,
+		 reserved3 : 1,
+		 timestamp_l : 16,
+		 port : 4,
+		 vc : 2,
+		 reserved4 : 2,
+		 frame_sync : 4,
+		 reserved5 : 4;
+	uint64_t reserved6 : 3,
+		 cmd : 2,
+		 reserved7 : 1,
+		 monitor_id : 7,
+		 reserved8 : 1,
+		 timestamp_h : 50;
+};
+
+int ici_isys_csi2_init(struct ici_isys_csi2 *csi2,
+			struct ici_isys *isys,
+			void __iomem *base, unsigned int index);
+void ici_isys_csi2_cleanup(struct ici_isys_csi2 *csi2);
+void ici_isys_csi2_wait_last_eof(struct ici_isys_csi2 *csi2);
+void ici_isys_csi2_isr(struct ici_isys_csi2 *csi2);
+unsigned int ici_isys_csi2_get_current_field(
+	struct device* dev, struct ici_isys_mipi_packet_header *ph);
+	
+#endif /* ICI_ISYS_CSI2_H */
diff --git a/drivers/media/pci/intel/ici/ici-isys-frame-buf.c b/drivers/media/pci/intel/ici/ici-isys-frame-buf.c
new file mode 100644
index 0000000..8e62c27
--- /dev/null
+++ b/drivers/media/pci/intel/ici/ici-isys-frame-buf.c
@@ -0,0 +1,950 @@
+// SPDX-License-Identifier: (BSD-3-Clause OR GPL-2.0)
+/*
+ * Copyright (C) 2018 Intel Corporation
+ */
+
+#include <linux/kernel.h>
+#include <linux/vmalloc.h>
+#include <linux/dma-buf.h>
+
+#include "./ici/ici-isys.h"
+#ifdef ICI_ENABLED
+
+#include "isysapi/interface/ia_css_isysapi_types.h"
+#include "isysapi/interface/ia_css_isysapi.h"
+#include "./ici/ici-isys-frame-buf.h"
+
+#define get_frame_entry_to_buf_wrap(get_entry) \
+	container_of(get_entry, struct ici_frame_buf_wrapper,\
+		get_frame_entry)
+
+#define put_frame_entry_to_buf_wrap(put_entry) \
+	container_of(put_entry, struct ici_frame_buf_wrapper,\
+		put_frame_entry)
+
+static struct ici_frame_buf_wrapper
+*ici_frame_buf_lookup(struct ici_isys_frame_buf_list
+					*buf_list,
+					struct ici_frame_info
+					*user_frame_info)
+{
+	struct ici_frame_buf_wrapper *buf;
+	int i;
+	int mem_type = user_frame_info->mem_type;
+
+	list_for_each_entry(buf, &buf_list->getbuf_list, node) {
+		for (i = 0; i < user_frame_info->num_planes; i++) {
+			struct ici_frame_plane *new_plane =
+				&user_frame_info->frame_planes[i];
+			struct ici_frame_plane *cur_plane =
+				&buf->frame_info.frame_planes[i];
+			if (buf->state != ICI_BUF_PREPARED &&
+				buf->state != ICI_BUF_DONE){
+				continue;
+			}
+
+			switch (mem_type) {
+			case ICI_MEM_USERPTR:
+				if (new_plane->mem.userptr ==
+					cur_plane->mem.userptr)
+					return buf;
+				break;
+			case ICI_MEM_DMABUF:
+				if (new_plane->mem.dmafd ==
+					cur_plane->mem.dmafd)
+					return buf;
+				break;
+			}
+			//TODO: add multiplaner checks
+		}
+
+	}
+	return NULL;
+}
+
+static void ici_put_userpages(struct device *dev,
+					struct ici_kframe_plane
+					*kframe_plane)
+{
+	struct sg_table *sgt = kframe_plane->sgt;
+	struct scatterlist *sgl;
+	unsigned int i;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0)
+    DEFINE_DMA_ATTRS(attrs);
+#else
+    unsigned long attrs;
+#endif
+
+	struct mm_struct* mm = current->active_mm;
+	if (!mm){
+		dev_err(dev, "Failed to get active mm_struct ptr from current process.\n");
+		return;
+	}
+
+	down_read(&mm->mmap_sem);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0)
+	dma_set_attr(DMA_ATTR_SKIP_CPU_SYNC, &attrs);
+	dma_unmap_sg_attrs(kframe_plane->dev, sgt->sgl, sgt->orig_nents,
+				DMA_FROM_DEVICE, &attrs);
+#else
+    attrs = DMA_ATTR_SKIP_CPU_SYNC;
+	dma_unmap_sg_attrs(kframe_plane->dev, sgt->sgl, sgt->orig_nents,
+				DMA_FROM_DEVICE, attrs);
+#endif
+
+	for_each_sg(sgt->sgl, sgl, sgt->orig_nents, i) {
+		struct page *page = sg_page(sgl);
+
+		unsigned int npages = PAGE_ALIGN(sgl->offset + sgl->length)
+			>> PAGE_SHIFT;
+		unsigned int page_no;
+
+		for (page_no = 0; page_no < npages; ++page_no, ++page) {
+			set_page_dirty_lock(page);
+			put_page(page);
+		}
+	}
+
+	kfree(sgt);
+	kframe_plane->sgt = NULL;
+
+	up_read(&mm->mmap_sem);
+}
+
+static void ici_put_dma(struct device *dev,
+					struct ici_kframe_plane
+					*kframe_plane)
+{
+	struct sg_table *sgt = kframe_plane->sgt;
+
+	if (WARN_ON(!kframe_plane->db_attach)) {
+		pr_err("trying to unpin a not attached buffer\n");
+		return;
+	}
+
+	if (WARN_ON(!sgt)) {
+		pr_err("dmabuf buffer is already unpinned\n");
+		return;
+	}
+
+	if (kframe_plane->kaddr) {
+		dma_buf_vunmap(kframe_plane->db_attach->dmabuf,
+		kframe_plane->kaddr);
+		kframe_plane->kaddr = NULL;
+	}
+	dma_buf_unmap_attachment(kframe_plane->db_attach, sgt,
+				DMA_BIDIRECTIONAL);
+
+	kframe_plane->dma_addr = 0;
+	kframe_plane->sgt = NULL;
+
+}
+
+static int ici_map_dma(struct device *dev,
+					struct ici_frame_plane
+					*frame_plane,
+					struct ici_kframe_plane
+					*kframe_plane)
+{
+
+	int ret = 0;
+	int fd = frame_plane->mem.dmafd;
+
+	kframe_plane->dbdbuf = dma_buf_get(fd);
+	if (!kframe_plane->dbdbuf) {
+		ret = -EINVAL;
+		goto error;
+	}
+
+	if (frame_plane->length == 0)
+		kframe_plane->length = kframe_plane->dbdbuf->size;
+	else
+		kframe_plane->length = frame_plane->length;
+
+	kframe_plane->fd = fd;
+	kframe_plane->db_attach = dma_buf_attach(kframe_plane->dbdbuf, dev);
+
+	if (IS_ERR(kframe_plane->db_attach)) {
+		ret = PTR_ERR(kframe_plane->db_attach);
+		goto error_put;
+	}
+
+	kframe_plane->sgt = dma_buf_map_attachment(kframe_plane->db_attach,
+				DMA_BIDIRECTIONAL);
+	if (IS_ERR_OR_NULL(kframe_plane->sgt)) {
+		ret = -EINVAL;
+		kframe_plane->sgt = NULL;
+		dev_dbg(dev, "map attachment failed\n");
+		goto error_detach;
+	}
+
+	kframe_plane->dma_addr = sg_dma_address(kframe_plane->sgt->sgl);
+	kframe_plane->kaddr = dma_buf_vmap(kframe_plane->dbdbuf);
+
+	if (!kframe_plane->kaddr) {
+		ret = -EINVAL;
+		goto error_detach;
+	}
+
+	dev_dbg(dev, "MAPBUF: mapped fd %d\n", fd);
+
+	return 0;
+
+error_detach:
+	dma_buf_detach(kframe_plane->dbdbuf, kframe_plane->db_attach);
+error_put:
+	dma_buf_put(kframe_plane->dbdbuf);
+error:
+	return ret;
+}
+
+static int ici_get_userpages(struct device *dev,
+					 struct ici_frame_plane
+					 *frame_plane,
+					 struct ici_kframe_plane
+					 *kframe_plane)
+{
+	unsigned long start, end, addr;
+	int npages, array_size;
+	struct page **pages;
+	int nr = 0;
+	int ret = 0;
+	struct sg_table *sgt;
+	unsigned int i;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0)
+    DEFINE_DMA_ATTRS(attrs);
+#else
+    unsigned long attrs;
+#endif
+
+	addr = (unsigned long)frame_plane->mem.userptr;
+	start = addr & PAGE_MASK;
+	end = PAGE_ALIGN(addr + frame_plane->length);
+	npages = (end - start) >> PAGE_SHIFT;
+	array_size = npages * sizeof(struct page *);
+
+	if (!npages)
+		return -EINVAL;
+
+	sgt = kzalloc(sizeof(*sgt), GFP_KERNEL);
+	if (!sgt)
+		return -ENOMEM;
+
+	if (array_size <= PAGE_SIZE)
+		pages = kzalloc(array_size, GFP_KERNEL);
+	else
+		pages = vzalloc(array_size);
+
+	if (!pages) {
+		kfree(sgt);
+		return -ENOMEM;
+	}
+
+	down_read(&current->mm->mmap_sem);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0)
+	nr = get_user_pages(
+				current, current->mm,
+				start, npages, 1, 0, pages, NULL);
+#else
+    nr = get_user_pages(start, npages, FOLL_WRITE, pages, NULL);
+#endif
+	if (nr < npages)
+		goto error_free_pages;
+
+    ret = sg_alloc_table_from_pages(sgt, pages, npages,
+					addr & ~PAGE_MASK, frame_plane->length,
+					GFP_KERNEL);
+	if (ret) {
+		dev_err(dev, "Failed to init sgt\n");
+		goto error_free_pages;
+	}
+
+
+	kframe_plane->dev = dev;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0)
+    dma_set_attr(DMA_ATTR_SKIP_CPU_SYNC, &attrs);
+	sgt->nents = dma_map_sg_attrs(dev, sgt->sgl, sgt->orig_nents,
+					DMA_FROM_DEVICE, &attrs);
+#else
+    attrs = DMA_ATTR_SKIP_CPU_SYNC;
+    sgt->nents = dma_map_sg_attrs(dev, sgt->sgl, sgt->orig_nents,
+                    DMA_FROM_DEVICE, attrs);
+#endif
+
+	if (sgt->nents <= 0) {
+		dev_err(dev, "Failed to init dma_map\n");
+		ret = -EIO;
+		goto error_dma_map;
+	}
+	kframe_plane->dma_addr = sg_dma_address(sgt->sgl);
+	kframe_plane->sgt = sgt;
+
+error_free_page_list:
+	if (pages) {
+		if (array_size <= PAGE_SIZE)
+			kfree(pages);
+		else
+			vfree(pages);
+	}
+	up_read(&current->mm->mmap_sem);
+	return ret;
+
+error_dma_map:
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0)
+    dma_unmap_sg_attrs(dev, sgt->sgl, sgt->orig_nents,
+			DMA_FROM_DEVICE, &attrs);
+#else
+    dma_unmap_sg_attrs(dev, sgt->sgl, sgt->orig_nents,
+			DMA_FROM_DEVICE, attrs);
+#endif
+
+error_free_pages:
+	if (pages) {
+		for (i = 0; i < nr; i++)
+			put_page(pages[i]);
+	}
+	kfree(sgt);
+	goto error_free_page_list;
+}
+
+static int ici_get_userpages_virt(struct device *dev,
+					 struct ici_frame_plane
+					 *frame_plane,
+					 struct ici_kframe_plane
+					 *kframe_plane,
+					 struct page **pages)
+{
+	unsigned long addr;
+	int npages;
+	int ret = 0;
+	struct sg_table *sgt;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0)
+    DEFINE_DMA_ATTRS(attrs);
+#else
+    unsigned long attrs;
+#endif
+
+	addr = (unsigned long)frame_plane->mem.userptr;
+	npages = kframe_plane->npages;
+
+	if (!npages)
+		return -EINVAL;
+
+	sgt = kzalloc(sizeof(*sgt), GFP_KERNEL);
+	if (!sgt)
+		return -ENOMEM;
+
+    ret = sg_alloc_table_from_pages(sgt, pages, npages,
+					addr & ~PAGE_MASK, frame_plane->length,
+					GFP_KERNEL);
+	if (ret) {
+		dev_err(dev, "Failed to init sgt\n");
+		goto error_free_pages;
+	}
+
+
+	kframe_plane->dev = dev;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0)
+    dma_set_attr(DMA_ATTR_SKIP_CPU_SYNC, &attrs);
+	sgt->nents = dma_map_sg_attrs(dev, sgt->sgl, sgt->orig_nents,
+					DMA_FROM_DEVICE, &attrs);
+#else
+    attrs = DMA_ATTR_SKIP_CPU_SYNC;
+    sgt->nents = dma_map_sg_attrs(dev, sgt->sgl, sgt->orig_nents,
+				DMA_FROM_DEVICE, attrs);
+#endif
+
+	if (sgt->nents <= 0) {
+		dev_err(dev, "Failed to init dma_map\n");
+		ret = -EIO;
+		goto error_dma_map;
+	}
+	kframe_plane->dma_addr = sg_dma_address(sgt->sgl);
+	kframe_plane->sgt = sgt;
+
+error_free_page_list:
+	return ret;
+
+error_dma_map:
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0)
+    dma_unmap_sg_attrs(dev, sgt->sgl, sgt->orig_nents,
+			DMA_FROM_DEVICE, &attrs);
+#else
+    dma_unmap_sg_attrs(dev, sgt->sgl, sgt->orig_nents,
+			DMA_FROM_DEVICE, attrs);
+#endif
+
+error_free_pages:
+	kfree(sgt);
+	goto error_free_page_list;
+}
+
+int ici_isys_get_buf(struct ici_isys_stream *as,
+				struct ici_frame_info *frame_info)
+{
+	int res;
+	unsigned i;
+	struct ici_frame_buf_wrapper *buf;
+
+	struct ici_kframe_plane *kframe_plane;
+	struct ici_isys_frame_buf_list *buf_list = &as->buf_list;
+	int mem_type = frame_info->mem_type;
+
+	if (mem_type != ICI_MEM_USERPTR &&
+		mem_type != ICI_MEM_DMABUF) {
+		dev_err(&as->isys->adev->dev, "Memory type not supproted\n");
+		return -EINVAL;
+	}
+
+	if (!frame_info->frame_planes[0].length) {
+		dev_err(&as->isys->adev->dev, "User length not set\n");
+		return -EINVAL;
+	}
+	buf = ici_frame_buf_lookup(buf_list, frame_info);
+
+	if (buf) {
+		buf->state = ICI_BUF_PREPARED;
+		return 0;
+	}
+
+
+	buf = kzalloc(sizeof(*buf), GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	buf->buf_id = frame_info->frame_buf_id;
+	buf->buf_list = buf_list;
+	memcpy(&buf->frame_info, frame_info, sizeof(buf->frame_info));
+
+	switch (mem_type) {
+	case ICI_MEM_USERPTR:
+		if (!frame_info->frame_planes[0].mem.userptr) {
+			dev_err(&as->isys->adev->dev,
+				"User pointer not define\n");
+			res = -EINVAL;
+			goto err_exit;
+		}
+		for (i = 0; i < frame_info->num_planes; i++) {
+			kframe_plane = &buf->kframe_info.planes[i];
+			kframe_plane->mem_type =
+			ICI_MEM_USERPTR;
+			res =
+				ici_get_userpages(
+					&as->isys->adev->dev,
+						&frame_info->
+						frame_planes[i],
+						kframe_plane);
+			if (res)
+				goto err_exit;
+		}
+		break;
+	case ICI_MEM_DMABUF:
+		for (i = 0; i < frame_info->num_planes; i++) {
+			kframe_plane = &buf->kframe_info.planes[i];
+			kframe_plane->mem_type =
+				ICI_MEM_DMABUF;
+			res = ici_map_dma(
+						&as->isys->adev->dev,
+						&frame_info->
+						frame_planes[i],
+						kframe_plane);
+			if (res)
+				goto err_exit;
+		}
+		break;
+	}
+
+	mutex_lock(&buf_list->mutex);
+	buf->state = ICI_BUF_PREPARED;
+	list_add_tail(&buf->node, &buf_list->getbuf_list);
+	mutex_unlock(&buf_list->mutex);
+	return 0;
+
+err_exit:
+	kfree(buf);
+	return res;
+}
+
+int ici_isys_get_buf_virt(struct ici_isys_stream *as,
+				struct ici_frame_buf_wrapper *frame_buf,
+				struct page **pages)
+{
+	int res;
+	unsigned i;
+	struct ici_frame_buf_wrapper *buf;
+
+	struct ici_kframe_plane *kframe_plane;
+	struct ici_isys_frame_buf_list *buf_list = &as->buf_list;
+	int mem_type = frame_buf->frame_info.mem_type;
+
+	if (mem_type != ICI_MEM_USERPTR &&
+		mem_type != ICI_MEM_DMABUF) {
+		dev_err(&as->isys->adev->dev, "Memory type not supproted\n");
+		return -EINVAL;
+	}
+
+	if (!frame_buf->frame_info.frame_planes[0].length) {
+		dev_err(&as->isys->adev->dev, "User length not set\n");
+		return -EINVAL;
+	}
+	buf = ici_frame_buf_lookup(buf_list, &frame_buf->frame_info);
+
+	if (buf) {
+		buf->state = ICI_BUF_PREPARED;
+		return 0;
+	}
+
+
+	buf = frame_buf;
+
+	buf->buf_list = buf_list;
+
+	switch (mem_type) {
+	case ICI_MEM_USERPTR:
+		if (!frame_buf->frame_info.frame_planes[0].mem.userptr) {
+			dev_err(&as->isys->adev->dev,
+				"User pointer not define\n");
+			return -EINVAL;
+		}
+		for (i = 0; i < frame_buf->frame_info.num_planes; i++) {
+			kframe_plane = &buf->kframe_info.planes[i];
+			kframe_plane->mem_type =
+			ICI_MEM_USERPTR;
+			res =
+				ici_get_userpages_virt(
+					&as->isys->adev->dev,
+						&frame_buf->frame_info.frame_planes[i],
+						kframe_plane,
+						pages);
+			if (res)
+				return res;
+		}
+		break;
+	case ICI_MEM_DMABUF:
+		break;
+	}
+
+	mutex_lock(&buf_list->mutex);
+	buf->state = ICI_BUF_PREPARED;
+	list_add_tail(&buf->node, &buf_list->getbuf_list);
+	mutex_unlock(&buf_list->mutex);
+	return 0;
+}
+
+int ici_isys_put_buf(struct ici_isys_stream *as,
+				struct ici_frame_info *frame_info,
+				unsigned int f_flags)
+{
+	struct ici_frame_buf_wrapper *buf;
+	struct ici_isys_frame_buf_list *buf_list = &as->buf_list;
+	unsigned long flags = 0;
+	int rval;
+
+	spin_lock_irqsave(&buf_list->lock, flags);
+	if (list_empty(&buf_list->putbuf_list)) {
+		/* Wait */
+		if (!(f_flags & O_NONBLOCK)) {
+			spin_unlock_irqrestore(&buf_list->lock, flags);
+			rval = wait_event_interruptible(buf_list->wait,
+							!list_empty(&buf_list->
+								putbuf_list));
+			spin_lock_irqsave(&buf_list->lock, flags);
+			if (rval == -ERESTARTSYS)
+				return rval;
+		}
+	}
+
+	if (list_empty(&buf_list->putbuf_list)) {
+		spin_unlock_irqrestore(&buf_list->lock, flags);
+		return -ENODATA;
+	}
+
+	buf = list_entry(buf_list->putbuf_list.next,
+			struct ici_frame_buf_wrapper, node);
+	list_del(&buf->node);
+	spin_unlock_irqrestore(&buf_list->lock, flags);
+
+	mutex_lock(&buf_list->mutex);
+	buf->state = ICI_BUF_DONE;
+	list_add_tail(&buf->node,
+						&buf_list->getbuf_list);
+	mutex_unlock(&buf_list->mutex);
+
+	memcpy(frame_info, &buf->frame_info, sizeof(buf->frame_info));
+	return 0;
+}
+
+static void frame_buf_done(
+	struct ici_isys_frame_buf_list *buf_list,
+	struct ici_frame_buf_wrapper *buf)
+{
+	unsigned long flags = 0;
+	spin_lock_irqsave(&buf_list->lock, flags);
+	buf->state = ICI_BUF_READY;
+	list_add_tail(&buf->node, &buf_list->putbuf_list);
+	spin_unlock_irqrestore(&buf_list->lock, flags);
+	wake_up_interruptible(&buf_list->wait);
+}
+
+void ici_isys_frame_buf_ready(struct ici_isys_pipeline
+					*ip,
+					struct ia_css_isys_resp_info *info)
+{
+	struct ici_frame_buf_wrapper *buf;
+	struct ici_isys_stream *as =
+	    ici_pipeline_to_stream(ip);
+	struct ici_isys_frame_buf_list *buf_list = &as->buf_list;
+	struct ici_isys *isys = as->isys;
+	unsigned long flags = 0;
+	bool found = false;
+
+	dev_dbg(&isys->adev->dev, "buffer: received buffer %8.8x\n",
+		info->pin.addr);
+
+	spin_lock_irqsave(&buf_list->lock, flags);
+
+	list_for_each_entry_reverse(buf, &buf_list->getbuf_list, node) {
+		struct ici_kframe_plane* plane;
+
+		if (buf->state != ICI_BUF_ACTIVE)
+			continue;
+		plane = &buf->kframe_info.planes[0];
+		if (plane->dma_addr == info->pin.addr) {
+			found = true;
+			break;
+		}
+	}
+
+	if (!found) {
+		spin_unlock_irqrestore(&buf_list->lock, flags);
+		dev_err(&isys->adev->dev,
+			"WARNING: cannot find a matching video buffer!\n");
+		return;
+	}
+
+	list_del(&buf->node);
+	spin_unlock_irqrestore(&buf_list->lock, flags);
+
+	/*
+	 * For interlaced buffers, the notification to user space
+	 * is postponed to capture_done event since the field
+	 * information is available only at that time.
+	 */
+	if (ip->interlaced) {
+		spin_lock_irqsave(&buf_list->short_packet_queue_lock, flags);
+		list_add(&buf->node, &buf_list->interlacebuf_list);
+		spin_unlock_irqrestore(&buf_list->short_packet_queue_lock,
+					   flags);
+	} else {
+		buf->frame_info.field = ICI_FIELD_NONE;
+		frame_buf_done(buf_list, buf);
+		if (as->frame_done_notify_queue)
+			as->frame_done_notify_queue();
+	}
+
+	dev_dbg(&isys->adev->dev, "buffer: found buffer %p\n", buf);
+}
+
+static void unmap_buf(struct ici_frame_buf_wrapper *buf)
+{
+	int i;
+
+	for (i = 0; i < buf->frame_info.num_planes; i++) {
+		struct ici_kframe_plane *kframe_plane =
+			&buf->kframe_info.planes[i];
+		switch (kframe_plane->mem_type) {
+		case ICI_MEM_USERPTR:
+			ici_put_userpages(kframe_plane->dev,
+						kframe_plane);
+		break;
+		case ICI_MEM_DMABUF:
+			ici_put_dma(kframe_plane->dev,
+					kframe_plane);
+		break;
+		default:
+			dev_err(&buf->buf_list->strm_dev->dev, "not supported memory type: %d\n",
+				kframe_plane->mem_type);
+		break;
+		}
+	}
+}
+
+void ici_isys_frame_buf_stream_cancel(struct
+						  ici_isys_stream
+						  *as)
+{
+	struct ici_isys_frame_buf_list *buf_list = &as->buf_list;
+	struct ici_frame_buf_wrapper *buf;
+	struct ici_frame_buf_wrapper *next_buf;
+
+	list_for_each_entry_safe(buf, next_buf, &buf_list->getbuf_list, node) {
+		list_del(&buf->node);
+		unmap_buf(buf);
+	}
+	list_for_each_entry_safe(buf, next_buf, &buf_list->putbuf_list, node) {
+		list_del(&buf->node);
+		unmap_buf(buf);
+	}
+	list_for_each_entry_safe(buf, next_buf, &buf_list->interlacebuf_list,
+								node) {
+		list_del(&buf->node);
+		unmap_buf(buf);
+	}
+}
+
+int ici_isys_frame_buf_add_next(
+	struct ici_isys_stream *as,
+	struct ia_css_isys_frame_buff_set *css_buf)
+{
+	struct ici_frame_buf_wrapper *buf = NULL;
+	struct ici_isys_frame_buf_list *buf_list = &as->buf_list;
+	unsigned long flags = 0;
+	bool found = false;
+
+	mutex_lock(&buf_list->mutex);
+
+	list_for_each_entry(buf, &buf_list->getbuf_list, node) {
+		if (buf->state == ICI_BUF_PREPARED){
+			found = true;
+			break;
+		}
+	}
+
+	if (!found) {
+		/* No more buffers available */
+		goto cleanup_mutex;
+	}
+
+
+	buf->state = ICI_BUF_ACTIVE;
+	mutex_unlock(&buf_list->mutex);
+
+	css_buf->send_irq_sof = 1;
+	css_buf->output_pins[buf_list->fw_output].addr =
+		(uint32_t)buf->kframe_info.planes[0].dma_addr;
+    css_buf->output_pins[buf_list->fw_output].out_buf_id =
+		buf->buf_id + 1;
+
+	if (buf_list->short_packet_bufs) {
+		struct ici_frame_short_buf* sb;
+		struct ici_isys_mipi_packet_header* ph;
+		struct ia_css_isys_output_pin_payload *output_pin;
+		spin_lock_irqsave(&buf_list->short_packet_queue_lock, flags);
+		if (!list_empty(&buf_list->short_packet_incoming)) {
+			sb = list_entry(buf_list->short_packet_incoming.next,
+				struct ici_frame_short_buf, node);
+			list_del(&sb->node);
+			list_add_tail(&sb->node, &buf_list->short_packet_active);
+			spin_unlock_irqrestore(&buf_list->short_packet_queue_lock,
+				flags);
+
+			ph = (struct ici_isys_mipi_packet_header*)
+				sb->buffer;
+			ph->word_count = 0xffff;
+			ph->dtype = 0xff;
+			dma_sync_single_for_cpu(sb->dev, sb->dma_addr, sizeof(*ph),
+				DMA_BIDIRECTIONAL);
+			output_pin = &css_buf->output_pins[
+				buf_list->short_packet_output_pin];
+			output_pin->addr = sb->dma_addr;
+			output_pin->out_buf_id = sb->buf_id + 1;
+		} else {
+			spin_unlock_irqrestore(&buf_list->short_packet_queue_lock,
+				flags);
+			dev_err(&as->isys->adev->dev,
+				"No more short packet buffers. Driver bug?");
+			WARN_ON(1);
+		}
+	}
+	return 0;
+
+cleanup_mutex:
+	mutex_unlock(&buf_list->mutex);
+	return -ENODATA;
+}
+
+void ici_isys_frame_buf_capture_done(
+	struct ici_isys_pipeline *ip,
+	struct ia_css_isys_resp_info *info)
+{
+	if (ip->interlaced) {
+		struct ici_isys_stream *as =
+			ici_pipeline_to_stream(ip);
+		struct ici_isys_frame_buf_list *buf_list =
+			&as->buf_list;
+		unsigned long flags = 0;
+		struct ici_frame_short_buf* sb;
+		struct ici_frame_buf_wrapper* buf;
+		struct ici_frame_buf_wrapper* buf_safe;
+		struct list_head list;
+
+		spin_lock_irqsave(&buf_list->short_packet_queue_lock, flags);
+		if(ip->short_packet_source == IPU_ISYS_SHORT_PACKET_FROM_RECEIVER)
+			if (!list_empty(&buf_list->short_packet_active)) {
+			sb = list_last_entry(&buf_list->short_packet_active,
+				struct ici_frame_short_buf, node);
+			list_move(&sb->node, &buf_list->short_packet_incoming);
+		}
+
+		list_cut_position(&list,
+				  &buf_list->interlacebuf_list,
+				  buf_list->interlacebuf_list.prev);
+		spin_unlock_irqrestore(&buf_list->short_packet_queue_lock,
+					   flags);
+
+		list_for_each_entry_safe(buf, buf_safe, &list, node) {
+			buf->frame_info.field = ip->cur_field;
+			list_del(&buf->node);
+			frame_buf_done(buf_list, buf);
+		if (as->frame_done_notify_queue)
+			as->frame_done_notify_queue();
+		}
+	}
+}
+
+void ici_isys_frame_short_packet_ready(
+	struct ici_isys_pipeline *ip,
+	struct ia_css_isys_resp_info *info)
+{
+	struct ici_isys_stream *as =
+		ici_pipeline_to_stream(ip);
+	struct ici_isys_frame_buf_list *buf_list =
+		&as->buf_list;
+	unsigned long flags = 0;
+	struct ici_frame_short_buf* sb;
+
+	spin_lock_irqsave(&buf_list->short_packet_queue_lock, flags);
+	if (list_empty(&buf_list->short_packet_active)) {
+		spin_unlock_irqrestore(&buf_list->short_packet_queue_lock,
+			flags);
+		dev_err(&as->isys->adev->dev,
+			"active short buffer queue empty\n");
+		return;
+	}
+	list_for_each_entry_reverse(sb, &buf_list->short_packet_active,
+		node) {
+		if (sb->dma_addr == info->pin.addr) {
+			ip->cur_field =
+				ici_isys_csi2_get_current_field(
+					&as->isys->adev->dev,
+					(struct ici_isys_mipi_packet_header*)
+					sb->buffer);
+			break;
+		}
+	}
+	spin_unlock_irqrestore(&buf_list->short_packet_queue_lock, flags);
+}
+
+void ici_isys_frame_buf_short_packet_destroy(
+	struct ici_isys_stream* as)
+{
+	struct ici_isys_frame_buf_list *buf_list =
+		&as->buf_list;
+    unsigned int i;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0)
+    struct dma_attrs attrs;
+	init_dma_attrs(&attrs);
+	dma_set_attr(DMA_ATTR_NON_CONSISTENT, &attrs);
+#else
+    unsigned long attrs;
+    attrs = DMA_ATTR_NON_CONSISTENT;
+#endif
+    if (!buf_list->short_packet_bufs)
+		return;
+
+	for (i = 0 ; i < ICI_ISYS_SHORT_PACKET_BUFFER_NUM ;
+		i++) {
+		if (buf_list->short_packet_bufs[i].buffer)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0)
+				dma_free_attrs(&as->isys->adev->dev,
+					buf_list->short_packet_bufs[i].length,
+					buf_list->short_packet_bufs[i].buffer,
+					buf_list->short_packet_bufs[i].dma_addr, &attrs);
+#else
+				dma_free_attrs(&as->isys->adev->dev,
+					buf_list->short_packet_bufs[i].length,
+					buf_list->short_packet_bufs[i].buffer,
+					buf_list->short_packet_bufs[i].dma_addr, attrs);
+#endif
+	}
+	kfree(buf_list->short_packet_bufs);
+	buf_list->short_packet_bufs = NULL;
+}
+
+int ici_isys_frame_buf_short_packet_setup(
+	struct ici_isys_stream* as,
+	struct ici_stream_format* source_fmt)
+{
+	struct ici_isys_frame_buf_list *buf_list =
+		&as->buf_list;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0)
+    struct dma_attrs attrs;
+#else
+    unsigned long attrs;
+#endif
+	unsigned int i;
+	size_t buf_size;
+
+	buf_size =
+		ICI_ISYS_SHORT_PACKET_BUF_SIZE(source_fmt->ffmt.height);
+	buf_list->num_short_packet_lines =
+		ICI_ISYS_SHORT_PACKET_PKT_LINES(source_fmt->ffmt.height);
+
+	INIT_LIST_HEAD(&buf_list->short_packet_incoming);
+	INIT_LIST_HEAD(&buf_list->short_packet_active);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0)
+	init_dma_attrs(&attrs);
+	dma_set_attr(DMA_ATTR_NON_CONSISTENT, &attrs);
+#else
+    attrs = DMA_ATTR_NON_CONSISTENT;
+#endif
+
+    as->ip.cur_field = ICI_FIELD_TOP;
+
+	buf_list->short_packet_bufs = kzalloc(
+		sizeof(struct ici_frame_short_buf) *
+		 ICI_ISYS_SHORT_PACKET_BUFFER_NUM, GFP_KERNEL);
+	if (!buf_list->short_packet_bufs)
+		return -ENOMEM;
+
+	for (i = 0 ; i < ICI_ISYS_SHORT_PACKET_BUFFER_NUM ;
+		i++) {
+		struct ici_frame_short_buf* sb =
+			&buf_list->short_packet_bufs[i];
+		sb->buf_id = i;
+		sb->buf_list = buf_list;
+		sb->length = buf_size;
+		sb->dev = &as->isys->adev->dev;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0)
+		sb->buffer = dma_alloc_attrs(
+			sb->dev, buf_size, &sb->dma_addr, GFP_KERNEL, &attrs);
+#else
+		sb->buffer = dma_alloc_attrs(
+			sb->dev, buf_size, &sb->dma_addr, GFP_KERNEL, attrs);
+#endif
+		if (!sb->buffer) {
+			ici_isys_frame_buf_short_packet_destroy(as);
+			return -ENOMEM;
+		}
+		list_add(&sb->node, &buf_list->short_packet_incoming);
+	}
+	return 0;
+}
+
+int ici_isys_frame_buf_init(
+	struct ici_isys_frame_buf_list* buf_list)
+{
+	buf_list->drv_priv = NULL;
+	mutex_init(&buf_list->mutex);
+	spin_lock_init(&buf_list->lock);
+	spin_lock_init(&buf_list->short_packet_queue_lock);
+	INIT_LIST_HEAD(&buf_list->getbuf_list);
+	INIT_LIST_HEAD(&buf_list->putbuf_list);
+	INIT_LIST_HEAD(&buf_list->interlacebuf_list);
+	init_waitqueue_head(&buf_list->wait);
+	return 0;
+}
+
+#endif /* #ICI_ENABLED */
diff --git a/drivers/media/pci/intel/ici/ici-isys-frame-buf.h b/drivers/media/pci/intel/ici/ici-isys-frame-buf.h
new file mode 100644
index 0000000..771967c
--- /dev/null
+++ b/drivers/media/pci/intel/ici/ici-isys-frame-buf.h
@@ -0,0 +1,139 @@
+/* SPDX-License-Identifier: (BSD-3-Clause OR GPL-2.0) */
+/*
+ * Copyright (C) 2018 Intel Corporation
+ */
+
+#ifndef ICI_ISYS_FRAME_BUF_H
+#define ICI_ISYS_FRAME_BUF_H
+
+#include <linux/scatterlist.h>
+#include <linux/list.h>
+#include <media/ici.h>
+
+struct ici_isys_pipeline;
+struct ia_css_isys_frame_buff_set;
+struct ici_stream_device;
+struct ici_isys_stream;
+struct ia_css_isys_resp_info;
+
+struct ici_kframe_plane {
+	struct device *dev;
+	unsigned int mem_type;
+	unsigned long length;
+
+	/* For user_ptr */
+	unsigned long page_offset;
+
+	/* Common */
+	dma_addr_t dma_addr;
+	struct sg_table *sgt;
+
+	/* For DMA operation */
+	int fd;
+	struct dma_buf_attachment *db_attach;
+	struct dma_buf *dbdbuf;
+	void *kaddr;
+
+	/* For mediator */
+	int npages;
+	u64 page_table_ref;
+};
+
+struct ici_kframe_info {
+	struct ici_kframe_plane planes[ICI_MAX_PLANES];
+	int num_planes;
+};
+
+typedef enum frame_buf_state_ {
+	ICI_BUF_NOT_SET,
+	ICI_BUF_PREPARED,
+	ICI_BUF_ACTIVE,
+	ICI_BUF_READY,
+	ICI_BUF_DONE,
+} frame_buf_state;
+
+struct ici_frame_buf_wrapper {
+	struct ici_kframe_info kframe_info;
+	struct ici_frame_info frame_info;
+	struct list_head node;
+	struct ici_isys_frame_buf_list *buf_list;
+	struct list_head uos_node;
+	struct ici_isys_frame_buf_list *uos_buf_list;
+	uint32_t buf_id;
+	frame_buf_state state;
+};
+
+struct ici_frame_short_buf {
+	void* buffer;
+	dma_addr_t dma_addr;
+	struct device* dev;
+	size_t length;
+	struct list_head node;
+	struct ici_isys_frame_buf_list *buf_list;
+	uint32_t buf_id;
+};
+
+struct ici_isys_frame_buf_list {
+	void *drv_priv;
+	struct mutex mutex;
+	struct list_head getbuf_list;
+	struct list_head putbuf_list;
+
+	struct list_head interlacebuf_list;
+
+	uint32_t css_pin_type;
+	unsigned int fw_output;
+	spinlock_t lock;
+	wait_queue_head_t wait;
+	struct ici_stream_device *strm_dev;
+	spinlock_t short_packet_queue_lock;
+	struct list_head short_packet_incoming;
+	struct list_head short_packet_active;
+	struct ici_frame_short_buf* short_packet_bufs;
+	uint32_t num_short_packet_lines;
+	uint32_t short_packet_output_pin;
+};
+
+int ici_isys_get_buf(struct ici_isys_stream *as,
+				 struct ici_frame_info
+				 *user_frame_info);
+
+int ici_isys_get_buf_virt(struct ici_isys_stream *as,
+				struct ici_frame_buf_wrapper *frame_buf,
+				struct page **pages);
+
+int ici_isys_put_buf(struct ici_isys_stream *as,
+				 struct ici_frame_info
+				 *user_frame_info, unsigned int f_flags);
+
+int ici_isys_frame_buf_init(struct
+					ici_isys_frame_buf_list
+					*buf_list);
+
+void ici_isys_frame_buf_ready(
+	struct ici_isys_pipeline *ip,
+	struct ia_css_isys_resp_info *info);
+
+int ici_isys_frame_buf_add_next(
+	struct ici_isys_stream *as,
+	struct ia_css_isys_frame_buff_set *css_buf);
+
+void ici_isys_frame_buf_stream_cancel(
+	struct ici_isys_stream *as);
+
+int ici_isys_frame_buf_short_packet_setup(
+	struct ici_isys_stream* as,
+	struct ici_stream_format* source_fmt);
+
+void ici_isys_frame_buf_short_packet_destroy(
+	struct ici_isys_stream* as);
+
+void ici_isys_frame_short_packet_ready(
+	struct ici_isys_pipeline *ip,
+	struct ia_css_isys_resp_info *info);
+
+void ici_isys_frame_buf_capture_done(
+	struct ici_isys_pipeline *ip,
+	struct ia_css_isys_resp_info *info);
+
+#endif /* ICI_ISYS_FRAME_BUF_H */
diff --git a/drivers/media/pci/intel/ici/ici-isys-pipeline-device.c b/drivers/media/pci/intel/ici/ici-isys-pipeline-device.c
new file mode 100644
index 0000000..a4e4d77
--- /dev/null
+++ b/drivers/media/pci/intel/ici/ici-isys-pipeline-device.c
@@ -0,0 +1,493 @@
+// SPDX-License-Identifier: (BSD-3-Clause OR GPL-2.0)
+/*
+ * Copyright (C) 2018 Intel Corporation
+ */
+
+#include "./ici/ici-isys.h"
+
+#ifdef ICI_ENABLED
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/uaccess.h>
+#include <linux/compat.h>
+
+#include "./ici/ici-isys-pipeline-device.h"
+#include "./ici/ici-isys-pipeline.h"
+
+static struct class *pipeline_class;
+
+static struct ici_isys_node* find_node(
+	struct ici_isys_pipeline_device *pipe_dev,
+	unsigned id);
+
+static int pipeline_device_open(struct inode *inode, struct file *file)
+{
+	struct ici_isys_pipeline_device *pipe_dev =
+	    inode_to_ici_isys_pipeline_device(inode);
+	int rval = 0;
+
+	file->private_data = pipe_dev;
+
+	get_device(&pipe_dev->dev);
+
+	DEBUGK("pipeline_device_open\n");
+
+	return rval;
+}
+
+static int pipeline_device_release(struct inode *inode,
+	struct file *file)
+{
+	struct ici_isys_pipeline_device *pipe_dev =
+	    inode_to_ici_isys_pipeline_device(inode);
+
+	put_device(&pipe_dev->dev);
+
+	DEBUGK("pipeline_device_release\n");
+
+	return 0;
+}
+
+static int pipeline_enum_links(struct file *file, void *fh,
+	struct ici_links_query *links_query)
+{
+	struct ici_isys_node *node;
+	struct node_pipe* pipe;
+	struct node_pad* pad;
+	struct ici_isys_pipeline_device *pipe_dev =
+			file->private_data;
+	struct ici_link_desc* link;
+
+	node = find_node(pipe_dev, links_query->pad.node_id);
+	if (!node)
+		return -ENODEV;
+	if (links_query->pad.pad_idx >= node->nr_pads)
+		return -EINVAL;
+
+	pad = &node->node_pad[links_query->pad.pad_idx];
+	if (pad->pad_id != links_query->pad.pad_idx)
+		return -EINVAL;
+
+	links_query->links_cnt = 0;
+
+	list_for_each_entry(pipe, &node->node_pipes, list_entry) {
+		if (pipe->src_pad != pad && pipe->sink_pad != pad)
+			continue;
+		link = &links_query->links[links_query->links_cnt];
+		link->source.node_id = pipe->src_pad->node->node_id;
+		link->source.pad_idx = pipe->src_pad->pad_id;
+		link->source.flags = pipe->src_pad->flags;
+		link->sink.node_id = pipe->sink_pad->node->node_id;
+		link->sink.pad_idx = pipe->sink_pad->pad_id;
+		link->sink.flags = pipe->sink_pad->flags;
+		link->flags = pipe->flags;
+		++links_query->links_cnt;
+		if (WARN_ON(links_query->links_cnt >=
+			ICI_MAX_LINKS)) {
+			dev_warn(&pipe_dev->dev,
+				"Too many links defined. %d\n",
+				links_query->links_cnt);
+			break;
+		}
+	}
+	return 0;
+}
+
+static int pipeline_enum_nodes(struct file *file, void *fh,
+	struct ici_node_desc *node_desc)
+{
+	struct ici_isys_pipeline_device* pipeline_dev =
+		file->private_data;
+	struct ici_isys_node *node;
+	struct ici_pad_desc* pad_desc;
+	int pad;
+	bool found = false;
+
+	node_desc->node_count = 0;
+	list_for_each_entry(node, &pipeline_dev->nodes, node_entry) {
+		node_desc->node_count++;
+		if (node_desc->node_id != node->node_id)
+			continue;
+
+		/* fill out the node data */
+		found = true;
+		memcpy(node_desc->name, node->name,
+				sizeof(node_desc->name));
+		node_desc->nr_pads = node->nr_pads;
+		for (pad=0; pad < node->nr_pads; pad++) {
+			pad_desc = &node_desc->node_pad[pad];
+			pad_desc->pad_idx = node->node_pad[pad].pad_id;
+			pad_desc->node_id = node->node_id;
+			pad_desc->flags = node->node_pad[pad].flags;
+		}
+	}
+	if (node_desc->node_id == -1)
+		return 0;
+	if (!found)
+		return -ENODEV;
+	return 0;
+}
+
+static struct ici_isys_node* find_node(
+	struct ici_isys_pipeline_device *pipe_dev,
+	unsigned id)
+{
+	struct ici_isys_node *ici_node;
+
+	list_for_each_entry(ici_node, &pipe_dev->nodes, node_entry) {
+		if (ici_node->node_id == id)
+			return ici_node;
+	}
+	return NULL;
+}
+
+static int ici_pipeline_get_supported_format(struct file *file,
+	void *fh,
+	struct ici_pad_supported_format_desc *format_desc)
+{
+	struct ici_isys_node *node;
+	struct ici_isys_pipeline_device *pipe_dev =
+			file->private_data;
+
+	node = find_node(pipe_dev, format_desc->pad.node_id);
+	if (!node)
+		return -ENODEV;
+
+	if (node->node_get_pad_supported_format)
+		return node->node_get_pad_supported_format(node,
+			format_desc);
+	return -ENODEV;
+}
+
+static struct node_pipe* find_pipe(
+			struct ici_isys_node* src_node,
+			struct ici_link_desc *link)
+{
+	struct node_pipe *np;
+
+	list_for_each_entry(np, &src_node->node_pipes, list_entry) {
+		if (np->src_pad->node->node_id == link->source.node_id
+			&& np->src_pad->pad_id == link->source.pad_idx
+			&& np->sink_pad->node->node_id ==
+				link->sink.node_id
+			&& np->sink_pad->pad_id == link->sink.pad_idx)
+
+			return np;
+	}
+
+	return NULL;
+}
+
+static int ici_setup_link(struct file *file, void *fh,
+				struct ici_link_desc *link)
+{
+	int rval = 0;
+	struct ici_isys_pipeline_device *pipe_dev =
+			file->private_data;
+	struct ici_isys_node *src_node, *sink_node;
+	struct node_pipe *np;
+
+	src_node = find_node(pipe_dev, link->source.node_id);
+	if (!src_node)
+		return -ENODEV;
+
+	sink_node = find_node(pipe_dev, link->sink.node_id);
+	if (!sink_node)
+		return -ENODEV;
+
+	np = find_pipe(src_node, link);
+
+	if (np) {
+		np->flags = link->flags;
+	} else {
+		dev_warn(&pipe_dev->dev, "Link not found\n");
+		return -ENODEV;
+	}
+
+	np = find_pipe(sink_node, link);
+	if (np)
+		np->flags = link->flags | ICI_LINK_FLAG_BACKLINK;
+	else
+		dev_warn(&pipe_dev->dev, "Backlink not found\n");
+
+	return rval;
+}
+
+int ici_pipeline_set_ffmt(struct file *file, void *fh,
+	struct ici_pad_framefmt *ffmt)
+{
+	struct ici_isys_pipeline_device *pipe_dev =
+			file->private_data;
+	struct ici_isys_node *node;
+	int rval = -ENODEV;
+
+	node = find_node(pipe_dev, ffmt->pad.node_id);
+	if (!node)
+		return -ENODEV;
+
+	if (node->node_set_pad_ffmt)
+		rval = node->node_set_pad_ffmt(node, ffmt);
+
+	return rval;
+}
+
+int ici_pipeline_get_ffmt(struct file *file, void *fh,
+	struct ici_pad_framefmt *ffmt)
+{
+	struct ici_isys_pipeline_device *pipe_dev =
+			file->private_data;
+	struct ici_isys_node *node;
+	int rval = -ENODEV;
+
+	node = find_node(pipe_dev, ffmt->pad.node_id);
+	if (!node)
+		return -ENODEV;
+
+	if (node->node_get_pad_ffmt)
+		rval = node->node_get_pad_ffmt(node, ffmt);
+
+	return rval;
+}
+
+static int ici_pipeline_set_sel(struct file *file, void *fh,
+				struct ici_pad_selection *pad_sel)
+{
+	struct ici_isys_node *node;
+	struct ici_isys_pipeline_device *pipe_dev =
+			file->private_data;
+
+	node = find_node(pipe_dev, pad_sel->pad.node_id);
+	if (!node)
+		return -ENODEV;
+
+	if (node->node_set_pad_sel)
+		return node->node_set_pad_sel(node, pad_sel);
+	return -ENODEV;
+}
+
+static int ici_pipeline_get_sel(struct file *file, void *fh,
+				struct ici_pad_selection *pad_sel)
+{
+	struct ici_isys_node *node;
+	struct ici_isys_pipeline_device *pipe_dev =
+			file->private_data;
+
+	node = find_node(pipe_dev, pad_sel->pad.node_id);
+	if (!node)
+		return -ENODEV;
+
+	if (node->node_get_pad_sel)
+		return node->node_get_pad_sel(node, pad_sel);
+	return -ENODEV;
+}
+
+static long ici_pipeline_ioctl_common(void __user *up,
+	struct file *file, unsigned int ioctl_cmd,
+	unsigned long ioctl_arg)
+{
+	union {
+		struct ici_node_desc node_desc;
+		struct ici_link_desc link;
+		struct ici_pad_framefmt pad_prop;
+		struct ici_pad_supported_format_desc
+			format_desc;
+		struct ici_links_query links_query;
+		struct ici_pad_selection pad_sel;
+	} isys_ioctl_cmd_args;
+	int err = 0;
+	struct ici_isys_pipeline_device *pipe_dev =
+						file->private_data;
+	const struct ici_pipeline_ioctl_ops *ops;
+
+	if (_IOC_SIZE(ioctl_cmd) > sizeof(isys_ioctl_cmd_args))
+		return -ENOTTY;
+
+	if (_IOC_DIR(ioctl_cmd) & _IOC_WRITE) {
+		err = copy_from_user(&isys_ioctl_cmd_args, up,
+			_IOC_SIZE(ioctl_cmd));
+		if (err)
+			return -EFAULT;
+	}
+
+	mutex_lock(&pipe_dev->mutex);
+	ops = pipe_dev->pipeline_ioctl_ops;
+	switch(ioctl_cmd) {
+	case ICI_IOC_ENUM_NODES:
+		err = ops->pipeline_enum_nodes(file, pipe_dev,
+			&isys_ioctl_cmd_args.node_desc);
+		break;
+	case ICI_IOC_ENUM_LINKS:
+		err = ops->pipeline_enum_links(file, pipe_dev,
+			&isys_ioctl_cmd_args.links_query);
+		break;
+	case ICI_IOC_SETUP_PIPE:
+		err = ops->pipeline_setup_pipe(file, pipe_dev,
+			&isys_ioctl_cmd_args.link);
+		break;
+	case ICI_IOC_SET_FRAMEFMT:
+		err = ops->pad_set_ffmt(file, pipe_dev,
+			&isys_ioctl_cmd_args.pad_prop);
+		break;
+	case ICI_IOC_GET_FRAMEFMT:
+		err = ops->pad_get_ffmt(file, pipe_dev,
+			&isys_ioctl_cmd_args.pad_prop);
+		break;
+	case ICI_IOC_GET_SUPPORTED_FRAMEFMT:
+		err = ops->pad_get_supported_format(file, pipe_dev,
+			&isys_ioctl_cmd_args.format_desc);
+		break;
+	case ICI_IOC_SET_SELECTION:
+		err = ops->pad_set_sel(file, pipe_dev,
+			&isys_ioctl_cmd_args.pad_sel);
+		break;
+	case ICI_IOC_GET_SELECTION:
+		err = ops->pad_get_sel(file, pipe_dev,
+			&isys_ioctl_cmd_args.pad_sel);
+		break;
+	default:
+		err = -ENOTTY;
+		break;
+	}
+
+	mutex_unlock(&pipe_dev->mutex);
+	if (err < 0)
+		return err;
+
+	if (_IOC_DIR(ioctl_cmd) & _IOC_READ) {
+		err = copy_to_user(up, &isys_ioctl_cmd_args,
+			_IOC_SIZE(ioctl_cmd));
+		if (err)
+			return -EFAULT;
+	}
+
+	return 0;
+}
+
+static long ici_pipeline_ioctl(struct file *file,
+	unsigned int ioctl_cmd, unsigned long ioctl_arg)
+{
+	long status = 0;
+	void __user *up = (void __user *)ioctl_arg;
+	status = ici_pipeline_ioctl_common(up, file, ioctl_cmd,
+		ioctl_arg);
+
+	return status;
+}
+
+static long ici_pipeline_ioctl32(struct file *file,
+	unsigned int ioctl_cmd, unsigned long ioctl_arg)
+{
+	long status = 0;
+	void __user *up = compat_ptr(ioctl_arg);
+	status = ici_pipeline_ioctl_common(up, file, ioctl_cmd,
+		ioctl_arg);
+
+	return status;
+}
+
+static const struct ici_pipeline_ioctl_ops pipeline_ioctls =
+{
+	.pipeline_setup_pipe = ici_setup_link,
+	.pipeline_enum_nodes = pipeline_enum_nodes,
+	.pipeline_enum_links = pipeline_enum_links,
+	.pad_set_ffmt = ici_pipeline_set_ffmt,
+	.pad_get_ffmt = ici_pipeline_get_ffmt,
+	.pad_get_supported_format =
+		ici_pipeline_get_supported_format,
+	.pad_set_sel = ici_pipeline_set_sel,
+	.pad_get_sel = ici_pipeline_get_sel,
+
+};
+
+static const struct file_operations ici_isys_pipeline_fops =
+{
+	.owner = THIS_MODULE,
+	.open = pipeline_device_open,
+	.unlocked_ioctl = ici_pipeline_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl = ici_pipeline_ioctl32,
+#endif
+	.release = pipeline_device_release,
+};
+
+static void pipeline_device_main_release(struct device *sd)
+{
+}
+
+int pipeline_device_register(
+	struct ici_isys_pipeline_device *pipe_dev,
+	struct ici_isys *isys)
+{
+	int rval = 0;
+
+	pipeline_class =
+		class_create(THIS_MODULE,
+			ICI_PIPELINE_DEVICE_NAME);
+	if (IS_ERR(pipeline_class)) {
+		printk(KERN_WARNING "Failed to register device class %s\n",
+		       ICI_PIPELINE_DEVICE_NAME);
+		return PTR_ERR(pipeline_class);
+	}
+
+	pipe_dev->parent = &isys->adev->dev;
+	pipe_dev->minor = -1;
+
+	cdev_init(&pipe_dev->cdev, &ici_isys_pipeline_fops);
+	pipe_dev->cdev.owner = ici_isys_pipeline_fops.owner;
+
+	rval = cdev_add(&pipe_dev->cdev,
+		MKDEV(MAJOR_PIPELINE, MINOR_PIPELINE), 1);
+	if (rval) {
+		printk(KERN_ERR "%s: failed to add cdevice\n", __func__);
+		goto fail;
+	}
+
+	pipe_dev->dev.class = pipeline_class;
+	pipe_dev->dev.devt = MKDEV(MAJOR_PIPELINE, MINOR_PIPELINE);
+	pipe_dev->dev.parent = pipe_dev->parent;
+	pipe_dev->dev.release = pipeline_device_main_release;
+	dev_set_name(&pipe_dev->dev, "%s",
+		ICI_PIPELINE_DEVICE_NAME);
+	rval = device_register(&pipe_dev->dev);
+	if (rval < 0) {
+		printk(KERN_ERR "%s: device_register failed\n", __func__);
+		goto out_cdev_del;
+	}
+
+	strlcpy(pipe_dev->name, pipe_dev->dev.kobj.name,
+		sizeof(pipe_dev->name));
+	pipe_dev->minor = MINOR_PIPELINE;
+
+	DEBUGK("Device registered: %s\n", pipe_dev->name);
+	pipe_dev->pipeline_ioctl_ops = &pipeline_ioctls;
+	mutex_init(&pipe_dev->mutex);
+	INIT_LIST_HEAD(&pipe_dev->nodes);
+
+	return 0;
+
+out_cdev_del:
+	cdev_del(&pipe_dev->cdev);
+
+fail:
+	return rval;
+}
+EXPORT_SYMBOL(pipeline_device_register);
+
+void pipeline_device_unregister(
+	struct ici_isys_pipeline_device* pipe_dev)
+{
+	DEBUGK("Pipeline device unregistering...");
+	device_unregister(&pipe_dev->dev);
+	cdev_del(&pipe_dev->cdev);
+	class_destroy(pipeline_class);
+	mutex_destroy(&pipe_dev->mutex);
+}
+EXPORT_SYMBOL(pipeline_device_unregister);
+
+
+#endif /*ICI_ENABLED*/
diff --git a/drivers/media/pci/intel/ici/ici-isys-pipeline-device.h b/drivers/media/pci/intel/ici/ici-isys-pipeline-device.h
new file mode 100644
index 0000000..b218b4d
--- /dev/null
+++ b/drivers/media/pci/intel/ici/ici-isys-pipeline-device.h
@@ -0,0 +1,62 @@
+/* SPDX-License-Identifier: (BSD-3-Clause OR GPL-2.0) */
+/*
+ * Copyright (C) 2018 Intel Corporation
+ */
+
+#ifndef ICI_ISYS_PIPELINE_DEVICE_H
+#define ICI_ISYS_PIPELINE_DEVICE_H
+
+#include <linux/mutex.h>
+#include <linux/device.h>
+#include <linux/cdev.h>
+#include <linux/fs.h>
+#include <linux/list.h>
+
+struct ici_pipeline_ioctl_ops;
+struct ici_link_desc;
+struct ici_pad_supported_format_desc;
+
+struct ici_isys_pipeline_device {
+	struct cdev cdev;
+	struct device dev;
+	struct device *parent;
+	int minor;
+	char name[32];
+	struct mutex mutex;
+	const struct file_operations *fops;
+	struct list_head nodes;
+	const struct ici_pipeline_ioctl_ops *pipeline_ioctl_ops;
+	unsigned next_node_id;
+};
+
+/* Pipeline IOCTLs */
+struct ici_pipeline_ioctl_ops {
+	int (*pipeline_enum_nodes)(struct file *file, void *fh,
+			struct ici_node_desc *node_desc);
+	int (*pipeline_enum_links)(struct file *file, void *fh,
+			struct ici_links_query *links_query);
+	int (*pipeline_setup_pipe)(struct file *file, void *fh,
+			struct ici_link_desc *link);
+	int (*pad_set_ffmt)(struct file *file, void *fh,
+			struct ici_pad_framefmt* pad_ffmt);
+	int (*pad_get_ffmt)(struct file *file, void *fh,
+			struct ici_pad_framefmt* pad_ffmt);
+	int (*pad_get_supported_format)(struct file *file, void *fh,
+			struct ici_pad_supported_format_desc *format_desc);
+	int (*pad_set_sel)(struct file *file, void *fh,
+			struct ici_pad_selection* pad_sel);
+	int (*pad_get_sel)(struct file *file, void *fh,
+			struct ici_pad_selection* pad_sel);
+};
+
+int pipeline_device_register(
+			struct ici_isys_pipeline_device *pipe_dev,
+			struct ici_isys *isys);
+void pipeline_device_unregister(struct ici_isys_pipeline_device
+								*pipe_dev);
+
+#define inode_to_ici_isys_pipeline_device(inode) \
+	container_of((inode)->i_cdev,\
+	struct ici_isys_pipeline_device, cdev)
+
+#endif /*ICI_ISYS_PIPELINE_DEVICE_H */
diff --git a/drivers/media/pci/intel/ici/ici-isys-pipeline.c b/drivers/media/pci/intel/ici/ici-isys-pipeline.c
new file mode 100644
index 0000000..563a76d
--- /dev/null
+++ b/drivers/media/pci/intel/ici/ici-isys-pipeline.c
@@ -0,0 +1,174 @@
+// SPDX-License-Identifier: (BSD-3-Clause OR GPL-2.0)
+/*
+ * Copyright (C) 2018 Intel Corporation
+ */
+
+#include "./ici/ici-isys.h"
+
+#ifdef ICI_ENABLED
+
+#include "./ici/ici-isys-pipeline.h"
+
+int ici_isys_pipeline_node_init(
+	struct ici_isys *isys,
+	struct ici_isys_node *node,
+	const char* name,
+	unsigned num_pads,
+	struct node_pad *node_pads)
+{
+	unsigned int pad_id;
+
+	mutex_lock(&isys->pipeline_dev.mutex);
+	node->parent = &isys->pipeline_dev;
+	snprintf(node->name, sizeof(node->name), "%s", name);
+	if (num_pads > ICI_MAX_PADS) {
+		dev_warn(&isys->adev->dev,
+			"Too many external pads %d\n", num_pads);
+		num_pads = ICI_MAX_PADS;
+	}
+	node->nr_pads = num_pads;
+	node->node_pad = node_pads;
+	node->nr_pipes = 0;
+	node->node_id = isys->pipeline_dev.next_node_id++;
+
+	INIT_LIST_HEAD(&node->node_entry);
+	INIT_LIST_HEAD(&node->iterate_node);
+	INIT_LIST_HEAD(&node->node_pipes);
+
+	for (pad_id = 0; pad_id < num_pads; pad_id++) {
+		node->node_pad[pad_id].node = node;
+		node->node_pad[pad_id].pad_id = pad_id;
+	}
+
+	list_add_tail(&node->node_entry,
+		&node->parent->nodes);
+	dev_info(&isys->adev->dev,
+		"Setup node \"%s\" with %d pads\n",
+		node->name,
+		node->nr_pads);
+	mutex_unlock(&isys->pipeline_dev.mutex);
+	return 0;
+}
+
+void node_pads_cleanup(struct ici_isys_node *node)
+{
+	struct node_pipe *tmp, *q, *np;
+	list_for_each_entry_safe(np, q, &node->node_pipes, list_entry) {
+		tmp = np;
+		list_del(&np->list_entry);
+		kfree(tmp);
+	}
+}
+
+static struct node_pipe* node_pad_add_link(struct ici_isys_node *node)
+{
+	struct node_pipe *np;
+	np = kzalloc(sizeof(*np), GFP_KERNEL);
+	if (!np)
+		return NULL;
+
+	list_add_tail(&np->list_entry, &node->node_pipes);
+	node->nr_pipes++;
+	return np;
+}
+
+int node_pad_create_link(struct ici_isys_node *src,
+		u16 src_pad, struct ici_isys_node *sink,
+		u16 sink_pad, u32 flags )
+{
+	int rval = 0;
+	struct node_pipe *np;
+	struct node_pipe *rnp;
+	if(!src || !sink || !src->parent)
+		return -EINVAL;
+
+	mutex_lock(&src->parent->mutex);
+	np = node_pad_add_link(src);
+	if(!np) {
+		rval = -ENOMEM;
+		goto cleanup_mutex;
+	}
+
+	np->src_pad = &src->node_pad[src_pad];
+	np->sink_pad = &sink->node_pad[sink_pad];
+	np->flags = flags;
+	np->rev_pipe = NULL;
+
+	rnp = node_pad_add_link(sink);
+	if(!rnp) {
+		rval = -ENOMEM;
+		goto cleanup_mutex;
+	}
+
+	rnp->src_pad = &src->node_pad[src_pad];
+	rnp->sink_pad = &sink->node_pad[sink_pad];
+	rnp->flags = flags | ICI_LINK_FLAG_BACKLINK;
+	rnp->rev_pipe = np;
+	np->rev_pipe = rnp;
+
+cleanup_mutex:
+	mutex_unlock(&src->parent->mutex);
+	return rval;
+}
+
+static int __ici_isys_pipeline_for_each_node(
+	ici_isys_pipeline_node_cb_fn cb_fn,
+	void* cb_data,
+	struct ici_isys_node* start_node,
+	struct ici_isys_pipeline *ip_active,
+	bool backwards)
+{
+	struct node_pipe *pipe;
+	struct ici_isys_node* node;
+	struct ici_isys_node* next_node = NULL;
+	int rval;
+	LIST_HEAD(node_list);
+
+	if (!cb_fn || !start_node || !start_node->parent)
+		return -EINVAL;
+
+	rval = cb_fn(cb_data, start_node, NULL);
+	if (rval)
+		return rval;
+	list_add_tail(&start_node->iterate_node, &node_list);
+	while (!list_empty(&node_list)) {
+		node = list_entry(node_list.next,
+			struct ici_isys_node,
+			iterate_node);
+		list_del(&node->iterate_node);
+		list_for_each_entry(pipe, &node->node_pipes,
+			list_entry) {
+			if (backwards && !(pipe->flags & ICI_LINK_FLAG_BACKLINK))
+				continue;
+			else if (!backwards && (pipe->flags & ICI_LINK_FLAG_BACKLINK))
+				continue;
+			if (ip_active && !(pipe->flags & ICI_LINK_FLAG_ENABLED))
+				continue;
+			next_node = (backwards ? pipe->src_pad->node :
+				pipe->sink_pad->node);
+			rval = cb_fn(cb_data, next_node, pipe);
+			if (rval)
+				return rval;
+			list_add_tail(&next_node->iterate_node,
+				&node_list);
+		}
+	}
+	return 0;
+}
+
+int ici_isys_pipeline_for_each_node(
+	ici_isys_pipeline_node_cb_fn cb_fn,
+	void* cb_data,
+	struct ici_isys_node* start_node,
+	struct ici_isys_pipeline *ip_active,
+	bool backwards)
+{
+	int rval = 0;
+	mutex_lock(&start_node->parent->mutex);
+	rval = __ici_isys_pipeline_for_each_node(cb_fn,
+		cb_data, start_node, ip_active, backwards);
+	mutex_unlock(&start_node->parent->mutex);
+	return rval;
+}
+
+#endif /* ICI_ENABLED */
diff --git a/drivers/media/pci/intel/ici/ici-isys-pipeline.h b/drivers/media/pci/intel/ici/ici-isys-pipeline.h
new file mode 100644
index 0000000..8004d8d
--- /dev/null
+++ b/drivers/media/pci/intel/ici/ici-isys-pipeline.h
@@ -0,0 +1,98 @@
+/* SPDX-License-Identifier: (BSD-3-Clause OR GPL-2.0) */
+/*
+ * Copyright (C) 2018 Intel Corporation
+ */
+
+#ifndef ICI_ISYS_PIPELINE_H
+#define ICI_ISYS_PIPELINE_H
+
+#include <linux/mutex.h>
+#include <linux/list.h>
+#include <linux/completion.h>
+
+#include <media/ici.h>
+
+#define ICI_ISYS_OUTPUT_PINS 11
+#define ICI_NUM_CAPTURE_DONE 2
+#define ICI_ISYS_MAX_PARALLEL_SOF 2
+
+struct ici_isys_node;
+struct ici_isys_subdev;
+struct ici_isys_csi2_be;
+struct ici_isys_csi2;
+struct ici_isys_tpg;
+struct ia_css_isys_resp_info;
+struct ici_isys_pipeline;
+struct ici_isys_stream;
+struct node_pad;
+
+struct ici_sequence_info {
+	unsigned int sequence;
+	u64 timestamp;
+};
+
+struct ici_output_pin_data {
+	void (*pin_ready)(struct ici_isys_pipeline *ip,
+			  struct ia_css_isys_resp_info *info);
+	struct ici_isys_frame_buf_list *buf_list;
+};
+
+struct ici_isys_pipeline {
+	struct node_pipeline pipe;
+	struct ici_isys_pipeline_device *pipeline_dev;
+	int source;		/* SSI stream source */
+	int stream_handle;	/* stream handle for CSS API */
+	unsigned int nr_output_pins;	/* How many firmware pins? */
+	struct ici_isys_csi2_be *csi2_be;
+	struct ici_isys_csi2 *csi2;
+	struct ici_isys_subdev *asd_source;
+	int asd_source_pad_id;
+	unsigned int streaming;
+	struct completion stream_open_completion;
+	struct completion stream_close_completion;
+	struct completion stream_start_completion;
+	struct completion stream_stop_completion;
+	struct completion capture_ack_completion;
+	struct ici_isys *isys;
+
+	void (*capture_done[ICI_NUM_CAPTURE_DONE])
+	(struct ici_isys_pipeline *ip,
+	 struct ia_css_isys_resp_info *resp);
+	struct ici_output_pin_data
+			output_pins[ICI_ISYS_OUTPUT_PINS];
+	bool interlaced;
+	int error;
+	int cur_field;
+	unsigned int short_packet_source;
+	unsigned int short_packet_trace_index;
+	unsigned int vc;
+};
+
+int ici_isys_pipeline_node_init(
+	struct ici_isys *isys,
+	struct ici_isys_node *node,
+	const char* name,
+	unsigned num_pads,
+	struct node_pad *node_pads);
+
+int node_pad_create_link(struct ici_isys_node *src,
+		u16 src_pad, struct ici_isys_node *sink,
+		u16 sink_pad, u32 flags );
+
+void node_pads_cleanup(struct ici_isys_node *node);
+
+typedef int (*ici_isys_pipeline_node_cb_fn)(void* cb_data,
+	struct ici_isys_node* node,
+	struct node_pipe* pipe);
+
+int ici_isys_pipeline_for_each_node(
+	ici_isys_pipeline_node_cb_fn cb_fn,
+	void* cb_data,
+	struct ici_isys_node* start_node,
+	struct ici_isys_pipeline* ip_active,
+	bool backwards);
+
+#define ici_nodepipe_to_pipeline(__np) \
+        container_of(__np, struct ici_isys_pipeline, pipe)
+
+#endif /* ICI_ISYS_PIPELINE_H */
diff --git a/drivers/media/pci/intel/ici/ici-isys-stream-device.c b/drivers/media/pci/intel/ici/ici-isys-stream-device.c
new file mode 100644
index 0000000..9633698
--- /dev/null
+++ b/drivers/media/pci/intel/ici/ici-isys-stream-device.c
@@ -0,0 +1,397 @@
+// SPDX-License-Identifier: (BSD-3-Clause OR GPL-2.0)
+/*
+ * Copyright (C) 2018 Intel Corporation
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/uaccess.h>
+#include <linux/poll.h>
+#include <linux/compat.h>
+
+#include "./ici/ici-isys-stream-device.h"
+#include "./ici/ici-isys-pipeline-device.h"
+
+#define MAX_STREAM_DEVICES 64
+
+static dev_t ici_stream_dev_t;
+static struct class*  stream_class;
+static int stream_devices_registered = 0;
+static int stream_device_init = 0;
+
+static int ici_stream_init(void);
+static void ici_stream_exit(void);
+
+static int stream_device_open(struct inode *inode, struct file *file)
+{
+	struct ici_stream_device *strm_dev = inode_to_intel_ipu_stream_device(inode);
+	int rval = 0;
+
+	get_device(&strm_dev->dev);
+
+	file->private_data = strm_dev;
+	if (strm_dev->fops->open)
+		rval = strm_dev->fops->open(inode, file);
+
+	if (rval)
+		put_device(&strm_dev->dev);
+
+	return rval;
+}
+
+static int stream_device_release(struct inode *inode, struct file *file)
+{
+	struct ici_stream_device *strm_dev = inode_to_intel_ipu_stream_device(inode);
+	int rval = 0;
+
+	if (strm_dev->fops->release)
+		rval = strm_dev->fops->release(inode, file);
+
+	put_device(&strm_dev->dev);
+	return rval;
+}
+
+static unsigned int ici_fop_poll(struct file *file, struct poll_table_struct *poll)
+{
+	struct ici_stream_device *strm_dev = file->private_data;
+	unsigned int rval = POLLERR | POLLHUP;
+
+	if (strm_dev->fops->poll)
+		rval = strm_dev->fops->poll(file, poll);
+	else
+		return DEFAULT_POLLMASK;
+
+	return rval;
+}
+
+#ifdef CONFIG_COMPAT
+struct timeval32 {
+	__u32 tv_sec;
+	__u32 tv_usec;
+} __attribute__((__packed__));
+
+struct ici_frame_plane32 {
+	__u32 bytes_used;
+	__u32 length;
+	union {
+		compat_uptr_t userptr;
+		__s32 dmafd;
+	} mem;
+	__u32 data_offset;
+	__u32 reserved[2];
+} __attribute__((__packed__));
+
+struct ici_frame_info32 {
+	__u32 frame_type;
+	__u32 field;
+	__u32 flag;
+	__u32 frame_buf_id;
+	struct timeval32 frame_timestamp;
+	__u32 frame_sequence_id;
+	__u32 mem_type; /* _DMA or _USER_PTR */
+	struct ici_frame_plane32 frame_planes[ICI_MAX_PLANES]; /* multi-planar */
+	__u32 num_planes; /* =1 single-planar &gt; 1 multi-planar array size */
+	__u32 reserved[2];
+} __attribute__((__packed__));
+
+#define ICI_IOC_GET_BUF32 _IOWR(MAJOR_STREAM, 3, struct ici_frame_info32)
+#define ICI_IOC_PUT_BUF32 _IOWR(MAJOR_STREAM, 4, struct ici_frame_info32)
+
+static void copy_from_user_frame_info32(struct ici_frame_info *kp, struct ici_frame_info32 __user *up)
+{
+	int i;
+	compat_uptr_t userptr;
+
+	get_user(kp->frame_type, &up->frame_type);
+	get_user(kp->field, &up->field);
+	get_user(kp->flag, &up->flag);
+	get_user(kp->frame_buf_id, &up->frame_buf_id);
+	get_user(kp->frame_timestamp.tv_sec, &up->frame_timestamp.tv_sec);
+	get_user(kp->frame_timestamp.tv_usec, &up->frame_timestamp.tv_usec);
+	get_user(kp->frame_sequence_id, &up->frame_sequence_id);
+	get_user(kp->mem_type, &up->mem_type);
+	get_user(kp->num_planes, &up->num_planes);
+	for (i=0; i<kp->num_planes; i++) {
+		get_user(kp->frame_planes[i].bytes_used, &up->frame_planes[i].bytes_used);
+		get_user(kp->frame_planes[i].length, &up->frame_planes[i].length);
+		if(kp->mem_type==ICI_MEM_USERPTR) {
+			get_user(userptr, &up->frame_planes[i].mem.userptr);
+			kp->frame_planes[i].mem.userptr = (unsigned long) compat_ptr(userptr);
+		} else if (kp->mem_type==ICI_MEM_DMABUF) {
+			get_user(kp->frame_planes[i].mem.dmafd, &up->frame_planes[i].mem.dmafd);
+		};
+		get_user(kp->frame_planes[i].data_offset, &up->frame_planes[i].data_offset);
+	}
+}
+
+static void copy_to_user_frame_info32(struct ici_frame_info *kp, struct ici_frame_info32 __user *up)
+{
+	int i;
+	compat_uptr_t userptr;
+
+	put_user(kp->frame_type, &up->frame_type);
+	put_user(kp->field, &up->field);
+	put_user(kp->flag, &up->flag);
+	put_user(kp->frame_buf_id, &up->frame_buf_id);
+	put_user(kp->frame_timestamp.tv_sec, &up->frame_timestamp.tv_sec);
+	put_user(kp->frame_timestamp.tv_usec, &up->frame_timestamp.tv_usec);
+	put_user(kp->frame_sequence_id, &up->frame_sequence_id);
+	put_user(kp->mem_type, &up->mem_type);
+	put_user(kp->num_planes, &up->num_planes);
+	for (i=0; i<kp->num_planes; i++) {
+		put_user(kp->frame_planes[i].bytes_used, &up->frame_planes[i].bytes_used);
+		put_user(kp->frame_planes[i].length, &up->frame_planes[i].length);
+		if(kp->mem_type==ICI_MEM_USERPTR) {
+			userptr = (unsigned long)compat_ptr(kp->frame_planes[i].mem.userptr);
+			put_user(userptr, &up->frame_planes[i].mem.userptr);
+		} else if (kp->mem_type==ICI_MEM_DMABUF) {
+			get_user(kp->frame_planes[i].mem.dmafd, &up->frame_planes[i].mem.dmafd);
+		}
+		put_user(kp->frame_planes[i].data_offset, &up->frame_planes[i].data_offset);
+	}
+}
+
+static long ici_stream_ioctl32(struct file *file, __u32 ioctl_cmd,
+			       unsigned long ioctl_arg) {
+	union {
+		struct ici_frame_info frame_info;
+		struct ici_stream_format sf;
+	} isys_ioctl_cmd_args;
+
+	int err = 0;
+	struct ici_stream_device *strm_dev = file->private_data;
+	void __user *up = compat_ptr(ioctl_arg);
+
+	mutex_lock(strm_dev->mutex);
+
+	switch(ioctl_cmd) {
+	case ICI_IOC_STREAM_ON:
+		err = strm_dev->ipu_ioctl_ops->ici_stream_on(file, strm_dev);
+		break;
+	case ICI_IOC_STREAM_OFF:
+		err = strm_dev->ipu_ioctl_ops->ici_stream_off(file, strm_dev);
+		break;
+	case ICI_IOC_GET_BUF32:
+		copy_from_user_frame_info32(&isys_ioctl_cmd_args.frame_info, up);
+		err = strm_dev->ipu_ioctl_ops->ici_get_buf(file, strm_dev, &isys_ioctl_cmd_args.frame_info);
+		if (err)
+			break;
+		copy_to_user_frame_info32(&isys_ioctl_cmd_args.frame_info, up);
+		break;
+	case ICI_IOC_PUT_BUF32:
+		copy_from_user_frame_info32(&isys_ioctl_cmd_args.frame_info, up);
+		err = strm_dev->ipu_ioctl_ops->ici_put_buf(file, strm_dev, &isys_ioctl_cmd_args.frame_info);
+		if (err)
+			break;
+		copy_to_user_frame_info32(&isys_ioctl_cmd_args.frame_info, up);
+		break;
+	case ICI_IOC_SET_FORMAT:
+		if (_IOC_SIZE(ioctl_cmd) > sizeof(isys_ioctl_cmd_args))
+			return -ENOTTY;
+
+		err = copy_from_user(&isys_ioctl_cmd_args, up,
+			_IOC_SIZE(ioctl_cmd));
+		if (err)
+			return -EFAULT;
+
+		err = strm_dev->ipu_ioctl_ops->ici_set_format(file, strm_dev, &isys_ioctl_cmd_args.sf);
+		if (err)
+			break;
+
+		err = copy_to_user(up, &isys_ioctl_cmd_args, _IOC_SIZE(ioctl_cmd));
+		if (err) {
+			return -EFAULT;
+		}
+		break;
+	default:
+		err = -ENOTTY;
+		break;
+	}
+
+	mutex_unlock(strm_dev->mutex);
+	if (err) {
+		return err;
+	}
+
+	return 0;
+}
+#endif
+
+static long ici_stream_ioctl(struct file *file, unsigned int ioctl_cmd,
+			       unsigned long ioctl_arg) {
+	union {
+		struct ici_frame_info frame_info;
+		struct ici_stream_format sf;
+	} isys_ioctl_cmd_args;
+	int err = 0;
+	struct ici_stream_device *strm_dev = file->private_data;
+	void __user *up = (void __user *)ioctl_arg;
+
+	bool copy = (ioctl_cmd != ICI_IOC_STREAM_ON &&
+			ioctl_cmd != ICI_IOC_STREAM_OFF);
+
+	if (copy) {
+		if (_IOC_SIZE(ioctl_cmd) > sizeof(isys_ioctl_cmd_args))
+			return -ENOTTY;
+
+		if (_IOC_DIR(ioctl_cmd) & _IOC_WRITE) {
+			err = copy_from_user(&isys_ioctl_cmd_args, up,
+				_IOC_SIZE(ioctl_cmd));
+			if (err)
+				return -EFAULT;
+		}
+	}
+
+	mutex_lock(strm_dev->mutex);
+
+	switch(ioctl_cmd) {
+	case ICI_IOC_STREAM_ON:
+		err = strm_dev->ipu_ioctl_ops->ici_stream_on(file, strm_dev);
+		break;
+	case ICI_IOC_STREAM_OFF:
+		err = strm_dev->ipu_ioctl_ops->ici_stream_off(file, strm_dev);
+		break;
+	case ICI_IOC_GET_BUF:
+		err = strm_dev->ipu_ioctl_ops->ici_get_buf(file, strm_dev, &isys_ioctl_cmd_args.frame_info);
+		break;
+	case ICI_IOC_PUT_BUF:
+		err = strm_dev->ipu_ioctl_ops->ici_put_buf(file, strm_dev, &isys_ioctl_cmd_args.frame_info);
+		break;
+	case ICI_IOC_SET_FORMAT:
+		err = strm_dev->ipu_ioctl_ops->ici_set_format(file, strm_dev, &isys_ioctl_cmd_args.sf);
+		break;
+	default:
+		err = -ENOTTY;
+		break;
+	}
+
+	mutex_unlock(strm_dev->mutex);
+	if (err)
+		return err;
+
+	if (copy && _IOC_DIR(ioctl_cmd) & _IOC_READ) {
+		err = copy_to_user(up, &isys_ioctl_cmd_args, _IOC_SIZE(ioctl_cmd));
+		if (err)
+			return -EFAULT;
+	}
+
+	return 0;
+}
+
+static const struct file_operations ici_stream_fops = {
+	.owner = THIS_MODULE,
+	.open = stream_device_open,			/* calls strm_dev->fops->open() */
+	.unlocked_ioctl = ici_stream_ioctl,	/* calls strm_dev->ipu_ioctl_ops->() */
+#ifdef CONFIG_COMPAT
+	.compat_ioctl = ici_stream_ioctl32,
+#endif
+	.release = stream_device_release,		/* calls strm_dev->fops->release() */
+	.poll = ici_fop_poll,		/* calls strm_dev->fops->poll() */
+};
+
+/* Called on device_unregister */
+static void base_device_release(struct device *sd)
+{
+}
+
+int stream_device_register(struct ici_stream_device *strm_dev)
+{
+	int rval = 0;
+	int num;
+
+	if (!stream_device_init) {
+		rval = ici_stream_init();
+		if (rval) {
+			printk(KERN_ERR "%s: failed to init stream device\n", __func__);
+			return rval;
+		}
+		stream_device_init++;
+	}
+	num = stream_devices_registered;
+
+	if (!(num < MAX_STREAM_DEVICES)) {
+		printk(KERN_WARNING "%s: wrong minor of stream device: %d\n",
+			__func__, num);
+		return -EINVAL;
+	}
+	strm_dev->minor = -1;
+
+	cdev_init(&strm_dev->cdev, &ici_stream_fops);
+	strm_dev->cdev.owner = ici_stream_fops.owner;
+
+	rval = cdev_add(&strm_dev->cdev, MKDEV(MAJOR(ici_stream_dev_t), num), 1);
+	if (rval) {
+		printk(KERN_WARNING "%s: failed to add cdevice\n", __func__);
+		return rval;
+	}
+
+	strm_dev->dev.class = stream_class;
+	strm_dev->dev.devt = MKDEV(MAJOR(ici_stream_dev_t), num);
+	strm_dev->dev.parent = strm_dev->dev_parent;
+	dev_set_name(&strm_dev->dev, "%s%d", ICI_STREAM_DEVICE_NAME, num);
+	rval = device_register(&strm_dev->dev);
+	if (rval < 0) {
+		printk(KERN_WARNING "%s: device_register failed\n", __func__);
+		cdev_del(&strm_dev->cdev);
+		return rval;
+	}
+
+	/* Release function will be called on device unregister,
+	   it is needed to avoid errors */
+	strm_dev->dev.release = base_device_release;
+	strlcpy(strm_dev->name, strm_dev->dev.kobj.name, sizeof(strm_dev->name));
+	strm_dev->minor = num;
+
+	printk(KERN_INFO "Device registered: %s\n", strm_dev->name);
+	stream_devices_registered++;
+
+	return 0;
+}
+
+void stream_device_unregister(struct ici_stream_device *strm_dev)
+{
+	device_unregister(&strm_dev->dev);
+	cdev_del(&strm_dev->cdev);
+
+	stream_devices_registered--;
+        if (!stream_devices_registered) {
+                ici_stream_exit();
+                stream_device_init--;
+        }
+}
+
+static int ici_stream_init(void)
+{
+	int rval;
+	ici_stream_dev_t = MKDEV(MAJOR_STREAM, 0);
+
+	rval = register_chrdev_region(ici_stream_dev_t,
+				MAX_STREAM_DEVICES, ICI_STREAM_DEVICE_NAME);
+	if (rval) {
+		printk(KERN_WARNING "can't register intel_ipu_ici stream chrdev region (%d)\n", rval);
+		return rval;
+	}
+
+	stream_class = class_create(THIS_MODULE, ICI_STREAM_DEVICE_NAME);
+	if (IS_ERR(stream_class)) {
+		unregister_chrdev_region(ici_stream_dev_t, MAX_STREAM_DEVICES);
+		printk(KERN_WARNING "Failed to register device class %s\n", ICI_STREAM_DEVICE_NAME);
+		return PTR_ERR(stream_class);
+	}
+
+	return 0;
+}
+
+static void ici_stream_exit(void)
+{
+	class_unregister(stream_class);
+	//class_destroy(stream_class);
+	unregister_chrdev_region(ici_stream_dev_t, MAX_STREAM_DEVICES);
+
+	printk(KERN_INFO "intel_ipu_ici stream device unregistered\n");
+}
+
diff --git a/drivers/media/pci/intel/ici/ici-isys-stream-device.h b/drivers/media/pci/intel/ici/ici-isys-stream-device.h
new file mode 100644
index 0000000..5aec894
--- /dev/null
+++ b/drivers/media/pci/intel/ici/ici-isys-stream-device.h
@@ -0,0 +1,58 @@
+/* SPDX-License-Identifier: (BSD-3-Clause OR GPL-2.0) */
+/*
+ * Copyright (C) 2018 Intel Corporation
+ */
+
+#ifndef ICI_ISYS_STREAM_DEVICE_H
+#define ICI_ISYS_STREAM_DEVICE_H
+
+#include <linux/ioctl.h>
+#include <linux/device.h>
+#include <linux/cdev.h>
+#include <linux/mutex.h>
+#include <media/ici.h>
+
+#include "ici-isys-frame-buf.h"
+#include "ici-isys-pipeline.h"
+#include "virtio/intel-ipu4-virtio-common.h"
+
+struct ici_ioctl_ops;
+struct ici_frame_plane;
+
+struct ici_stream_device {
+	struct device dev;		/* intel stream base dev */
+	struct cdev cdev;		/* character device */
+	struct device *dev_parent;	/* parent device ipu_bus */
+	struct mutex *mutex;
+	const struct file_operations *fops; /* standard Linux fops */
+	struct ici_isys_frame_buf_list *frame_buf_list;	/* frame buffer wrapper pointer */
+	char name[32];			/* device name */
+	int minor;			/* driver minor */
+	unsigned long flags;		/* stream device state machine */
+	const struct ici_ioctl_ops *ipu_ioctl_ops;
+	//Mediator param
+	int virt_dev_id;
+	struct ipu4_virtio_priv *virt_priv;
+};
+
+struct ici_ioctl_ops {
+	int (*ici_set_format) (struct file *file, void *fh,
+		struct ici_stream_format *psf);
+	int (*ici_stream_on)	(struct file *file, void *fh);
+	int (*ici_stream_off) (struct file *file, void *fh);
+	int (*ici_get_buf) (struct file *file, void *fh,
+		struct ici_frame_info *fram);
+	int (*ici_get_buf_virt) (struct file *file, void *fh,
+		struct ici_frame_buf_wrapper *fram, struct page **pages);
+	int (*ici_put_buf) (struct file *file, void *fh,
+		struct ici_frame_info *fram);
+};
+
+#define inode_to_intel_ipu_stream_device(inode) \
+	container_of((inode)->i_cdev, struct ici_stream_device, cdev)
+
+int stream_device_register(struct ici_stream_device *strm_dev);
+
+void stream_device_unregister(struct ici_stream_device *strm_dev);
+
+#endif /* ICI_ISYS_STREAM_DEVICE_H */
diff --git a/drivers/media/pci/intel/ici/ici-isys-stream.c b/drivers/media/pci/intel/ici/ici-isys-stream.c
new file mode 100644
index 0000000..6a2c6e1
--- /dev/null
+++ b/drivers/media/pci/intel/ici/ici-isys-stream.c
@@ -0,0 +1,1450 @@
+// SPDX-License-Identifier: (BSD-3-Clause OR GPL-2.0)
+/*
+ * Copyright (C) 2018 Intel Corporation
+ */
+
+#include "./ici/ici-isys.h"
+#ifdef ICI_ENABLED
+
+#include <linux/delay.h>
+#include <linux/pm_runtime.h>
+#include <linux/kthread.h>
+#include <linux/poll.h>
+#include <linux/sched/types.h>
+#include "isysapi/interface/ia_css_isysapi_fw_types.h"
+#include "isysapi/interface/ia_css_isysapi.h"
+#include <ia_css_pkg_dir.h>
+#include <ia_css_pkg_dir_iunit.h>
+#include <ia_css_pkg_dir_types.h>
+#include "ipu-trace.h"
+#include "ipu-fw-isys.h"
+#include "ici-fw-isys.h"
+#include "ipu-wrapper.h"
+#include "./ici/ici-isys-stream.h"
+#include "./ici/ici-isys-csi2.h"
+#include "./ici/ici-isys-csi2-be.h"
+#include <media/ici.h>
+
+#ifndef IPU4_DEBUG
+#define IPU4_DEBUG 1
+#endif
+
+#define dev_to_stream(dev) \
+	container_of(dev, struct ici_isys_stream, strm_dev)
+
+const struct ici_isys_pixelformat ici_isys_pfmts[] = {
+	/* YUV vector format */
+	{ ICI_FORMAT_YUYV, 24, 24, ICI_FORMAT_YUYV, IA_CSS_ISYS_FRAME_FORMAT_YUV420_16 },
+	/* Raw bayer vector formats. */
+	{ ICI_FORMAT_SBGGR12, 16, 12, ICI_FORMAT_SBGGR12, IA_CSS_ISYS_FRAME_FORMAT_RAW16 },
+	{ ICI_FORMAT_SGBRG12, 16, 12, ICI_FORMAT_SGBRG12, IA_CSS_ISYS_FRAME_FORMAT_RAW16 },
+	{ ICI_FORMAT_SGRBG12, 16, 12, ICI_FORMAT_SGRBG12, IA_CSS_ISYS_FRAME_FORMAT_RAW16 },
+	{ ICI_FORMAT_SRGGB12, 16, 12, ICI_FORMAT_SRGGB12, IA_CSS_ISYS_FRAME_FORMAT_RAW16 },
+	{ ICI_FORMAT_SBGGR10, 16, 10, ICI_FORMAT_SBGGR10, IA_CSS_ISYS_FRAME_FORMAT_RAW16 },
+	{ ICI_FORMAT_SGBRG10, 16, 10, ICI_FORMAT_SGBRG10, IA_CSS_ISYS_FRAME_FORMAT_RAW16 },
+	{ ICI_FORMAT_SGRBG10, 16, 10, ICI_FORMAT_SGRBG10, IA_CSS_ISYS_FRAME_FORMAT_RAW16 },
+	{ ICI_FORMAT_SRGGB10, 16, 10, ICI_FORMAT_SRGGB10, IA_CSS_ISYS_FRAME_FORMAT_RAW16 },
+	{ ICI_FORMAT_SBGGR8, 16, 8, ICI_FORMAT_SBGGR8, IA_CSS_ISYS_FRAME_FORMAT_RAW16 },
+	{ ICI_FORMAT_SGBRG8, 16, 8, ICI_FORMAT_SGBRG8, IA_CSS_ISYS_FRAME_FORMAT_RAW16 },
+	{ ICI_FORMAT_SGRBG8, 16, 8, ICI_FORMAT_SGRBG8, IA_CSS_ISYS_FRAME_FORMAT_RAW16 },
+	{ ICI_FORMAT_SRGGB8, 16, 8, ICI_FORMAT_SRGGB8, IA_CSS_ISYS_FRAME_FORMAT_RAW16 },
+	/*{ V4L2_FMT_INTEL_IPU4_ISYS_META, 8, 8, MEDIA_BUS_FMT_FIXED, IA_CSS_ISYS_MIPI_DATA_TYPE_EMBEDDED },*/
+	{ }
+};
+
+const struct ici_isys_pixelformat ici_isys_pfmts_be_soc[] = {
+	{ ICI_FORMAT_UYVY, 16, 16, ICI_FORMAT_UYVY, IA_CSS_ISYS_FRAME_FORMAT_UYVY },
+	{ ICI_FORMAT_YUYV, 16, 16, ICI_FORMAT_YUYV, IA_CSS_ISYS_FRAME_FORMAT_YUYV },
+	{ ICI_FORMAT_RGB565, 32, 32, ICI_FORMAT_RGB565, IA_CSS_ISYS_FRAME_FORMAT_RGBA888 },
+	{ ICI_FORMAT_RGB888, 32, 32, ICI_FORMAT_RGB888, IA_CSS_ISYS_FRAME_FORMAT_RGBA888 },
+	/* Raw bayer formats. */
+	{ ICI_FORMAT_SBGGR12, 16, 12, ICI_FORMAT_SBGGR12, IA_CSS_ISYS_FRAME_FORMAT_RAW16 },
+	{ ICI_FORMAT_SGBRG12, 16, 12, ICI_FORMAT_SGBRG12, IA_CSS_ISYS_FRAME_FORMAT_RAW16 },
+	{ ICI_FORMAT_SGRBG12, 16, 12, ICI_FORMAT_SGRBG12, IA_CSS_ISYS_FRAME_FORMAT_RAW16 },
+	{ ICI_FORMAT_SRGGB12, 16, 12, ICI_FORMAT_SRGGB12, IA_CSS_ISYS_FRAME_FORMAT_RAW16 },
+	{ ICI_FORMAT_SBGGR10, 16, 10, ICI_FORMAT_SBGGR10, IA_CSS_ISYS_FRAME_FORMAT_RAW16 },
+	{ ICI_FORMAT_SGBRG10, 16, 10, ICI_FORMAT_SGBRG10, IA_CSS_ISYS_FRAME_FORMAT_RAW16 },
+	{ ICI_FORMAT_SGRBG10, 16, 10, ICI_FORMAT_SGRBG10, IA_CSS_ISYS_FRAME_FORMAT_RAW16 },
+	{ ICI_FORMAT_SRGGB10, 16, 10, ICI_FORMAT_SRGGB10, IA_CSS_ISYS_FRAME_FORMAT_RAW16 },
+	{ ICI_FORMAT_SBGGR8, 8, 8, ICI_FORMAT_SBGGR8, IA_CSS_ISYS_FRAME_FORMAT_RAW8 },
+	{ ICI_FORMAT_SGBRG8, 8, 8, ICI_FORMAT_SGBRG8, IA_CSS_ISYS_FRAME_FORMAT_RAW8 },
+	{ ICI_FORMAT_SGRBG8, 8, 8, ICI_FORMAT_SGRBG8, IA_CSS_ISYS_FRAME_FORMAT_RAW8 },
+	{ ICI_FORMAT_SRGGB8, 8, 8, ICI_FORMAT_SRGGB8, IA_CSS_ISYS_FRAME_FORMAT_RAW8 },
+	{ }
+};
+
+const struct ici_isys_pixelformat ici_isys_pfmts_packed[] = {
+        { ICI_FORMAT_UYVY, 16, 16, ICI_FORMAT_UYVY, IA_CSS_ISYS_FRAME_FORMAT_UYVY },
+        { ICI_FORMAT_YUYV, 16, 16, ICI_FORMAT_YUYV, IA_CSS_ISYS_FRAME_FORMAT_YUYV },
+        { ICI_FORMAT_RGB565, 16, 16, ICI_FORMAT_RGB565, IA_CSS_ISYS_FRAME_FORMAT_RGB565 },
+        { ICI_FORMAT_RGB888, 24, 24, ICI_FORMAT_RGB888, IA_CSS_ISYS_FRAME_FORMAT_RGBA888 },
+        { ICI_FORMAT_SBGGR12, 12, 12, ICI_FORMAT_SBGGR12, IA_CSS_ISYS_FRAME_FORMAT_RAW12 },
+        { ICI_FORMAT_SGBRG12, 12, 12, ICI_FORMAT_SGBRG12, IA_CSS_ISYS_FRAME_FORMAT_RAW12 },
+        { ICI_FORMAT_SGRBG12, 12, 12, ICI_FORMAT_SGRBG12, IA_CSS_ISYS_FRAME_FORMAT_RAW12 },
+        { ICI_FORMAT_SRGGB12, 12, 12, ICI_FORMAT_SRGGB12, IA_CSS_ISYS_FRAME_FORMAT_RAW12 },
+        { ICI_FORMAT_SBGGR10, 10, 10, ICI_FORMAT_SBGGR10, IA_CSS_ISYS_FRAME_FORMAT_RAW10 },
+        { ICI_FORMAT_SGBRG10, 10, 10, ICI_FORMAT_SGBRG10, IA_CSS_ISYS_FRAME_FORMAT_RAW10 },
+        { ICI_FORMAT_SGRBG10, 10, 10, ICI_FORMAT_SGRBG10, IA_CSS_ISYS_FRAME_FORMAT_RAW10 },
+        { ICI_FORMAT_SRGGB10, 10, 10, ICI_FORMAT_SRGGB10, IA_CSS_ISYS_FRAME_FORMAT_RAW10 },
+        { ICI_FORMAT_SBGGR8, 8, 8, ICI_FORMAT_SBGGR8, IA_CSS_ISYS_FRAME_FORMAT_RAW8 },
+        { ICI_FORMAT_SGBRG8, 8, 8, ICI_FORMAT_SGBRG8, IA_CSS_ISYS_FRAME_FORMAT_RAW8 },
+        { ICI_FORMAT_SGRBG8, 8, 8, ICI_FORMAT_SGRBG8, IA_CSS_ISYS_FRAME_FORMAT_RAW8 },
+        { ICI_FORMAT_SRGGB8, 8, 8, ICI_FORMAT_SRGGB8, IA_CSS_ISYS_FRAME_FORMAT_RAW8 },
+        { }
+};
+
+struct pipeline_format_data {
+	struct ici_isys_stream *as;
+	struct ici_pad_framefmt pff;
+};
+
+struct pipeline_power_data {
+	struct ici_isys_stream *as;
+	int power;
+};
+
+static int pipeline_set_node_power(void* cb_data,
+	struct ici_isys_node* node,
+	struct node_pipe* pipe)
+{
+	struct pipeline_power_data* pwr_data = cb_data;
+	struct ici_isys_stream *as = pwr_data->as;
+	dev_info(&as->isys->adev->dev,
+		"Set ext sd \"%s\" power to %d\n",
+		node->name, pwr_data->power);
+	if (node->node_set_power) {
+		int ret = node->node_set_power(node, pwr_data->power);
+		if (ret < 0)
+			return ret;
+	}
+	return 0;
+}
+
+static int pipeline_set_power(struct ici_isys_stream *as,
+	int state)
+{
+	struct pipeline_power_data pwr_data = {
+		.as = as,
+		.power = state,
+	};
+
+	return ici_isys_pipeline_for_each_node(
+			pipeline_set_node_power,
+			&pwr_data,
+			&as->node,
+			&as->ip,
+			true);
+}
+
+static int intel_ipu4_isys_library_close(struct ici_isys *isys)
+{
+	struct device *dev = &isys->adev->dev;
+	int timeout = IPU_ISYS_TURNOFF_TIMEOUT;
+	int rval;
+
+	/*
+	 * Ask library to stop the isys fw. Actual close takes
+	 * some time as the FW must stop its actions including code fetch
+	 * to SP icache.
+	*/
+	rval = ipu_lib_call(device_close, isys);
+	if (rval)
+		dev_err(dev, "Device close failure: %d\n", rval);
+
+	/* release probably fails if the close failed. Let's try still */
+	do {
+		usleep_range(IPU_ISYS_TURNOFF_DELAY_US,
+			2 * IPU_ISYS_TURNOFF_DELAY_US);
+		rval = ipu_lib_call_notrace(device_release, isys, 0);
+		timeout--;
+	} while (rval != 0 && timeout);
+
+	if (!rval)
+		isys->fwcom = NULL; /* No further actions needed */
+	else
+		dev_err(dev, "Device release time out %d\n", rval);
+	return rval;
+}
+
+static unsigned int get_comp_format(u32 code)
+{
+	unsigned int predictor = 0; /* currently hard coded */
+	unsigned int udt = ici_isys_format_code_to_mipi(code);
+	unsigned int scheme = ici_isys_get_compression_scheme(code);
+
+	/* if data type is not user defined return here */
+	if ((udt < ICI_ISYS_MIPI_CSI2_TYPE_USER_DEF(1))
+		 || (udt > ICI_ISYS_MIPI_CSI2_TYPE_USER_DEF(8)))
+		return 0;
+
+	/*
+	 * For each user defined type (1..8) there is configuration bitfield for
+	 * decompression.
+	 *
+	 * | bit 3     | bits 2:0 |
+	 * | predictor | scheme   |
+	 * compression schemes:
+	 * 000 = no compression
+	 * 001 = 10 - 6 - 10
+	 * 010 = 10 - 7 - 10
+	 * 011 = 10 - 8 - 10
+	 * 100 = 12 - 6 - 12
+	 * 101 = 12 - 7 - 12
+	 * 110 = 12 - 8 - 12
+	 */
+
+	return ((predictor << 3) | scheme) <<
+		 ((udt - ICI_ISYS_MIPI_CSI2_TYPE_USER_DEF(1)) * 4);
+}
+
+static void csi_short_packet_prepare_firmware_stream_cfg_ici(
+	struct ici_isys_pipeline *ip,
+	struct ia_css_isys_stream_cfg_data *cfg)
+{
+	struct ici_isys_stream *as =
+		ici_pipeline_to_stream(ip);
+	struct ici_isys_frame_buf_list *buf_list =
+		&as->buf_list;
+	int input_pin = cfg->nof_input_pins++;
+	int output_pin = cfg->nof_output_pins++;
+	struct ia_css_isys_input_pin_info *input_info =
+		&cfg->input_pins[input_pin];
+	struct ia_css_isys_output_pin_info *output_info =
+		&cfg->output_pins[output_pin];
+
+	/*
+	 * Setting dt as ICI_ISYS_SHORT_PACKET_GENERAL_DT will cause
+	 * MIPI receiver to receive all MIPI short packets.
+	 */
+	input_info->dt = ICI_ISYS_SHORT_PACKET_GENERAL_DT;
+	input_info->input_res.width = ICI_ISYS_SHORT_PACKET_WIDTH;
+	input_info->input_res.height = buf_list->num_short_packet_lines;
+
+	ip->output_pins[output_pin].pin_ready =
+		ici_isys_frame_short_packet_ready;
+	ip->output_pins[output_pin].buf_list = buf_list;
+	buf_list->short_packet_output_pin = output_pin;
+
+	output_info->input_pin_id = input_pin;
+	output_info->output_res.width = ICI_ISYS_SHORT_PACKET_WIDTH;
+	output_info->output_res.height = buf_list->num_short_packet_lines;
+	output_info->stride = ICI_ISYS_SHORT_PACKET_WIDTH *
+			      ICI_ISYS_SHORT_PACKET_UNITSIZE;
+	output_info->pt = ICI_ISYS_SHORT_PACKET_PT;
+	output_info->ft = ICI_ISYS_SHORT_PACKET_FT;
+	output_info->send_irq = 1;
+}
+
+static int csi_short_packet_configure_tunit(
+    struct ici_isys_pipeline *ip,
+    bool enable)
+{
+	struct ici_isys *isys = ip->isys;
+	void __iomem *isys_base = isys->pdata->base;
+	void __iomem *tunit_base = isys_base + TRACE_REG_IS_TRACE_UNIT_BASE;
+	void __iomem *csi2_tm_base;
+	void __iomem *event_mask_reg;
+	unsigned int trace_addr;
+	int rval;
+	int i;
+
+	if (ip->csi2->index >= IPU_ISYS_MAX_CSI2_LEGACY_PORTS) {
+		csi2_tm_base = isys->pdata->base + TRACE_REG_CSI2_3PH_TM_BASE;
+		trace_addr = TRACE_REG_CSI2_3PH_TM_TRACE_ADDRESS_VAL;
+		event_mask_reg = csi2_tm_base +
+			TRACE_REG_CSI2_3PH_TM_TRACE_DDR_EN_REG_IDX_P(
+			ip->csi2->index);
+	} else {
+		csi2_tm_base = isys->pdata->base + TRACE_REG_CSI2_TM_BASE;
+		trace_addr = TRACE_REG_CSI2_TM_TRACE_ADDRESS_VAL;
+		event_mask_reg = csi2_tm_base +
+			TRACE_REG_CSI2_TM_TRACE_DDR_EN_REG_IDX_P(
+			ip->csi2->index);
+	}
+
+	if (!enable) {
+		writel(0, event_mask_reg);
+		writel(0, csi2_tm_base +
+			TRACE_REG_CSI2_TM_OVERALL_ENABLE_REG_IDX);
+		writel(0, tunit_base + TRACE_REG_TUN_DDR_ENABLE);
+		return 0;
+	}
+
+	/* ring buffer base */
+	writel(isys->short_packet_trace_buffer_dma_addr,
+        tunit_base + TRACE_REG_TUN_DRAM_BASE_ADDR);
+
+	/* ring buffer end */
+	writel(isys->short_packet_trace_buffer_dma_addr +
+        IPU_ISYS_SHORT_PACKET_TRACE_BUFFER_SIZE -
+        IPU_ISYS_SHORT_PACKET_TRACE_MSG_SIZE,
+        tunit_base + TRACE_REG_TUN_DRAM_END_ADDR);
+
+	/* Infobits for ddr trace */
+	writel(IPU_INFO_REQUEST_DESTINATION_PRIMARY,
+        tunit_base + TRACE_REG_TUN_DDR_INFO_VAL);
+
+	/* Remove reset from trace timers */
+	writel(TRACE_REG_GPREG_TRACE_TIMER_RST_OFF,
+		isys_base + TRACE_REG_IS_GPREG_TRACE_TIMER_RST_N);
+
+	/* Reset CSI2 monitor */
+	writel(1, csi2_tm_base + TRACE_REG_CSI2_TM_RESET_REG_IDX);
+
+	/* Set trace address register. */
+	writel(trace_addr, csi2_tm_base +
+		TRACE_REG_CSI2_TM_TRACE_ADDRESS_REG_IDX);
+	writel(TRACE_REG_CSI2_TM_TRACE_HEADER_VAL, csi2_tm_base +
+		TRACE_REG_CSI2_TM_TRACE_HEADER_REG_IDX);
+
+	/* Enable DDR trace. */
+	writel(1, tunit_base + TRACE_REG_TUN_DDR_ENABLE);
+
+	/* Enable trace for CSI2 port. */
+#if 0
+	reg_val = readl(event_mask_reg);
+	reg_val |= TRACE_REG_CSI2_TM_EVENT_FS(ip->vc);
+	writel(reg_val, event_mask_reg);
+#else
+	for (i = 0; i < IPU_ISYS_MAX_CSI2_LEGACY_PORTS +
+	     IPU_ISYS_MAX_CSI2_COMBO_PORTS; i++) {
+		void __iomem *event_mask_reg =
+			(i < IPU_ISYS_MAX_CSI2_LEGACY_PORTS) ?
+			isys->pdata->base + TRACE_REG_CSI2_TM_BASE +
+			TRACE_REG_CSI2_TM_TRACE_DDR_EN_REG_IDX_P(i) :
+			isys->pdata->base + TRACE_REG_CSI2_3PH_TM_BASE +
+			TRACE_REG_CSI2_3PH_TM_TRACE_DDR_EN_REG_IDX_P(i);
+
+		writel(IPU_ISYS_SHORT_PACKET_TRACE_EVENT_MASK,
+			event_mask_reg);
+	}
+#endif
+	/* Enable CSI2 receiver monitor */
+	writel(1, csi2_tm_base + TRACE_REG_CSI2_TM_OVERALL_ENABLE_REG_IDX);
+
+	rval = ipu_buttress_tsc_read(isys->adev->isp,
+		&isys->tsc_timer_base);
+	if (rval) {
+		dev_err(&isys->adev->dev,
+			"Failed to read TSC timer.\n");
+		return rval;
+	}
+	rval = ipu_trace_get_timer(&isys->adev->dev,
+		&isys->tunit_timer_base);
+	if (rval) {
+		dev_err(&isys->adev->dev,
+			"Failed to read Tunit timer.\n");
+		return rval;
+	}
+
+	return 0;
+}
+
+static void get_stream_opened(struct ici_isys_stream *as)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&as->isys->lock, flags);
+	as->isys->stream_opened++;
+	spin_unlock_irqrestore(&as->isys->lock, flags);
+}
+
+static void put_stream_opened(struct ici_isys_stream *as)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&as->isys->lock, flags);
+	as->isys->stream_opened--;
+	spin_unlock_irqrestore(&as->isys->lock, flags);
+}
+
+static int get_stream_handle(struct ici_isys_stream *as)
+{
+	struct ici_isys_pipeline *ip = &as->ip;
+	unsigned int stream_handle;
+	unsigned long flags;
+
+	spin_lock_irqsave(&as->isys->lock, flags);
+	for (stream_handle = 0;
+		stream_handle < INTEL_IPU4_ISYS_MAX_STREAMS; stream_handle++)
+		if (as->isys->ici_pipes[stream_handle] == NULL)
+			break;
+	if (stream_handle == INTEL_IPU4_ISYS_MAX_STREAMS) {
+		spin_unlock_irqrestore(&as->isys->lock, flags);
+		return -EBUSY;
+	}
+	as->isys->ici_pipes[stream_handle] = ip;
+	ip->stream_handle = stream_handle;
+	spin_unlock_irqrestore(&as->isys->lock, flags);
+	return 0;
+}
+
+static void put_stream_handle(struct ici_isys_stream *as)
+{
+	struct ici_isys_pipeline *ip = &as->ip;
+	unsigned long flags;
+
+	spin_lock_irqsave(&as->isys->lock, flags);
+	as->isys->ici_pipes[ip->stream_handle] = NULL;
+	ip->stream_handle = -1;
+	spin_unlock_irqrestore(&as->isys->lock, flags);
+}
+
+/* Create stream and start it using the CSS library API. */
+static int start_stream_firmware(struct ici_isys_stream *as)
+{
+	struct ici_isys_pipeline *ip = &as->ip;
+	struct device *dev = &as->isys->adev->dev;
+	struct ia_css_isys_stream_cfg_data stream_cfg = {
+		.src = ip->source,
+		.vc = 0,
+		.isl_use = ICI_ISL_OFF,
+		.nof_input_pins = 1,
+	};
+	struct ia_css_isys_frame_buff_set css_buf;
+	struct ici_pad_framefmt source_fmt = {
+		.pad.pad_idx = ip->asd_source_pad_id,
+		.ffmt = {0},
+
+	};
+	struct ici_isys_node* be_csi2_node = NULL;
+
+	int rval, rvalout, tout, i;
+
+	rval = ip->asd_source->node.node_get_pad_ffmt(
+		&ip->asd_source->node, &source_fmt);
+	if (rval)
+		return rval;
+	stream_cfg.compfmt = get_comp_format(source_fmt.ffmt.pixelformat);
+	stream_cfg.input_pins[0].input_res.width = source_fmt.ffmt.width;
+	stream_cfg.input_pins[0].input_res.height = source_fmt.ffmt.height;
+	stream_cfg.input_pins[0].dt =
+		ici_isys_format_code_to_mipi(source_fmt.ffmt.pixelformat);
+
+	/*
+	 * Only CSI2-BE has the capability to do crop,
+	 * so get the crop info from csi2-be.
+	 */
+	stream_cfg.crop[0].right_offset = source_fmt.ffmt.width;
+	stream_cfg.crop[0].bottom_offset = source_fmt.ffmt.height;
+	if (ip->csi2_be) {
+		struct ici_pad_selection ps = {
+			.pad.pad_idx = CSI2_BE_ICI_PAD_SOURCE,
+			.rect = {0},
+		};
+		be_csi2_node = &ip->csi2_be->asd.node;
+		if (be_csi2_node->node_get_pad_sel)
+			rval = be_csi2_node->node_get_pad_sel(
+				be_csi2_node, &ps);
+		else
+			rval = -ENODEV;
+		if (!rval) {
+			stream_cfg.crop[0].left_offset = ps.rect.left;
+			stream_cfg.crop[0].top_offset = ps.rect.top;
+			stream_cfg.crop[0].right_offset = ps.rect.left +
+				ps.rect.width;
+			stream_cfg.crop[0].bottom_offset = ps.rect.top +
+				ps.rect.height;
+		}
+	}
+
+	as->prepare_firmware_stream_cfg(as, &stream_cfg);
+
+	if (ip->interlaced) {
+		if (ip->short_packet_source ==
+		    IPU_ISYS_SHORT_PACKET_FROM_RECEIVER)
+			csi_short_packet_prepare_firmware_stream_cfg_ici(ip,
+				&stream_cfg);
+		else
+			csi_short_packet_configure_tunit(ip, 1);
+	}
+
+//	csslib_dump_isys_stream_cfg(dev, &stream_cfg); //TODO implement corresponding function to dump command input to FW
+
+	ip->nr_output_pins = stream_cfg.nof_output_pins;
+
+	rval = get_stream_handle(as);
+	if (rval) {
+		dev_dbg(dev, "Can't get stream_handle\n");
+		return rval;
+	}
+
+	reinit_completion(&ip->stream_open_completion);
+/* SKTODO: Debug start */
+	printk("SKTODO: My stream open\n");
+	printk("ia_css_isys_stream_source src = %d\n", stream_cfg.src);
+	printk("ia_css_isys_mipi_vc vc = %d\n", stream_cfg.vc);
+	printk("ia_css_isys_isl_use isl_use = %d\n", stream_cfg.isl_use);
+	printk("compfmt = %u\n", stream_cfg.compfmt);
+	printk("struct ia_css_isys_isa_cfg isa_cfg");
+	for ( i = 0 ; i < N_IA_CSS_ISYS_CROPPING_LOCATION ; i++ ) {
+		printk("crop[%d].top_offset = %d\n", i, stream_cfg.crop[i].top_offset);
+		printk("crop[%d].left_offset = %d\n", i, stream_cfg.crop[i].left_offset);
+		printk("crop[%d].bottom_offset = %d\n", i, stream_cfg.crop[i].bottom_offset);
+		printk("crop[%d].right_offset = %d\n", i, stream_cfg.crop[i].right_offset);
+	}
+	printk("send_irq_sof_discarded = %u\n", stream_cfg.send_irq_sof_discarded);
+	printk("send_irq_eof_discarded = %u\n", stream_cfg.send_irq_eof_discarded);
+	printk("send_resp_sof_discarded = %u\n", stream_cfg.send_resp_sof_discarded);
+	printk("send_resp_eof_discarded = %u\n", stream_cfg.send_resp_eof_discarded);
+	printk("nof_input_pins = %u\n", stream_cfg.nof_input_pins);
+	printk("nof_output_pins = %u\n", stream_cfg.nof_output_pins);
+	for (i = 0 ; i < stream_cfg.nof_input_pins ; i++) {
+		printk("input_pins[%d].input_res.width = %u\n", i, stream_cfg.input_pins[i].input_res.width);
+		printk("input_pins[%d].input_res.height = %u\n", i, stream_cfg.input_pins[i].input_res.height);
+		printk("input_pins[%d].dt = %d\n", i, stream_cfg.input_pins[i].dt);
+		printk("input_pins[%d].mipi_store_mode = %d\n", i, stream_cfg.input_pins[i].mipi_store_mode);
+	}
+	for (i = 0 ; i < stream_cfg.nof_output_pins ; i++) {
+		printk("output_pins[%d].input_pin_id = %u\n", i, stream_cfg.output_pins[i].input_pin_id);
+		printk("output_pins[%d].output_res.width = %u\n", i, stream_cfg.output_pins[i].output_res.width);
+		printk("output_pins[%d].output_res.height = %u\n", i, stream_cfg.output_pins[i].output_res.height);
+		printk("output_pins[%d].stride = %u\n", i, stream_cfg.output_pins[i].stride);
+		printk("output_pins[%d].pt = %d\n", i, stream_cfg.output_pins[i].pt);
+		printk("output_pins[%d].ft = %d\n", i, stream_cfg.output_pins[i].ft);
+		printk("output_pins[%d].watermark_in_lines = %u\n", i, stream_cfg.output_pins[i].watermark_in_lines);
+		printk("output_pins[%d].send_irq = %u\n", i, stream_cfg.output_pins[i].send_irq);
+	}
+/* SKTODO: Debug end */
+	rval = ipu_lib_call(stream_open, as->isys, ip->stream_handle, &stream_cfg);
+	if (rval < 0) {
+		dev_err(dev, "can't open stream (%d)\n", rval);
+		goto out_put_stream_handle;
+	}
+	get_stream_opened(as);
+
+	tout = wait_for_completion_timeout(&ip->stream_open_completion,
+					   IPU_LIB_CALL_TIMEOUT_JIFFIES);
+	if (!tout) {
+		dev_err(dev, "stream open time out\n");
+		rval = -ETIMEDOUT;
+		goto out_put_stream_opened;
+	}
+	if (ip->error) {
+		dev_err(dev, "stream open error: %d\n", ip->error);
+		rval = -EIO;
+		goto out_put_stream_opened;
+	}
+	dev_dbg(dev, "start stream: open complete\n");
+
+	rval = ici_isys_frame_buf_add_next(as, &css_buf);
+	if (rval) {
+		dev_err(dev, "no buffers for streaming (%d)\n", rval);
+		goto out_stream_close;
+	}
+//TODO implement corresponding function to dump command input to FW
+//	csslib_dump_isys_frame_buff_set(dev, &css_buf,
+//		stream_cfg.nof_output_pins);
+
+	reinit_completion(&ip->stream_start_completion);
+	rval = ipu_lib_call(stream_start, as->isys, ip->stream_handle,
+				   &css_buf);
+	if (rval < 0) {
+		dev_err(dev, "can't start streaming (%d)\n", rval);
+		goto out_stream_close;
+	}
+
+	tout = wait_for_completion_timeout(&ip->stream_start_completion,
+					   IPU_LIB_CALL_TIMEOUT_JIFFIES);
+	if (!tout) {
+		dev_err(dev, "stream start time out\n");
+		rval = -ETIMEDOUT;
+		goto out_stream_close;
+	}
+	if (ip->error) {
+		dev_err(dev, "stream start error: %d\n", ip->error);
+		rval = -EIO;
+		goto out_stream_close;
+	}
+	dev_dbg(dev, "start stream: complete\n");
+
+	return 0;
+
+out_stream_close:
+	reinit_completion(&ip->stream_close_completion);
+
+	rvalout = ipu_lib_call(stream_close, as->isys, ip->stream_handle);
+	if (rvalout < 0) {
+		dev_dbg(dev, "can't close stream (%d)\n", rvalout);
+	} else {
+		tout = wait_for_completion_timeout(&ip->stream_close_completion,
+				IPU_LIB_CALL_TIMEOUT_JIFFIES);
+		if (!tout)
+			dev_err(dev, "stream close time out\n");
+		else if (ip->error)
+			dev_err(dev, "stream close error: %d\n", ip->error);
+		else
+			dev_dbg(dev, "stream close complete\n");
+	}
+
+out_put_stream_opened:
+	put_stream_opened(as);
+
+out_put_stream_handle:
+	put_stream_handle(as);
+	return rval;
+}
+
+static void stop_streaming_firmware(struct ici_isys_stream *as)
+{
+	struct ici_isys_pipeline *ip = &as->ip;
+	struct device *dev = &as->isys->adev->dev;
+	int rval, tout;
+
+	reinit_completion(&ip->stream_stop_completion);
+	rval = ipu_lib_call(stream_flush, as->isys, ip->stream_handle);
+	if (rval < 0) {
+		dev_err(dev, "can't stop stream (%d)\n", rval);
+	} else {
+		tout = wait_for_completion_timeout(&ip->stream_stop_completion,
+				IPU_LIB_CALL_TIMEOUT_JIFFIES);
+		if (!tout)
+			dev_err(dev, "stream stop time out\n");
+		else if (ip->error)
+			dev_err(dev, "stream stop error: %d\n", ip->error);
+		else
+			dev_dbg(dev, "stop stream: complete\n");
+	}
+	if (ip->interlaced && ip->short_packet_source ==
+	    IPU_ISYS_SHORT_PACKET_FROM_TUNIT)
+		csi_short_packet_configure_tunit(ip, 0);
+}
+
+static void close_streaming_firmware(struct ici_isys_stream *as)
+{
+	struct ici_isys_pipeline *ip = &as->ip;
+	struct device *dev = &as->isys->adev->dev;
+	int rval, tout;
+
+	reinit_completion(&ip->stream_close_completion);
+	rval = ipu_lib_call(stream_close, as->isys, ip->stream_handle);
+	if (rval < 0) {
+		dev_err(dev, "can't close stream (%d)\n", rval);
+	} else {
+		tout = wait_for_completion_timeout(&ip->stream_close_completion,
+				IPU_LIB_CALL_TIMEOUT_JIFFIES);
+		if (!tout)
+			dev_err(dev, "stream close time out\n");
+		else if (ip->error)
+			dev_err(dev, "stream close error: %d\n", ip->error);
+		else
+			dev_dbg(dev, "close stream: complete\n");
+	}
+	put_stream_opened(as);
+	put_stream_handle(as);
+}
+
+void ici_isys_stream_add_capture_done(
+	struct ici_isys_pipeline* ip,
+	void (*capture_done)(struct ici_isys_pipeline* ip,
+		struct ia_css_isys_resp_info* resp))
+{
+	unsigned int i;
+
+	/* Different instances may register same function. Add only once */
+	for (i = 0; i < ICI_NUM_CAPTURE_DONE ; i++)
+		if (ip->capture_done[i] == capture_done)
+			return;
+
+	for (i = 0; i < ICI_NUM_CAPTURE_DONE ; i++) {
+		if (ip->capture_done[i] == NULL) {
+			ip->capture_done[i] = capture_done;
+			return;
+		}
+	}
+	/*
+	 * Too many call backs registered. Change to INTEL_IPU4_NUM_CAPTURE_DONE
+	 * constant probably required.
+	 */
+	BUG();
+}
+
+void ici_isys_prepare_firmware_stream_cfg_default(
+	struct ici_isys_stream *as,
+	struct ia_css_isys_stream_cfg_data *cfg)
+{
+	struct ici_isys_pipeline *ip = &as->ip;
+
+	struct ici_isys_frame_buf_list *bl = &as->buf_list;
+
+	struct ia_css_isys_output_pin_info *pin_info;
+	int pin = cfg->nof_output_pins++;
+
+	bl->fw_output = pin;
+	ip->output_pins[pin].pin_ready = ici_isys_frame_buf_ready;
+	ip->output_pins[pin].buf_list = bl;
+
+	pin_info = &cfg->output_pins[pin];
+	pin_info->input_pin_id = 0;
+	pin_info->output_res.width = as->strm_format.ffmt.width;
+	pin_info->output_res.height = as->strm_format.ffmt.height;
+	pin_info->stride = as->strm_format.pfmt.plane_fmt[0].bytesperline;
+	pin_info->pt = bl->css_pin_type;
+	pin_info->ft = as->pfmt->css_pixelformat;
+	pin_info->send_irq = 1;
+	cfg->vc = ip->vc;
+}
+
+static int pipeline_validate_node(void* cb_data,
+	struct ici_isys_node* src_node,
+	struct node_pipe* pipe)
+{
+	int rval;
+	struct ici_isys_pipeline *ip = cb_data;
+
+	dev_err(&ip->pipeline_dev->dev, "Validating node %s\n",
+		src_node->name);
+	if (src_node->node_pipeline_validate) {
+		rval = src_node->node_pipeline_validate(&ip->pipe,
+			src_node);
+		if (rval)
+			return rval;
+	}
+	if (pipe) {
+		struct ici_isys_node* sink_node =
+			pipe->sink_pad->node;
+		struct ici_pad_framefmt src_format = {
+			.pad.pad_idx = pipe->src_pad->pad_id,
+		};
+		struct ici_pad_framefmt sink_format = {
+			.pad.pad_idx = pipe->sink_pad->pad_id,
+		};
+		if (src_node->node_get_pad_ffmt) {
+			rval = src_node->node_get_pad_ffmt(src_node,
+				&src_format);
+			if (rval)
+				return rval;
+		}
+		if (sink_node->node_get_pad_ffmt) {
+			rval = sink_node->node_get_pad_ffmt(sink_node,
+				&sink_format);
+			if (rval)
+				return rval;
+		}
+		if (src_format.ffmt.width != sink_format.ffmt.width ||
+			src_format.ffmt.height != sink_format.ffmt.height ||
+			src_format.ffmt.pixelformat != sink_format.ffmt.pixelformat ||
+			src_format.ffmt.field != sink_format.ffmt.field ||
+			src_format.ffmt.colorspace != sink_format.ffmt.colorspace) {
+			dev_err(&ip->pipeline_dev->dev, "Formats don't match node (%d:%d) -> node (%d:%d)\n",
+				src_node->node_id, src_format.pad.pad_idx,
+				sink_node->node_id, sink_format.pad.pad_idx);
+			return -EINVAL;
+		}
+	}
+	return 0;
+}
+
+static int pipeline_validate(
+	struct ici_isys_node *node,
+	struct ici_isys_pipeline *ip)
+{
+	return ici_isys_pipeline_for_each_node(
+		pipeline_validate_node,
+		ip,
+		node,
+		ip,
+		true);
+}
+
+struct set_streaming_data {
+	struct ici_isys_pipeline *ip;
+	bool external;
+	int state;
+};
+
+static int set_streaming_node(void* cb_data,
+	struct ici_isys_node* node,
+	struct node_pipe* pipe)
+{
+	struct set_streaming_data* data = cb_data;
+	if (data->external != node->external)
+		return 0;
+
+	if (node->node_set_streaming)
+		return node->node_set_streaming(node, data->ip,
+			data->state);
+	return 0;
+}
+
+
+static int set_streaming(struct ici_isys_node *node,
+	struct ici_isys_pipeline *ip,
+	bool external,
+	int state)
+{
+	struct set_streaming_data data = {
+		.ip = ip,
+		.external = external,
+		.state = state
+	};
+	return ici_isys_pipeline_for_each_node(
+		set_streaming_node,
+		&data,
+		node,
+		ip,
+		true);
+}
+
+static int ici_isys_set_streaming(
+					struct ici_isys_stream *as,
+					unsigned int state)
+{
+	struct ici_isys_pipeline *ip = &as->ip;
+	int rval = 0;
+
+	dev_dbg(&as->isys->adev->dev, "set stream (intel_stream%d): %d\n", state,
+		as->strm_dev.minor);
+
+	if (!state) {
+		stop_streaming_firmware(as);
+
+		/* stop external sub-device now. */
+		if (ip->csi2) {
+			ici_isys_csi2_wait_last_eof(ip->csi2);
+		}
+
+		set_streaming(&as->node, ip, true, 0);
+	}
+
+	rval = set_streaming(&as->node, ip, false, state);
+	if (rval)
+		goto out_stop_streaming;
+
+	if (state) {
+		rval = start_stream_firmware(as);
+		if (rval) {
+			goto out_stop_streaming;
+		}
+		dev_dbg(&ip->isys->adev->dev, "set stream: source %d, stream_handle %d\n",
+				ip->source, ip->stream_handle);
+
+		/* Start external sub-device now. */
+		rval = set_streaming(&as->node, ip, true, state);
+		if (rval)
+			goto out_stop_streaming_firmware;
+
+	} else {
+		close_streaming_firmware(as);
+	}
+
+	ip->streaming = state;
+	return 0;
+
+out_stop_streaming_firmware:
+	stop_streaming_firmware(as);
+
+out_stop_streaming:
+	set_streaming(&as->node, ip, false, 0);
+	return rval;
+}
+
+static void stream_buffers(struct ici_isys_stream *as)
+{
+	struct ici_isys_pipeline *ip = &as->ip;
+	struct ia_css_isys_frame_buff_set set = {};
+	int rval;
+
+	for (;;) {
+		rval = ici_isys_frame_buf_add_next(as, &set);
+		if (rval) {
+			break;
+		}
+//TODO implement corresponding function to dump command input to FW
+//		csslib_dump_isys_frame_buff_set(&as->isys->adev->dev, &set,
+//						ip->nr_output_pins);
+		WARN_ON(ipu_lib_call(
+				stream_capture_indication, as->isys,
+				ip->stream_handle, &set) < 0);
+	}
+}
+
+static int ici_isys_stream_on(struct file *file, void *fh)
+{
+	struct ici_isys_stream *as =
+		dev_to_stream(file->private_data);
+	struct ici_isys_pipeline *ip = &as->ip;
+	int rval, i;
+
+	dev_dbg(&as->isys->adev->dev,
+		"stream_on: %u\n", as->strm_dev.minor);
+
+	if (ip->streaming) {
+		dev_dbg(&as->isys->adev->dev,
+			"Already streaming\n");
+		return 0;
+	}
+
+	ip->csi2 = NULL;
+	ip->csi2_be = NULL;
+	ip->asd_source = NULL;
+	ip->asd_source_pad_id = 0;
+	rval = pipeline_validate(&as->node, ip);
+	if (rval)
+		return rval;
+
+	if (!ip->asd_source) {
+		dev_err(&ip->isys->adev->dev, "set stream: Pipeline does not have a source\n");
+		return -ENODEV;
+	}
+
+	pipeline_set_power(as, 1);
+
+	mutex_lock(&as->isys->stream_mutex);
+	ip->source = ip->asd_source->source;
+
+	for (i = 0; i < ICI_NUM_CAPTURE_DONE; i++)
+		ip->capture_done[i] = NULL;
+
+	if (ip->interlaced) {
+		pr_err("** SKTODO: INTERLACE ENABLED **\n");
+	    if (ip->short_packet_source ==
+            IPU_ISYS_SHORT_PACKET_FROM_RECEIVER) {
+		    rval = ici_isys_frame_buf_short_packet_setup(
+			    as, &as->strm_format);
+		    if (rval)
+			    goto out_requeue;
+	    } else {
+		    memset(ip->isys->short_packet_trace_buffer, 0,
+			    IPU_ISYS_SHORT_PACKET_TRACE_BUFFER_SIZE);
+            dma_sync_single_for_device(&as->isys->adev->dev,
+                as->isys->short_packet_trace_buffer_dma_addr,
+                IPU_ISYS_SHORT_PACKET_TRACE_BUFFER_SIZE,
+                DMA_BIDIRECTIONAL);
+            ip->short_packet_trace_index = 0;
+        }
+	}
+
+	rval = ici_isys_set_streaming(as, 1);
+	if (rval)
+		goto out_cleanup_short_packet;
+
+	ip->streaming = 1;
+
+	dev_dbg(&as->isys->adev->dev, "dispatching queued requests\n");
+	stream_buffers(as);
+	dev_dbg(&as->isys->adev->dev,
+		"done dispatching queued requests\n");
+
+	mutex_unlock(&as->isys->stream_mutex);
+
+	return 0;
+
+out_cleanup_short_packet:
+	ici_isys_frame_buf_short_packet_destroy(as);
+
+out_requeue:
+	ici_isys_frame_buf_stream_cancel(as);
+	mutex_unlock(&as->isys->stream_mutex);
+	pipeline_set_power(as, 0);
+	return rval;
+}
+
+static int ici_isys_stream_off(struct file *file, void *fh)
+{
+	struct ici_isys_stream *as =
+		dev_to_stream(file->private_data);
+	struct ici_isys_pipeline *ip = &as->ip;
+
+	mutex_lock(&as->isys->stream_mutex);
+	if (ip->streaming)
+		ici_isys_set_streaming(as, 0);
+
+	ip->streaming = 0;
+	ici_isys_frame_buf_short_packet_destroy(as);
+	mutex_unlock(&as->isys->stream_mutex);
+
+	ici_isys_frame_buf_stream_cancel(as);
+	pipeline_set_power(as, 0);
+	return 0;
+}
+
+const struct ici_isys_pixelformat
+*ici_isys_get_pixelformat(
+	struct ici_isys_stream *as, unsigned int pixelformat)
+{
+	const struct ici_isys_pixelformat *pfmt;
+	unsigned pad;
+	const unsigned *supported_codes;
+
+	pad = as->pad.pad_id;
+	supported_codes = as->asd->supported_codes[pad];
+
+	for (pfmt = as->pfmts; pfmt->bpp; pfmt++) {
+		unsigned int i;
+
+		if (pfmt->code != pixelformat)
+			continue;
+
+		for (i = 0; supported_codes[i]; i++) {
+			if (pfmt->code == supported_codes[i])
+				return pfmt;
+		}
+	}
+
+	/* Not found. Get the default, i.e. the first defined one. */
+	for (pfmt = as->pfmts; pfmt->bpp; pfmt++) {
+		if (pfmt->code == *supported_codes)
+			return pfmt;
+	}
+
+	BUG();
+}
+
+const struct ici_isys_pixelformat
+*ici_isys_video_try_fmt_vid_mplane_default(
+	struct ici_isys_stream *as,
+	struct ici_stream_format *mpix)
+{
+	const struct ici_isys_pixelformat *pfmt =
+		ici_isys_get_pixelformat(as, mpix->ffmt.pixelformat);
+
+	mpix->ffmt.pixelformat = pfmt->pixelformat;
+	mpix->pfmt.num_planes = 1;
+
+	if (!as->packed)
+		mpix->pfmt.plane_fmt[0].bytesperline =
+			 mpix->ffmt.width * DIV_ROUND_UP(pfmt->bpp,
+			 BITS_PER_BYTE);
+	else
+		mpix->pfmt.plane_fmt[0].bytesperline = DIV_ROUND_UP(
+			as->line_header_length + as->line_footer_length
+			+ (unsigned int)mpix->ffmt.width * pfmt->bpp,
+			BITS_PER_BYTE);
+
+	mpix->pfmt.plane_fmt[0].bytesperline =
+		ALIGN(mpix->pfmt.plane_fmt[0].bytesperline,
+		as->isys->line_align);
+	mpix->pfmt.plane_fmt[0].bpp = pfmt->bpp;
+
+	 /*
+	 * (height + 1) * bytesperline due to a hardware issue: the DMA unit
+	 * is a power of two, and a line should be transferred as few units
+	 * as possible. The result is that up to line length more data than
+	 * the image size may be transferred to memory after the image.
+	 * Another limition is the GDA allocation unit size. For low
+	 * resolution it gives a bigger number. Use larger one to avoid
+	 * memory corruption.
+	 */
+	mpix->pfmt.plane_fmt[0].sizeimage =
+		max(max(mpix->pfmt.plane_fmt[0].sizeimage,
+			mpix->pfmt.plane_fmt[0].bytesperline *
+			mpix->ffmt.height +
+			max(mpix->pfmt.plane_fmt[0].bytesperline,
+			as->isys->pdata->ipdata->isys_dma_overshoot)),
+			1U);
+
+	if (mpix->ffmt.field == ICI_FIELD_ANY)
+		mpix->ffmt.field = ICI_FIELD_NONE;
+
+	return pfmt;
+}
+
+static int ici_s_fmt_vid_cap_mplane(
+	struct ici_isys_stream *as,
+	struct ici_stream_format *f)
+{
+	if (as->ip.streaming)
+		return -EBUSY;
+
+	as->pfmt = as->try_fmt_vid_mplane(as, f);
+	as->strm_format = *f;
+
+	return 0;
+}
+
+/**
+ * Returns true if device does not support real interrupts and
+ * polling must be used.
+ */
+static int ici_poll_for_events(
+	struct ici_isys_stream *as)
+{
+//	return is_intel_ipu_hw_fpga();
+	return 0;
+}
+
+static void ipu_cleanup_fw_msg_bufs(struct ici_isys *isys)
+{
+        struct isys_fw_msgs *fwmsg, *fwmsg0;
+        unsigned long flags;
+
+        spin_lock_irqsave(&isys->listlock, flags);
+        list_for_each_entry_safe(fwmsg, fwmsg0, &isys->framebuflist_fw, head)
+                list_move(&fwmsg->head, &isys->framebuflist);
+        spin_unlock_irqrestore(&isys->listlock, flags);
+}
+
+static int stream_fop_open(struct inode *inode, struct file *file)
+{
+	struct ici_stream_device *strm_dev =
+		inode_to_intel_ipu_stream_device(inode);
+	struct ici_isys_stream* as = dev_to_stream(strm_dev);
+	struct ici_isys *isys = as->isys;
+	struct ipu_bus_device *adev =
+		to_ipu_bus_device(&isys->adev->dev);
+	struct ipu_device *isp = adev->isp;
+	int rval;
+	DEBUGK("%s: stream open (%p)\n", __func__, as);
+
+	mutex_lock(&isys->mutex);
+	if (isys->reset_needed) {
+		mutex_unlock(&isys->mutex);
+		dev_warn(&isys->adev->dev, "isys power cycle required\n");
+		return -EIO;
+	}
+	mutex_unlock(&isys->mutex);
+
+	rval = ipu_buttress_authenticate(isp);
+	if (rval) {
+		dev_err(&isys->adev->dev, "FW authentication failed\n");
+		return rval;
+	}
+
+	rval = pm_runtime_get_sync(&isys->adev->dev);
+	if (rval < 0) {
+		pm_runtime_put_noidle(&isys->adev->dev);
+		return rval;
+	}
+
+	mutex_lock(&isys->mutex);
+
+	ipu_configure_spc(adev->isp,
+				 &isys->pdata->ipdata->hw_variant,
+				 IA_CSS_PKG_DIR_ISYS_INDEX,
+				 isys->pdata->base, isys->pkg_dir,
+				 isys->pkg_dir_dma_addr);
+
+
+	if (isys->ici_stream_opened++) {
+		/* Already open */
+		mutex_unlock(&isys->mutex);
+		return 0;
+	}
+
+        ipu_cleanup_fw_msg_bufs(isys);
+
+	if (isys->fwcom) {
+		/*
+		 * Something went wrong in previous shutdown. As we are now
+		 * restarting isys we can safely delete old context.
+		 */
+		ici_fw_isys_cleanup(isys);
+		isys->fwcom = NULL;
+	}
+
+	if (ici_poll_for_events(as)) {
+		static const struct sched_param param = {
+			.sched_priority = MAX_USER_RT_PRIO/2,
+		};
+
+		isys->isr_thread = kthread_run(
+			intel_ipu4_isys_isr_run_ici, as->isys,
+			IPU_ISYS_ENTITY_PREFIX);
+
+		if (IS_ERR(isys->isr_thread)) {
+			rval = PTR_ERR(isys->isr_thread);
+			goto out_intel_ipu4_pipeline_pm_use;
+		}
+
+		sched_setscheduler(isys->isr_thread, SCHED_FIFO, &param);
+	}
+
+	rval = ici_fw_isys_init(as->isys, IPU_ISYS_NUM_STREAMS);
+	if (rval < 0)
+		goto out_lib_init;
+
+	mutex_unlock(&isys->mutex);
+
+	return 0;
+
+out_lib_init:
+	if (ici_poll_for_events(as))
+		kthread_stop(isys->isr_thread);
+
+out_intel_ipu4_pipeline_pm_use:
+	isys->ici_stream_opened--;
+	mutex_unlock(&isys->mutex);
+	pm_runtime_put(&isys->adev->dev);
+
+	return rval;
+}
+
+static int stream_fop_release(struct inode *inode, struct file *file)
+{
+	struct ici_stream_device *strm_dev =
+		inode_to_intel_ipu_stream_device(inode);
+	struct ici_isys_stream* as = dev_to_stream(strm_dev);
+	int ret = 0;
+	DEBUGK("%s: stream release (%p)\n", __func__, as);
+
+	if (as->ip.streaming) {
+		ici_isys_stream_off(file, NULL);
+	}
+
+	mutex_lock(&as->isys->mutex);
+
+	if (!--as->isys->ici_stream_opened) {
+		if (ici_poll_for_events(as))
+			kthread_stop(as->isys->isr_thread);
+
+		intel_ipu4_isys_library_close(as->isys);
+		if (as->isys->fwcom) {
+			as->isys->reset_needed = true;
+			ret = -EIO;
+		}
+	}
+
+	mutex_unlock(&as->isys->mutex);
+
+	pm_runtime_put(&as->isys->adev->dev);
+	return ret;
+}
+
+static unsigned int stream_fop_poll(struct file *file,
+	struct poll_table_struct *poll)
+{
+	struct ici_isys_stream *as =
+		dev_to_stream(file->private_data);
+	struct ici_isys *isys = as->isys;
+	unsigned int res = 0;
+
+	dev_dbg(&isys->adev->dev, "stream_fop_poll\n");
+
+	poll_wait(file, &as->buf_list.wait, poll);
+
+	if (!list_empty(&as->buf_list.putbuf_list))
+		res = POLLIN;
+
+	dev_dbg(&isys->adev->dev, "stream_fop_poll res %u\n", res);
+
+	return res;
+}
+
+static int ici_isys_set_format(struct file *file, void *fh,
+	struct ici_stream_format *sf)
+{
+	int rval;
+	struct ici_isys_stream *as =
+		dev_to_stream(file->private_data);
+	struct ici_isys *isys = as->isys;
+
+	DEBUGK("%s: ici stream set format (%p)\n \
+		width: %u, height: %u, pixelformat: %u, field: %u, colorspace: %u\n",
+			__func__, as,
+			sf->ffmt.width,
+			sf->ffmt.height,
+			sf->ffmt.pixelformat,
+			sf->ffmt.field,
+			sf->ffmt.colorspace);
+
+	if (sf->ffmt.field == ICI_FIELD_ALTERNATE) {
+		DEBUGK("Interlaced enabled\n");
+		as->ip.interlaced = true;
+		as->ip.short_packet_source = 1;
+	} else {
+		as->ip.interlaced = false;
+	}
+
+	rval = ici_s_fmt_vid_cap_mplane(as, sf);
+	if (rval) {
+		dev_err(&isys->adev->dev, "failed to set format (vid_cap) %d\n", rval);
+		return rval;
+	}
+	if (sf->pfmt.num_planes != 1) {
+		dev_err(&isys->adev->dev, "Invalid num of planes %d\n",
+			sf->pfmt.num_planes);
+		return rval;
+	}
+	if (!sf->pfmt.plane_fmt[0].sizeimage) {
+		dev_err(&isys->adev->dev, "Zero image size for plane 0\n");
+		return rval;
+	}
+
+	return 0;
+}
+
+static int ici_isys_getbuf(struct file *file, void *fh,
+	struct ici_frame_info *user_frame_info)
+{
+	int rval = 0;
+	struct ici_isys_stream *as = dev_to_stream(
+		file->private_data);
+	struct ici_isys *isys = as->isys;
+
+	//DEBUGK("%s: ici stream getbuf (%p)\n", __func__, as);
+	rval = ici_isys_get_buf(as, user_frame_info);
+	if(rval) {
+		dev_err(&isys->adev->dev, "failed to get buffer %d\n", rval);
+		return rval;
+	}
+
+	mutex_lock(&as->isys->stream_mutex);
+	if (as->ip.streaming) {
+		stream_buffers(as);
+	}
+	mutex_unlock(&as->isys->stream_mutex);
+	return 0;
+}
+
+static int ici_isys_getbuf_virt(struct file *file, void *fh,
+	struct ici_frame_buf_wrapper *user_frame_buf, struct page **pages)
+{
+	int rval = 0;
+	struct ici_isys_stream *as = dev_to_stream(
+		file->private_data);
+	struct ici_isys *isys = as->isys;
+
+	rval = ici_isys_get_buf_virt(as, user_frame_buf, pages);
+	if (rval) {
+		dev_err(&isys->adev->dev, "failed to get buffer %d\n", rval);
+		return rval;
+	}
+
+	mutex_lock(&as->isys->stream_mutex);
+	if (as->ip.streaming) {
+		stream_buffers(as);
+	}
+	mutex_unlock(&as->isys->stream_mutex);
+	return 0;
+}
+
+static int ici_isys_putbuf(struct file *file, void *fh,
+	struct ici_frame_info *user_frame_info)
+{
+	int rval = 0;
+	struct ici_isys_stream *as = dev_to_stream(file->private_data);
+	struct ici_isys *isys = as->isys;
+	//DEBUGK("%s: ici stream putbuf (%p)\n", __func__, as);
+	rval = ici_isys_put_buf(as, user_frame_info,
+		file->f_flags);
+	if(rval) {
+		dev_err(&isys->adev->dev, "failed to put buffer %d\n", rval);
+		return rval;
+	}
+	return 0;
+}
+
+static int ici_isys_stream_get_ffmt(
+	struct ici_isys_node* node,
+	struct ici_pad_framefmt* pff)
+{
+	struct ici_isys_stream *as = node->sd;
+	if (pff->pad.pad_idx != 0) {
+		dev_err(&as->isys->adev->dev,
+			"Stream only has pad 0\n");
+		return -EINVAL;
+	}
+	pff->ffmt = as->strm_format.ffmt;
+	return 0;
+}
+
+static const struct ici_ioctl_ops ioctl_ops_mplane_ici = {
+	.ici_set_format = ici_isys_set_format,
+	.ici_stream_on = ici_isys_stream_on,
+	.ici_stream_off = ici_isys_stream_off,
+	.ici_get_buf = ici_isys_getbuf,
+	.ici_get_buf_virt = ici_isys_getbuf_virt,
+	.ici_put_buf = ici_isys_putbuf,
+};
+
+static const struct file_operations ipu4_isys_ici_stream_fops = {
+	.owner = THIS_MODULE,
+	.poll = stream_fop_poll,
+	.open = stream_fop_open,
+	.release = stream_fop_release,
+};
+
+int ici_isys_stream_init(
+				struct ici_isys_stream *as,
+				struct ici_isys_subdev *asd,
+				struct ici_isys_node *node,
+				unsigned int pad,
+				unsigned long pad_flags)
+{
+	int rval;
+	char name[ICI_MAX_NODE_NAME];
+
+	mutex_init(&as->mutex);
+	init_completion(&as->ip.stream_open_completion);
+	init_completion(&as->ip.stream_close_completion);
+	init_completion(&as->ip.stream_start_completion);
+	init_completion(&as->ip.stream_stop_completion);
+	init_completion(&as->ip.capture_ack_completion);
+	as->ip.isys = as->isys;
+	as->ip.pipeline_dev = &as->isys->pipeline_dev;
+	as->asd = asd;
+
+	as->strm_dev.ipu_ioctl_ops = &ioctl_ops_mplane_ici;
+
+	ici_isys_frame_buf_init(&as->buf_list);
+
+	as->pad.flags = pad_flags | ICI_PAD_FLAGS_MUST_CONNECT;
+	snprintf(name, sizeof(name),
+		 "%s Stream", asd->node.name);
+	rval = ici_isys_pipeline_node_init(as->isys,
+		&as->node, name, 1, &as->pad);
+	if (rval)
+		goto out_init_fail;
+
+	if (__ici_isys_subdev_get_ffmt(asd, pad))
+		as->strm_format.ffmt =
+			*__ici_isys_subdev_get_ffmt(asd, pad);
+
+	as->node.sd = as;
+	as->node.pipe = &as->ip.pipe;
+	as->node.node_get_pad_ffmt =
+		ici_isys_stream_get_ffmt;
+
+	asd->node.pipe = &as->ip.pipe;
+	/*asd->node.ops = &entity_ops;*/
+	as->strm_dev.fops = &ipu4_isys_ici_stream_fops;
+
+	as->strm_dev.frame_buf_list = &as->buf_list;
+	as->strm_dev.mutex = &as->mutex;
+	as->strm_dev.dev_parent = &as->isys->adev->dev;
+	dev_set_drvdata(&as->strm_dev.dev, as);
+
+	mutex_lock(&as->mutex);
+
+	rval = stream_device_register(&as->strm_dev);
+	if (rval)
+		goto out_mutex_unlock;
+
+	if (pad_flags & ICI_PAD_FLAGS_SINK)
+		rval = node_pad_create_link(
+			node, pad, &as->node, 0, 0);
+	else if (pad_flags & ICI_PAD_FLAGS_SOURCE)
+		rval = node_pad_create_link(
+			&as->node, 0, node, pad, 0);
+
+	if (rval) {
+		printk(KERN_WARNING "can't create link\n");
+		goto out_mutex_unlock;
+	}
+
+	mutex_unlock(&as->mutex);
+
+	return rval;
+
+out_mutex_unlock:
+	mutex_unlock(&as->mutex);
+	node_pads_cleanup(&as->asd->node);
+	//intel_ipu4_isys_framebuf_cleanup(&as->buf_list);
+out_init_fail:
+	mutex_destroy(&as->mutex);
+
+	return rval;
+}
+
+void ici_isys_stream_cleanup(struct ici_isys_stream *as)
+{
+	list_del(&as->node.node_entry);
+	stream_device_unregister(&as->strm_dev);
+	node_pads_cleanup(&as->asd->node);
+	mutex_destroy(&as->mutex);
+	//intel_ipu4_isys_framebuf_cleanup(&as->buf_list);
+}
+
+#endif //ICI_ENABLED
+
diff --git a/drivers/media/pci/intel/ici/ici-isys-stream.h b/drivers/media/pci/intel/ici/ici-isys-stream.h
new file mode 100644
index 0000000..77d89ed
--- /dev/null
+++ b/drivers/media/pci/intel/ici/ici-isys-stream.h
@@ -0,0 +1,85 @@
+/* SPDX-License-Identifier: (BSD-3-Clause OR GPL-2.0) */
+/*
+ * Copyright (C) 2018 Intel Corporation
+ */
+
+#ifndef ICI_ISYS_STREAM_H
+#define ICI_ISYS_STREAM_H
+
+#include <linux/mutex.h>
+#include <linux/list.h>
+#include <media/ici.h>
+
+#include "ici-isys-stream-device.h"
+#include "ici-isys-frame-buf.h"
+#include "ici-isys-pipeline.h"
+
+
+struct ici_isys;
+struct ia_css_isys_stream_cfg_data;
+struct ici_isys_subdev;
+
+struct ici_isys_pixelformat {
+        uint32_t pixelformat;
+        uint32_t bpp;
+        uint32_t bpp_packed;
+        uint32_t code;
+        uint32_t css_pixelformat;
+};
+
+struct ici_isys_stream {
+	/* Serialise access to other fields in the struct. */
+	struct mutex mutex;
+	struct node_pad pad;
+	struct ici_isys_node node;
+	struct ici_stream_device strm_dev;
+	struct ici_stream_format strm_format;
+	const struct ici_isys_pixelformat *pfmts;
+	const struct ici_isys_pixelformat *pfmt;
+	struct ici_isys_frame_buf_list buf_list;
+	struct ici_isys_subdev* asd;
+	struct ici_isys *isys; /* its parent device */
+	struct ici_isys_pipeline ip;
+	unsigned int streaming;
+	bool packed;
+	unsigned int line_header_length; /* bits */
+	unsigned int line_footer_length; /* bits */
+	const struct ici_isys_pixelformat *(*try_fmt_vid_mplane)(
+		struct ici_isys_stream *as,
+		struct ici_stream_format *mpix);
+	void (*prepare_firmware_stream_cfg)(
+		struct ici_isys_stream *as,
+		struct ia_css_isys_stream_cfg_data *cfg);
+	int (*frame_done_notify_queue)(void);
+};
+
+#define to_intel_ipu4_isys_ici_stream(__buf_list) \
+	container_of(__buf_list, struct ici_isys_stream, buf_list)
+#define ici_pipeline_to_stream(__ip) \
+	container_of(__ip, struct ici_isys_stream, ip)
+
+extern const struct ici_isys_pixelformat ici_isys_pfmts[];
+extern const struct ici_isys_pixelformat ici_isys_pfmts_be_soc[];
+extern const struct ici_isys_pixelformat ici_isys_pfmts_packed[];
+
+const struct ici_isys_pixelformat
+*ici_isys_video_try_fmt_vid_mplane_default(
+	struct ici_isys_stream *as,
+	struct ici_stream_format *mpix);
+void ici_isys_prepare_firmware_stream_cfg_default(
+	struct ici_isys_stream *as,
+	struct ia_css_isys_stream_cfg_data *cfg);
+
+int ici_isys_stream_init(struct ici_isys_stream *as,
+				struct ici_isys_subdev *asd,
+				struct ici_isys_node *node,
+				unsigned int pad,
+				unsigned long pad_flags);
+void ici_isys_stream_cleanup(struct ici_isys_stream *as);
+
+void ici_isys_stream_add_capture_done(
+	struct ici_isys_pipeline* ip,
+	void (*capture_done)(struct ici_isys_pipeline* ip,
+		struct ia_css_isys_resp_info* resp));
+
+#endif /* ICI_ISYS_STREAM_H */
diff --git a/drivers/media/pci/intel/ici/ici-isys-subdev.c b/drivers/media/pci/intel/ici/ici-isys-subdev.c
new file mode 100644
index 0000000..4d12a70
--- /dev/null
+++ b/drivers/media/pci/intel/ici/ici-isys-subdev.c
@@ -0,0 +1,548 @@
+// SPDX-License-Identifier: (BSD-3-Clause OR GPL-2.0)
+/*
+ * Copyright (C) 2018 Intel Corporation
+ */
+
+#include "./ici/ici-isys.h"
+#ifdef ICI_ENABLED
+
+#include "./ici/ici-isys-subdev.h"
+#include "./ici/ici-isys-pipeline.h"
+
+unsigned int ici_isys_format_code_to_bpp(u32 code)
+{
+	switch (code) {
+	case ICI_FORMAT_RGB888:
+		return 24;
+	case ICI_FORMAT_RGB565:
+	case ICI_FORMAT_UYVY:
+	case ICI_FORMAT_YUYV:
+		return 16;
+	case ICI_FORMAT_SBGGR12:
+	case ICI_FORMAT_SGBRG12:
+	case ICI_FORMAT_SGRBG12:
+	case ICI_FORMAT_SRGGB12:
+		return 12;
+	case ICI_FORMAT_SBGGR10:
+	case ICI_FORMAT_SGBRG10:
+	case ICI_FORMAT_SGRBG10:
+	case ICI_FORMAT_SRGGB10:
+		return 10;
+	case ICI_FORMAT_SBGGR8:
+	case ICI_FORMAT_SGBRG8:
+	case ICI_FORMAT_SGRBG8:
+	case ICI_FORMAT_SRGGB8:
+	case ICI_FORMAT_SBGGR10_DPCM8:
+	case ICI_FORMAT_SGBRG10_DPCM8:
+	case ICI_FORMAT_SGRBG10_DPCM8:
+	case ICI_FORMAT_SRGGB10_DPCM8:
+		return 8;
+	default:
+		BUG_ON(1);
+	}
+}
+
+unsigned int ici_isys_format_code_to_mipi(u32 code)
+{
+	switch (code) {
+	case ICI_FORMAT_RGB565:
+		return ICI_ISYS_MIPI_CSI2_TYPE_RGB565;
+	case ICI_FORMAT_RGB888:
+		return ICI_ISYS_MIPI_CSI2_TYPE_RGB888;
+	case ICI_FORMAT_UYVY:
+	case ICI_FORMAT_YUYV:
+		return ICI_ISYS_MIPI_CSI2_TYPE_YUV422_8;
+	case ICI_FORMAT_SBGGR12:
+	case ICI_FORMAT_SGBRG12:
+	case ICI_FORMAT_SGRBG12:
+	case ICI_FORMAT_SRGGB12:
+		return ICI_ISYS_MIPI_CSI2_TYPE_RAW12;
+	case ICI_FORMAT_SBGGR10:
+	case ICI_FORMAT_SGBRG10:
+	case ICI_FORMAT_SGRBG10:
+	case ICI_FORMAT_SRGGB10:
+		return ICI_ISYS_MIPI_CSI2_TYPE_RAW10;
+	case ICI_FORMAT_SBGGR8:
+	case ICI_FORMAT_SGBRG8:
+	case ICI_FORMAT_SGRBG8:
+	case ICI_FORMAT_SRGGB8:
+		return ICI_ISYS_MIPI_CSI2_TYPE_RAW8;
+	case ICI_FORMAT_SBGGR10_DPCM8:
+	case ICI_FORMAT_SGBRG10_DPCM8:
+	case ICI_FORMAT_SGRBG10_DPCM8:
+	case ICI_FORMAT_SRGGB10_DPCM8:
+		return ICI_ISYS_MIPI_CSI2_TYPE_USER_DEF(1);
+	default:
+		BUG_ON(1);
+	}
+}
+
+enum ici_isys_subdev_pixelorder
+ici_isys_subdev_get_pixelorder(u32 code)
+{
+	switch (code) {
+	case ICI_FORMAT_SBGGR12:
+	case ICI_FORMAT_SBGGR10:
+	case ICI_FORMAT_SBGGR8:
+	case ICI_FORMAT_SBGGR10_DPCM8:
+		return ICI_ISYS_SUBDEV_PIXELORDER_BGGR;
+	case ICI_FORMAT_SGBRG12:
+	case ICI_FORMAT_SGBRG10:
+	case ICI_FORMAT_SGBRG8:
+	case ICI_FORMAT_SGBRG10_DPCM8:
+		return ICI_ISYS_SUBDEV_PIXELORDER_GBRG;
+	case ICI_FORMAT_SGRBG12:
+	case ICI_FORMAT_SGRBG10:
+	case ICI_FORMAT_SGRBG8:
+	case ICI_FORMAT_SGRBG10_DPCM8:
+		return ICI_ISYS_SUBDEV_PIXELORDER_GRBG;
+	case ICI_FORMAT_SRGGB12:
+	case ICI_FORMAT_SRGGB10:
+	case ICI_FORMAT_SRGGB8:
+	case ICI_FORMAT_SRGGB10_DPCM8:
+		return ICI_ISYS_SUBDEV_PIXELORDER_RGGB;
+	default:
+		BUG_ON(1);
+	}
+}
+
+unsigned int ici_isys_get_compression_scheme(u32 code)
+{
+	switch (code) {
+	case ICI_FORMAT_SBGGR10_DPCM8:
+	case ICI_FORMAT_SGBRG10_DPCM8:
+	case ICI_FORMAT_SGRBG10_DPCM8:
+	case ICI_FORMAT_SRGGB10_DPCM8:
+		return 3;
+	default:
+		return 0;
+	}
+}
+
+u32 ici_isys_subdev_code_to_uncompressed(u32 sink_code)
+{
+	switch (sink_code) {
+	case ICI_FORMAT_SBGGR10_DPCM8:
+		return ICI_FORMAT_SBGGR10;
+	case ICI_FORMAT_SGBRG10_DPCM8:
+		return ICI_FORMAT_SGBRG10;
+	case ICI_FORMAT_SGRBG10_DPCM8:
+		return ICI_FORMAT_SGRBG10;
+	case ICI_FORMAT_SRGGB10_DPCM8:
+		return ICI_FORMAT_SRGGB10;
+	default:
+		return sink_code;
+	}
+}
+
+struct ici_framefmt *__ici_isys_subdev_get_ffmt(
+				struct ici_isys_subdev *asd,
+				unsigned pad)
+{
+	if (pad >= asd->num_pads)
+		return NULL;
+
+	return &asd->ffmt[pad];
+}
+
+int ici_isys_subdev_get_ffmt(
+	struct ici_isys_node* node,
+	struct ici_pad_framefmt* pff)
+{
+	int ret = 0;
+	struct ici_framefmt *format_out;
+	struct ici_isys_subdev *asd = node->sd;
+
+	mutex_lock(&asd->mutex);
+	format_out = __ici_isys_subdev_get_ffmt(asd,
+		pff->pad.pad_idx);
+	if (format_out)
+		pff->ffmt = *format_out;
+	else
+		ret = -EINVAL;
+	mutex_unlock(&asd->mutex);
+	return ret;
+}
+
+static int __subdev_set_ffmt(struct ici_isys_subdev *asd,
+			struct ici_pad_framefmt *pff)
+{
+	unsigned int i;
+	unsigned pad = pff->pad.pad_idx;
+	unsigned pixelformat;
+	BUG_ON(!mutex_is_locked(&asd->mutex));
+
+	if (pad >= asd->num_pads)
+		return -EINVAL;
+
+	pff->ffmt.width = clamp(pff->ffmt.width,
+		IPU_ISYS_MIN_WIDTH,
+		IPU_ISYS_MAX_WIDTH);
+	pff->ffmt.height = clamp(pff->ffmt.height,
+		IPU_ISYS_MIN_HEIGHT,
+		IPU_ISYS_MAX_HEIGHT);
+
+	pixelformat = asd->supported_codes[pad][0];
+	for (i = 0; asd->supported_codes[pad][i]; i++) {
+		if (asd->supported_codes[pad][i] ==
+			pff->ffmt.pixelformat) {
+
+			pixelformat = asd->supported_codes[pad][i];
+			break;
+		}
+	}
+	pff->ffmt.pixelformat = pixelformat;
+	asd->set_ffmt_internal(asd, pad, &pff->ffmt);
+	asd->ffmt[pad] = pff->ffmt;
+	return 0;
+}
+
+int ici_isys_subdev_set_ffmt(
+	struct ici_isys_node* node,
+	struct ici_pad_framefmt* pff)
+{
+	int res;
+	struct ici_isys_subdev *asd = node->sd;
+
+	mutex_lock(&asd->mutex);
+	res = __subdev_set_ffmt(asd, pff);
+	mutex_unlock(&asd->mutex);
+	return res;
+}
+
+int ici_isys_subdev_get_supported_format(
+	struct ici_isys_node* node,
+	struct ici_pad_supported_format_desc* psfd)
+{
+	struct ici_isys_subdev *asd = node->sd;
+	int pad = psfd->pad.pad_idx;
+	int idx = psfd->idx;
+	int i;
+	int rval = 0;
+
+	mutex_lock(&asd->mutex);
+	if (!asd->supported_code_counts[pad]) {
+		for (i = 0; asd->supported_codes[pad][i]; i++) {}
+		asd->supported_code_counts[pad] = i;
+	}
+
+	if (idx < asd->supported_code_counts[pad]) {
+		psfd->color_format = asd->supported_codes[pad][idx];
+		psfd->min_width = IPU_ISYS_MIN_WIDTH;
+		psfd->max_width = IPU_ISYS_MAX_WIDTH;
+		psfd->min_height = IPU_ISYS_MIN_HEIGHT;
+		psfd->max_height = IPU_ISYS_MAX_HEIGHT;
+	} else {
+		rval = -EINVAL;
+	}
+
+	mutex_unlock(&asd->mutex);
+	return rval;
+}
+
+
+int intel_ipu4_isys_subdev_set_crop_rect(struct ici_isys_subdev
+					*asd, unsigned pad,
+					struct ici_rect *r)
+{
+	struct node_pad *np;
+	struct ici_rect rmax = { 0 };
+	struct ici_rect *rcrop;
+	unsigned int tgt;
+	struct ici_framefmt *ffmt =
+		__ici_isys_subdev_get_ffmt(asd, pad);
+
+	if (!ffmt)
+		return -EINVAL;
+	if (!asd->valid_tgts[pad].crop)
+		return -EINVAL;
+	np = &asd->pads[pad];
+	rcrop = &asd->crop[pad];
+
+	if (np->flags & ICI_PAD_FLAGS_SINK) {
+		rmax.width = ffmt->width;
+		rmax.height = ffmt->height;
+		tgt = ICI_ISYS_SUBDEV_PROP_TGT_SINK_CROP;
+	} else {
+		/* 0 is the sink pad. */
+		rmax = asd->crop[0];
+		tgt = ICI_ISYS_SUBDEV_PROP_TGT_SOURCE_CROP;
+	}
+	rcrop->width = clamp(r->width, IPU_ISYS_MIN_WIDTH, rmax.width);
+	rcrop->height = clamp(r->height, IPU_ISYS_MIN_HEIGHT,
+				rmax.height);
+	ici_isys_subdev_fmt_propagate(asd, pad, rcrop, tgt, NULL);
+	return 0;
+}
+
+int intel_ipu4_isys_subdev_set_compose_rect(struct ici_isys_subdev
+						*asd, unsigned pad,
+						struct ici_rect *r)
+{
+	struct node_pad *np;
+	struct ici_rect rmax = { 0 };
+	struct ici_rect *rcompose;
+	unsigned int tgt;
+	struct ici_framefmt *ffmt =
+		__ici_isys_subdev_get_ffmt(asd, pad);
+
+	if (!ffmt)
+		return -EINVAL;
+	if (!asd->valid_tgts[pad].compose)
+		return -EINVAL;
+	np = &asd->pads[pad];
+	rcompose = &asd->compose[pad];
+
+	if (np->flags & ICI_PAD_FLAGS_SINK) {
+		rmax = asd->crop[pad];
+		tgt = ICI_ISYS_SUBDEV_PROP_TGT_SINK_COMPOSE;
+	} else {
+		/* 0 is the sink pad. */
+		rmax = asd->compose[0];
+		tgt = ICI_ISYS_SUBDEV_PROP_TGT_SOURCE_COMPOSE;
+	}
+	rcompose->width = clamp(r->width, IPU_ISYS_MIN_WIDTH,
+				rmax.width);
+	rcompose->height = clamp(r->height, IPU_ISYS_MIN_HEIGHT,
+				 rmax.height);
+	ici_isys_subdev_fmt_propagate(asd, pad, rcompose, tgt,
+						  NULL);
+	return 0;
+}
+
+int ici_isys_subdev_set_sel(
+	struct ici_isys_node* node,
+	struct ici_pad_selection* ps)
+{
+	struct ici_isys_subdev *asd = node->sd;
+	int rval = 0;
+
+	if (WARN_ON(ps->pad.pad_idx >= asd->num_pads))
+		return -EINVAL;
+
+	mutex_lock(&asd->mutex);
+	switch (ps->sel_type)
+	{
+		case ICI_EXT_SEL_TYPE_COMPOSE:
+			rval = intel_ipu4_isys_subdev_set_compose_rect(
+				asd, ps->pad.pad_idx, &ps->rect);
+			break;
+		case ICI_EXT_SEL_TYPE_CROP:
+			rval = intel_ipu4_isys_subdev_set_crop_rect(
+				asd, ps->pad.pad_idx, &ps->rect);
+			break;
+		default:
+			rval = -EINVAL;
+	}
+	mutex_unlock(&asd->mutex);
+	return rval;
+}
+
+int ici_isys_subdev_get_sel(
+	struct ici_isys_node* node,
+	struct ici_pad_selection* ps)
+{
+	struct ici_isys_subdev *asd = node->sd;
+	int rval = 0;
+
+	if (WARN_ON(ps->pad.pad_idx >= asd->num_pads))
+		return -EINVAL;
+
+	mutex_lock(&asd->mutex);
+	switch (ps->sel_type)
+	{
+		case ICI_EXT_SEL_TYPE_COMPOSE:
+			ps->rect = asd->compose[ps->pad.pad_idx];
+			break;
+		case ICI_EXT_SEL_TYPE_CROP:
+			ps->rect = asd->crop[ps->pad.pad_idx];
+			break;
+		default:
+			rval = -EINVAL;
+	}
+	mutex_unlock(&asd->mutex);
+	return rval;
+}
+
+void ici_isys_subdev_fmt_propagate(
+				struct ici_isys_subdev *asd,
+				unsigned pad,
+				struct ici_rect *r,
+				enum ici_isys_subdev_prop_tgt tgt,
+				struct ici_framefmt *ffmt)
+{
+	unsigned i;
+	struct ici_framefmt *ffmts[asd->num_pads];
+	struct ici_rect *crops[asd->num_pads];
+	struct ici_rect *compose[asd->num_pads];
+
+	if (WARN_ON(pad >= asd->num_pads))
+		return;
+
+	for (i = 0; i < asd->num_pads; i++) {
+		ffmts[i] = __ici_isys_subdev_get_ffmt(asd, pad);
+		crops[i] = &asd->crop[i];
+		compose[i] = &asd->compose[i];
+	}
+
+	switch (tgt) {
+	case ICI_ISYS_SUBDEV_PROP_TGT_SINK_FMT:
+		crops[pad]->left = crops[pad]->top = 0;
+		crops[pad]->width = ffmt->width;
+		crops[pad]->height = ffmt->height;
+		ici_isys_subdev_fmt_propagate(asd, pad,
+							crops[pad], tgt + 1,
+							ffmt);
+		return;
+	case ICI_ISYS_SUBDEV_PROP_TGT_SINK_CROP:
+		if (WARN_ON(asd->pads[pad].flags & ICI_PAD_FLAGS_SOURCE))
+			return;
+		compose[pad]->left = compose[pad]->top = 0;
+		compose[pad]->width = r->width;
+		compose[pad]->height = r->height;
+		ici_isys_subdev_fmt_propagate(asd, pad,
+							compose[pad], tgt + 1,
+							ffmt);
+		return;
+	case ICI_ISYS_SUBDEV_PROP_TGT_SINK_COMPOSE:
+		if (!(asd->pads[pad].flags & ICI_PAD_FLAGS_SINK))
+			return;
+
+		for (i = 1; i < asd->num_pads; i++) {
+			if (!(asd->pads[i].flags & ICI_PAD_FLAGS_SOURCE))
+				continue;
+
+			compose[i]->left = compose[i]->top = 0;
+			compose[i]->width = r->width;
+			compose[i]->height = r->height;
+			ici_isys_subdev_fmt_propagate(asd, i,
+								compose[i],
+								tgt + 1,
+								ffmt);
+		}
+		return;
+	case ICI_ISYS_SUBDEV_PROP_TGT_SOURCE_COMPOSE:
+		if (WARN_ON(asd->pads[pad].flags & ICI_PAD_FLAGS_SINK))
+			return;
+
+		crops[pad]->left = crops[pad]->top = 0;
+		crops[pad]->width = r->width;
+		crops[pad]->height = r->height;
+		ici_isys_subdev_fmt_propagate(asd, pad,
+							crops[pad], tgt + 1,
+							ffmt);
+		return;
+	case ICI_ISYS_SUBDEV_PROP_TGT_SOURCE_CROP:{
+			struct ici_framefmt fmt = {
+				.width = r->width,
+				.height = r->height,
+				/*
+				 * Either use the code from sink pad
+				 * or the current one.
+				 */
+				.pixelformat = (ffmt ? ffmt->pixelformat :
+						ffmts[pad]->pixelformat),
+			};
+
+			asd->set_ffmt_internal(asd, pad, &fmt);
+			return;
+		}
+	}
+}
+
+int ici_isys_subdev_init(struct ici_isys_subdev *asd,
+	const char* name,
+	unsigned int num_pads,
+	unsigned int index)
+{
+	int res = 0;
+
+	mutex_init(&asd->mutex);
+	asd->num_pads = num_pads;
+	asd->pads = devm_kcalloc(&asd->isys->adev->dev, num_pads,
+				sizeof(*asd->pads), GFP_KERNEL);
+
+	asd->ffmt = devm_kcalloc(&asd->isys->adev->dev, num_pads,
+				sizeof(*asd->ffmt), GFP_KERNEL);
+
+	asd->crop = devm_kcalloc(&asd->isys->adev->dev, num_pads,
+				sizeof(*asd->crop), GFP_KERNEL);
+
+	asd->compose = devm_kcalloc(&asd->isys->adev->dev, num_pads,
+				sizeof(*asd->compose), GFP_KERNEL);
+
+	asd->valid_tgts = devm_kcalloc(&asd->isys->adev->dev, num_pads,
+					sizeof(*asd->valid_tgts),
+					GFP_KERNEL);
+
+	asd->supported_code_counts = devm_kcalloc(&asd->isys->adev->dev,
+		num_pads, sizeof(*asd->supported_code_counts),
+		GFP_KERNEL);
+
+	if (!asd->pads || !asd->ffmt || !asd->crop || !asd->compose ||
+	    !asd->valid_tgts || !asd->supported_code_counts) {
+		res = -ENOMEM;
+		goto cleanup_allocs;
+	}
+
+	asd->isl_mode = ICI_ISL_OFF;
+	asd->be_mode = ICI_BE_RAW;
+	asd->source = -1;
+	asd->index = index;
+
+	asd->node.parent = &asd->isys->pipeline_dev;
+	asd->node.sd = asd;
+	asd->node.external = false;
+
+	res = ici_isys_pipeline_node_init(asd->isys,
+		&asd->node, name, asd->num_pads, asd->pads);
+	if (res)
+		goto cleanup_allocs;
+
+	asd->node.node_set_pad_ffmt =
+		ici_isys_subdev_set_ffmt;
+	asd->node.node_get_pad_ffmt =
+		ici_isys_subdev_get_ffmt;
+	asd->node.node_get_pad_supported_format =
+		ici_isys_subdev_get_supported_format;
+	asd->node.node_set_pad_sel =
+		ici_isys_subdev_set_sel;
+	asd->node.node_get_pad_sel =
+		ici_isys_subdev_get_sel;
+
+	return 0;
+
+cleanup_allocs:
+	if (asd->valid_tgts)
+		devm_kfree(&asd->isys->adev->dev, asd->valid_tgts);
+	if (asd->compose)
+		devm_kfree(&asd->isys->adev->dev, asd->compose);
+	if (asd->crop)
+		devm_kfree(&asd->isys->adev->dev, asd->crop);
+	if (asd->ffmt)
+		devm_kfree(&asd->isys->adev->dev, asd->ffmt);
+	if (asd->pads)
+		devm_kfree(&asd->isys->adev->dev, asd->pads);
+	mutex_destroy(&asd->mutex);
+	return res;
+}
+
+void ici_isys_subdev_cleanup(
+	struct ici_isys_subdev *asd)
+{
+	list_del(&asd->node.node_entry);
+
+	if (asd->valid_tgts)
+		devm_kfree(&asd->isys->adev->dev, asd->valid_tgts);
+	if (asd->compose)
+		devm_kfree(&asd->isys->adev->dev, asd->compose);
+	if (asd->crop)
+		devm_kfree(&asd->isys->adev->dev, asd->crop);
+	if (asd->ffmt)
+		devm_kfree(&asd->isys->adev->dev, asd->ffmt);
+	if (asd->pads)
+		devm_kfree(&asd->isys->adev->dev, asd->pads);
+	mutex_destroy(&asd->mutex);
+}
+
+#endif /*ICI_ENABLED*/
diff --git a/drivers/media/pci/intel/ici/ici-isys-subdev.h b/drivers/media/pci/intel/ici/ici-isys-subdev.h
new file mode 100644
index 0000000..e783fa1
--- /dev/null
+++ b/drivers/media/pci/intel/ici/ici-isys-subdev.h
@@ -0,0 +1,110 @@
+/* SPDX-License-Identifier: (BSD-3-Clause OR GPL-2.0) */
+/*
+ * Copyright (C) 2018 Intel Corporation
+ */
+
+#ifndef ICI_ISYS_SUBDEV_H
+#define ICI_ISYS_SUBDEV_H
+
+#include <media/ici.h>
+#include "ici-isys-pipeline.h"
+
+struct node_subdev_format;
+
+#define ICI_ISYS_MIPI_CSI2_TYPE_NULL	0x10
+#define ICI_ISYS_MIPI_CSI2_TYPE_BLANKING	0x11
+#define ICI_ISYS_MIPI_CSI2_TYPE_EMBEDDED8	0x12
+#define ICI_ISYS_MIPI_CSI2_TYPE_YUV422_8	0x1e
+#define ICI_ISYS_MIPI_CSI2_TYPE_RGB565	0x22
+#define ICI_ISYS_MIPI_CSI2_TYPE_RGB888	0x24
+#define ICI_ISYS_MIPI_CSI2_TYPE_RAW6	0x28
+#define ICI_ISYS_MIPI_CSI2_TYPE_RAW7	0x29
+#define ICI_ISYS_MIPI_CSI2_TYPE_RAW8	0x2a
+#define ICI_ISYS_MIPI_CSI2_TYPE_RAW10	0x2b
+#define ICI_ISYS_MIPI_CSI2_TYPE_RAW12	0x2c
+#define ICI_ISYS_MIPI_CSI2_TYPE_RAW14	0x2d
+#define ICI_ISYS_MIPI_CSI2_TYPE_USER_DEF(i)	(0x30 + (i)-1) /* 1-8 */
+
+enum ici_be_mode {
+	ICI_BE_RAW = 0,
+	ICI_BE_SOC
+};
+
+enum ici_isl_mode {
+	ICI_ISL_OFF = 0,	/* IA_CSS_ISYS_USE_NO_ISL_NO_ISA */
+	ICI_ISL_CSI2_BE,	/* IA_CSS_ISYS_USE_SINGLE_DUAL_ISL */
+	ICI_ISL_ISA	/* IA_CSS_ISYS_USE_SINGLE_ISA */
+};
+
+enum ici_isys_subdev_pixelorder {
+	ICI_ISYS_SUBDEV_PIXELORDER_BGGR = 0,
+	ICI_ISYS_SUBDEV_PIXELORDER_GBRG,
+	ICI_ISYS_SUBDEV_PIXELORDER_GRBG,
+	ICI_ISYS_SUBDEV_PIXELORDER_RGGB,
+};
+
+enum ici_isys_subdev_prop_tgt {
+	ICI_ISYS_SUBDEV_PROP_TGT_SINK_FMT,
+	ICI_ISYS_SUBDEV_PROP_TGT_SINK_CROP,
+	ICI_ISYS_SUBDEV_PROP_TGT_SINK_COMPOSE,
+	ICI_ISYS_SUBDEV_PROP_TGT_SOURCE_COMPOSE,
+	ICI_ISYS_SUBDEV_PROP_TGT_SOURCE_CROP,
+};
+
+#define	ICI_ISYS_SUBDEV_PROP_TGT_NR_OF \
+	(INTEL_IPU4_ISYS_SUBDEV_PROP_TGT_SOURCE_CROP + 1)
+
+struct ici_isys_subdev {
+	struct ici_isys_node node;
+	/* Serialise access to any other field in the struct */
+	struct mutex mutex;
+	struct ici_isys *isys;
+	unsigned const *const *supported_codes;
+	unsigned* supported_code_counts;
+	unsigned int num_pads;
+	struct node_pad *pads;
+	struct ici_framefmt *ffmt;
+	struct ici_rect *crop;
+	struct ici_rect *compose;
+	struct {
+		bool crop;
+		bool compose;
+	} *valid_tgts;
+	enum ici_isl_mode isl_mode;
+	enum ici_be_mode be_mode;
+	int source;		/* SSI stream source; -1 if unset */
+	unsigned int index; /* index for sd array in csi2 */
+	void (*set_ffmt_internal)(
+		struct ici_isys_subdev *asd,
+		unsigned pad,
+		struct ici_framefmt *format);
+};
+
+unsigned int ici_isys_format_code_to_bpp(u32 code);
+unsigned int ici_isys_format_code_to_mipi(u32 code);
+enum ici_isys_subdev_pixelorder
+ici_isys_subdev_get_pixelorder(u32 code);
+unsigned int ici_isys_get_compression_scheme(u32 code);
+u32 ici_isys_subdev_code_to_uncompressed(u32 sink_code);
+
+struct ici_framefmt* __ici_isys_subdev_get_ffmt(
+	struct ici_isys_subdev *asd,
+	unsigned pad);
+void ici_isys_subdev_fmt_propagate(
+		struct ici_isys_subdev *asd,
+		unsigned pad,
+		struct ici_rect *r,
+		enum ici_isys_subdev_prop_tgt
+		tgt,
+		struct ici_framefmt *ffmt);
+
+int ici_isys_subdev_init(struct ici_isys_subdev *asd,
+	const char* name,
+	unsigned int num_pads,
+	unsigned int index);
+void ici_isys_subdev_cleanup(
+	struct ici_isys_subdev *asd);
+
+#define ici_node_to_subdev(__node) \
+	container_of(__node, struct ici_isys_subdev, node)
+#endif /* ICI_ISYS_SUBDEV_H */
diff --git a/drivers/media/pci/intel/ici/ici-isys-tpg.c b/drivers/media/pci/intel/ici/ici-isys-tpg.c
new file mode 100644
index 0000000..250ed01
--- /dev/null
+++ b/drivers/media/pci/intel/ici/ici-isys-tpg.c
@@ -0,0 +1,214 @@
+// SPDX-License-Identifier: (BSD-3-Clause OR GPL-2.0)
+/*
+ * Copyright (C) 2018 Intel Corporation
+ */
+
+#include "./ici/ici-isys.h"
+#ifdef ICI_ENABLED
+#include <media/ici.h>
+#include "./ici/ici-isys-subdev.h"
+#include "./ici/ici-isys-stream.h"
+#include "./ici/ici-isys-tpg.h"
+#include "ipu-isys-tpg.h"
+#include "isysapi/interface/ia_css_isysapi_fw_types.h"
+
+#define MIPI_GEN_PPC		4
+
+#define ici_asd_to_tpg(__asd) \
+	container_of(__asd, struct ici_isys_tpg, asd)
+
+static const uint32_t ici_tpg_supported_codes_pad[] = {
+	ICI_FORMAT_SBGGR8,
+	ICI_FORMAT_SGBRG8,
+	ICI_FORMAT_SGRBG8,
+	ICI_FORMAT_SRGGB8,
+	ICI_FORMAT_SBGGR10,
+	ICI_FORMAT_SGBRG10,
+	ICI_FORMAT_SGRBG10,
+	ICI_FORMAT_SRGGB10,
+	0,
+};
+
+static const uint32_t *ici_tpg_supported_codes[] = {
+	ici_tpg_supported_codes_pad,
+};
+
+static int set_stream(
+	struct ici_isys_node *node,
+	void* ip,
+	int enable)
+{
+	struct ici_isys_subdev *asd = node->sd;
+	struct ici_isys_tpg *tpg =
+		to_ici_isys_tpg(asd);
+	unsigned int bpp =
+		ici_isys_format_code_to_bpp(tpg->asd.
+						    ffmt[TPG_PAD_SOURCE].
+						    pixelformat);
+	/*
+	 * In B0 MIPI_GEN block is CSI2 FB. Need to enable/disable TPG selection
+	 * register to control the TPG streaming.
+	 */
+	writel(enable ? 1 : 0, tpg->sel);
+
+	if (!enable) {
+		writel(0, tpg->base + MIPI_GEN_REG_COM_ENABLE);
+		return 0;
+	}
+
+	writel(MIPI_GEN_COM_DTYPE_RAW(bpp),
+		tpg->base + MIPI_GEN_REG_COM_DTYPE);
+	writel(ici_isys_format_code_to_mipi
+		(tpg->asd.ffmt[TPG_PAD_SOURCE].pixelformat),
+		tpg->base + MIPI_GEN_REG_COM_VTYPE);
+
+	writel(0, tpg->base + MIPI_GEN_REG_COM_VCHAN);
+	writel(DIV_ROUND_UP
+		(tpg->asd.ffmt[TPG_PAD_SOURCE].width * bpp, BITS_PER_BYTE),
+		tpg->base + MIPI_GEN_REG_COM_WCOUNT);
+
+	writel(0, tpg->base + MIPI_GEN_REG_SYNG_NOF_FRAMES);
+
+	writel(DIV_ROUND_UP(tpg->asd.ffmt[TPG_PAD_SOURCE].width, MIPI_GEN_PPC),
+		tpg->base + MIPI_GEN_REG_SYNG_NOF_PIXELS);
+	writel(tpg->asd.ffmt[TPG_PAD_SOURCE].height,
+		tpg->base + MIPI_GEN_REG_SYNG_NOF_LINES);
+
+	writel(0, tpg->base + MIPI_GEN_REG_TPG_MODE);
+
+	writel(-1, tpg->base + MIPI_GEN_REG_TPG_HCNT_MASK);
+	writel(-1, tpg->base + MIPI_GEN_REG_TPG_VCNT_MASK);
+	writel(-1, tpg->base + MIPI_GEN_REG_TPG_XYCNT_MASK);
+	writel(0, tpg->base + MIPI_GEN_REG_TPG_HCNT_DELTA);
+	writel(0, tpg->base + MIPI_GEN_REG_TPG_VCNT_DELTA);
+
+	writel(2, tpg->base + MIPI_GEN_REG_COM_ENABLE);
+	return 0;
+}
+
+static const char *const tpg_mode_items[] = {
+	"Ramp",
+	"Checkerboard",		/* Does not work, disabled. */
+	"Frame Based Colour",
+	NULL,
+};
+
+void ici_tpg_set_ffmt(struct ici_isys_subdev *asd,
+			unsigned pad,
+			struct ici_framefmt *ffmt)
+{
+	struct ici_framefmt *cur_ffmt =
+		__ici_isys_subdev_get_ffmt(asd, pad);
+
+	ffmt->field = ICI_FIELD_NONE;
+	ffmt->colorspace = 0;
+	memset(ffmt->reserved, 0, sizeof(ffmt->reserved));
+	if (cur_ffmt) {
+            *cur_ffmt = *ffmt;
+	     dev_dbg(&asd->isys->adev->dev, "%s: TPG ici stream set format\n"
+	        "width: %u, height: %u, pixelformat: %u, colorspace: %u field: %u\n",
+		__func__,
+		cur_ffmt->width,
+		cur_ffmt->height,
+		cur_ffmt->pixelformat, cur_ffmt->colorspace, cur_ffmt->field);
+	}
+}
+
+static int ici_tpg_pipeline_validate(
+	struct node_pipeline *inp,
+	struct ici_isys_node *node)
+{
+	struct ici_isys_subdev* asd = node->sd;
+	struct ici_isys_tpg *tpg =
+		ici_asd_to_tpg(asd);
+	struct ici_isys_pipeline *ip =
+		ici_nodepipe_to_pipeline(inp);
+
+	ip->asd_source = &tpg->asd;
+	ip->asd_source_pad_id = TPG_PAD_SOURCE;
+	return 0;
+}
+
+int ici_isys_tpg_init(struct ici_isys_tpg *tpg,
+				struct ici_isys *isys,
+				void __iomem *base, void __iomem *sel,
+				unsigned int index)
+{
+	struct ici_pad_framefmt fmt = {
+		.pad.pad_idx = TPG_PAD_SOURCE,
+		.ffmt = {
+				.width = 4096,
+				.height = 3072,
+			},
+	};
+
+	int rval;
+	char name[ICI_MAX_NODE_NAME];
+
+	dev_dbg(&isys->adev->dev, "ici_isys_tpg_init\n");
+
+	tpg->isys = isys;
+	tpg->base = base;
+	tpg->index = index;
+	tpg->sel = sel;
+	tpg->asd.isys = isys;
+
+	snprintf(name, sizeof(name),
+			 IPU_ISYS_ENTITY_PREFIX " TPG %u", index);
+	rval = ici_isys_subdev_init(&tpg->asd,
+		name, NR_OF_TPG_PADS, 0);
+	if (rval)
+		goto fail;
+
+	tpg->asd.pads[TPG_PAD_SOURCE].flags = ICI_PAD_FLAGS_SOURCE;
+
+	tpg->asd.source = IA_CSS_ISYS_STREAM_SRC_MIPIGEN_PORT0 + index;
+	tpg->asd.supported_codes = ici_tpg_supported_codes;
+	tpg->asd.set_ffmt_internal = ici_tpg_set_ffmt;
+	tpg->asd.node.node_set_streaming = set_stream;
+	tpg->asd.node.node_pipeline_validate =
+		ici_tpg_pipeline_validate;
+	tpg->asd.node.node_set_pad_ffmt(&tpg->asd.node, &fmt);
+	tpg->as.isys = isys;
+	tpg->as.try_fmt_vid_mplane =
+		ici_isys_video_try_fmt_vid_mplane_default;
+	tpg->as.prepare_firmware_stream_cfg =
+		ici_isys_prepare_firmware_stream_cfg_default;
+	tpg->as.pfmts = ici_isys_pfmts_packed;
+	tpg->as.packed = true;
+	tpg->as.buf_list.css_pin_type = IA_CSS_ISYS_PIN_TYPE_MIPI;
+	tpg->as.line_header_length =
+		INTEL_IPU4_ISYS_CSI2_LONG_PACKET_HEADER_SIZE;
+	tpg->as.line_footer_length =
+		INTEL_IPU4_ISYS_CSI2_LONG_PACKET_FOOTER_SIZE;
+
+	/*TODO:*/
+	/*
+	 * Buffer queue management call backs to be added.
+	 */
+
+	rval = ici_isys_stream_init(&tpg->as, &tpg->asd,
+			&tpg->asd.node, TPG_PAD_SOURCE,
+			ICI_PAD_FLAGS_SINK);
+	if (rval) {
+		dev_err(&isys->adev->dev, "can't init stream node\n");
+		goto fail;
+	}
+
+	return 0;
+
+fail:
+	ici_isys_tpg_cleanup(tpg);
+
+	return 1;
+}
+EXPORT_SYMBOL(ici_isys_tpg_init);
+
+void ici_isys_tpg_cleanup(struct ici_isys_tpg *tpg)
+{
+	ici_isys_subdev_cleanup(&tpg->asd);
+	ici_isys_stream_cleanup(&tpg->as);
+}
+EXPORT_SYMBOL(ici_isys_tpg_cleanup);
+
+#endif /*ICI_ENABLED*/
diff --git a/drivers/media/pci/intel/ici/ici-isys-tpg.h b/drivers/media/pci/intel/ici/ici-isys-tpg.h
new file mode 100644
index 0000000..5e6eeef
--- /dev/null
+++ b/drivers/media/pci/intel/ici/ici-isys-tpg.h
@@ -0,0 +1,47 @@
+/* SPDX-License-Identifier: (BSD-3-Clause OR GPL-2.0) */
+/*
+ * Copyright (C) 2018 Intel Corporation
+ */
+
+#ifndef ICI_ISYS_TPG_H
+#define ICI_ISYS_TPG_H
+
+#include "ici-isys-frame-buf.h"
+#include "ici-isys-subdev.h"
+#include "ici-isys-stream.h"
+
+struct intel_ipu4_isys_tpg_pdata;
+
+#define TPG_PAD_SOURCE			0
+#define NR_OF_TPG_PADS			1
+
+/*
+ * struct ici_isys_tpg
+ *
+ *
+*/
+struct ici_isys_tpg {
+	struct intel_ipu4_isys_tpg_pdata *pdata;
+	struct ici_isys *isys;
+	struct ici_isys_subdev asd;
+	struct ici_isys_stream as;
+
+	void __iomem *base;
+	void __iomem *sel;
+	int streaming;
+	u32 receiver_errors;
+	unsigned int nlanes;
+	unsigned int index;
+	atomic_t sof_sequence;
+};
+
+#define to_ici_isys_tpg(sd)					\
+	container_of(sd, struct ici_isys_tpg, asd)
+
+int ici_isys_tpg_init(struct ici_isys_tpg *tpg,
+				struct ici_isys *isys,
+				void __iomem *base, void __iomem *sel,
+				unsigned int index);
+void ici_isys_tpg_cleanup(struct ici_isys_tpg *tpg);
+
+#endif /* ICI_ISYS_TPG_H */
diff --git a/drivers/media/pci/intel/ici/ici-isys.c b/drivers/media/pci/intel/ici/ici-isys.c
new file mode 100644
index 0000000..466659b
--- /dev/null
+++ b/drivers/media/pci/intel/ici/ici-isys.c
@@ -0,0 +1,1367 @@
+// SPDX-License-Identifier: (BSD-3-Clause OR GPL-2.0)
+/*
+ * Copyright (C) 2018 Intel Corporation
+ */
+
+#include <linux/debugfs.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/firmware.h>
+#include <linux/kthread.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+#include <linux/string.h>
+#include <linux/sched.h>
+#include <linux/version.h>
+
+#include <media/ipu-isys.h>
+#include <media/ipu4-acpi.h>
+
+#include "ipu.h"
+#include "ipu-bus.h"
+#include "ipu-cpd.h"
+#include "ipu-mmu.h"
+#include "ipu-dma.h"
+#include "ipu-platform-isys-csi2-reg.h"
+#include "ipu-trace.h"
+#include "ipu-buttress.h"
+#include "isysapi/interface/ia_css_isysapi.h"
+#include "./ici/ici-isys.h"
+#include "./ici/ici-isys-csi2.h"
+#include "./ici/ici-isys-pipeline-device.h"
+
+#ifdef ICI_ENABLED
+
+#define ISYS_PM_QOS_VALUE	300
+
+#define INTEL_IPU4_ISYS_OUTPUT_PINS 11
+#define INTEL_IPU4_NUM_CAPTURE_DONE 2
+
+/* Trace block definitions for isys */
+struct ipu_trace_block isys_trace_blocks[] = {
+	{
+		.offset = TRACE_REG_IS_TRACE_UNIT_BASE,
+		.type = IPU_TRACE_BLOCK_TUN,
+	},
+	{
+		.offset = TRACE_REG_IS_SP_EVQ_BASE,
+		.type = IPU_TRACE_BLOCK_TM,
+	},
+	{
+		.offset = TRACE_REG_IS_SP_GPC_BASE,
+		.type = IPU_TRACE_BLOCK_GPC,
+	},
+	{
+		.offset = TRACE_REG_IS_ISL_GPC_BASE,
+		.type = IPU_TRACE_BLOCK_GPC,
+	},
+	{
+		.offset = TRACE_REG_IS_MMU_GPC_BASE,
+		.type = IPU_TRACE_BLOCK_GPC,
+	},
+	{
+		.offset = TRACE_REG_CSI2_TM_BASE,
+		.type = IPU_TRACE_CSI2,
+	},
+	{
+		.offset = TRACE_REG_CSI2_3PH_TM_BASE,
+		.type = IPU_TRACE_CSI2_3PH,
+	},
+	{
+		/* Note! this covers all 9 blocks */
+		.offset = TRACE_REG_CSI2_SIG2SIO_GR_BASE(0),
+		.type = IPU_TRACE_SIG2CIOS,
+	},
+	{
+		/* Note! this covers all 9 blocks */
+		.offset = TRACE_REG_CSI2_PH3_SIG2SIO_GR_BASE(0),
+		.type = IPU_TRACE_SIG2CIOS,
+	},
+	{
+		.offset = TRACE_REG_IS_GPREG_TRACE_TIMER_RST_N,
+		.type = IPU_TRACE_TIMER_RST,
+	},
+	{
+		.type = IPU_TRACE_BLOCK_END,
+	}
+};
+
+
+// Latest code structure doesnt do these functions.
+// let it remain to gauge the impact and then remove.
+#if 0
+static int isys_determine_legacy_csi_lane_configuration(struct ici_isys *isys)
+{
+	const struct csi_lane_cfg {
+		u32 reg_value;
+		int port_lanes[IPU_ISYS_MAX_CSI2_LEGACY_PORTS];
+	} csi_lanes_to_cfg[] = {
+		{ 0x0, { 4, 2, 0, 0 } }, /* no sensor defaults here */
+		{ 0x1, { 3, 2, 0, 0 } },
+		{ 0x2, { 2, 2, 0, 0 } },
+		{ 0x3, { 1, 2, 0, 0 } },
+		{ 0x4, { 4, 1, 0, 0 } },
+		{ 0x5, { 3, 1, 0, 0 } },
+		{ 0x6, { 2, 1, 0, 0 } },
+		{ 0x7, { 1, 1, 0, 0 } },
+		{ 0x8, { 4, 1, 0, 1 } },
+		{ 0x9, { 3, 1, 0, 1 } },
+		{ 0xa, { 2, 1, 0, 1 } },
+		{ 0xb, { 1, 1, 0, 1 } },
+		{ 0x10, { 2, 2, 2, 0 } },
+		{ 0x11, { 2, 2, 1, 0 } },
+		{ 0x18, { 2, 1, 2, 1 } },
+		{ 0x19, { 1, 1, 1, 1 } },
+	};
+	int i, j;
+
+	for (i = 0; i < ARRAY_SIZE(csi_lanes_to_cfg); i++) {
+		for (j = 0; j < IPU_ISYS_MAX_CSI2_LEGACY_PORTS; j++) {
+			/* Port with no sensor can be handled as don't care */
+			if (!isys->ici_csi2[j].nlanes)
+				continue;
+			if (csi_lanes_to_cfg[i].port_lanes[j] !=
+			    isys->ici_csi2[j].nlanes)
+				break;
+		}
+
+		if (j < IPU_ISYS_MAX_CSI2_LEGACY_PORTS)
+			continue;
+
+		isys->legacy_port_cfg = csi_lanes_to_cfg[i].reg_value;
+		dev_dbg(&isys->adev->dev, "Lane configuration value 0x%x\n,",
+			 isys->legacy_port_cfg);
+		return 0;
+	}
+	dev_err(&isys->adev->dev, "Non supported CSI lane configuration\n,");
+	return -EINVAL;
+}
+
+static int isys_determine_csi_combo_lane_configuration(struct ici_isys *isys)
+{
+	const struct csi_lane_cfg {
+		u32 reg_value;
+		int port_lanes[IPU_ISYS_MAX_CSI2_COMBO_PORTS];
+	} csi_lanes_to_cfg[] = {
+		{ 0x1f, { 0, 0 } }, /* no sensor defaults here - disable all */
+		{ 0x10, { 4, 0 } },
+		{ 0x11, { 3, 0 } },
+		{ 0x12, { 2, 0 } },
+		{ 0x13, { 1, 0 } },
+		{ 0x14, { 3, 1 } },
+		{ 0x15, { 2, 1 } },
+		{ 0x16, { 1, 1 } },
+		{ 0x18, { 2, 2 } },
+		{ 0x19, { 1, 2 } },
+	};
+	int i, j;
+
+	for (i = 0; i < ARRAY_SIZE(csi_lanes_to_cfg); i++) {
+		for (j = 0; j <  IPU_ISYS_MAX_CSI2_COMBO_PORTS; j++) {
+			/* Port with no sensor can be handled as don't care */
+			if (!isys->ici_csi2[j + IPU_ISYS_MAX_CSI2_LEGACY_PORTS].nlanes)
+				continue;
+			if (csi_lanes_to_cfg[i].port_lanes[j] !=
+			    isys->ici_csi2[j + IPU_ISYS_MAX_CSI2_LEGACY_PORTS].nlanes)
+				break;
+		}
+
+		if (j < IPU_ISYS_MAX_CSI2_COMBO_PORTS)
+			continue;
+
+		isys->combo_port_cfg = csi_lanes_to_cfg[i].reg_value;
+		dev_dbg(&isys->adev->dev,
+			"Combo port lane configuration value 0x%x\n",
+			isys->combo_port_cfg);
+
+		return 0;
+	}
+	dev_err(&isys->adev->dev,
+		"Unsupported CSI2-combo lane configuration\n");
+	return 0;
+}
+
+#endif
+struct isys_i2c_test {
+	u8 bus_nr;
+	u16 addr;
+	struct i2c_client *client;
+};
+
+static int isys_i2c_test(struct device *dev, void *priv)
+{
+	struct i2c_client *client = i2c_verify_client(dev);
+	struct isys_i2c_test *test = priv;
+
+	if (!client)
+		return 0;
+
+	if (i2c_adapter_id(client->adapter) != test->bus_nr
+	    || client->addr != test->addr)
+		return 0;
+
+	test->client = client;
+
+	return 0;
+}
+
+static struct i2c_client *isys_find_i2c_subdev(struct i2c_adapter *adapter,
+				struct ipu_isys_subdev_info *sd_info)
+{
+	struct i2c_board_info *info = &sd_info->i2c.board_info;
+	struct isys_i2c_test test = {
+		.bus_nr = i2c_adapter_id(adapter),
+		.addr = info->addr,
+	};
+	int rval;
+
+	rval = i2c_for_each_dev(&test, isys_i2c_test);
+	if (rval || !test.client)
+		return NULL;
+	return test.client;
+}
+
+static struct ici_ext_subdev *register_acpi_i2c_subdev(
+	struct ipu_isys_subdev_info *sd_info, struct i2c_client *client)
+{
+	struct i2c_board_info *info = &sd_info->i2c.board_info;
+	struct ici_ext_subdev *sd;
+
+	request_module(I2C_MODULE_PREFIX "%s", info->type);
+
+	/* ACPI overwrite with platform data */
+	client->dev.platform_data = info->platform_data;
+	/* Change I2C client name to one in temporary platform data */
+	strlcpy(client->name, info->type, sizeof(client->name));
+
+	if (device_reprobe(&client->dev))
+		return NULL;
+
+	if (!client->dev.driver)
+		return NULL;
+
+	if (!try_module_get(client->dev.driver->owner))
+		return NULL;
+
+	sd = i2c_get_clientdata(client);
+
+	module_put(client->dev.driver->owner);
+
+	return sd;
+}
+
+static int ext_device_setup_node(void* ipu_data,
+	struct ici_ext_subdev *sd,
+	const char* name)
+{
+	int rval;
+	struct ici_isys *isys = ipu_data;
+	sd->node.sd = sd;
+	sd->node.external = true;
+	rval = ici_isys_pipeline_node_init(
+		isys, &sd->node, name, sd->num_pads, sd->pads);
+	if (rval)
+		return rval;
+	sd->num_pads = sd->node.nr_pads;
+	return 0;
+}
+
+static int isys_complete_ext_device_registration(
+	struct ici_isys *isys,
+	struct ici_ext_subdev *sd,
+	struct ipu_isys_csi2_config *csi2)
+{
+	int rval;
+	struct ici_ext_subdev_register sd_register = {0};
+	unsigned int i;
+
+	sd_register.ipu_data = isys;
+	sd_register.sd = sd;
+	sd_register.setup_node = ext_device_setup_node;
+	sd_register.create_link = node_pad_create_link;
+	rval = sd->do_register(&sd_register);
+	if (rval) {
+		dev_err(&isys->adev->dev,
+			"Failed to regsiter external subdev\n");
+		return rval;
+	}
+	if (csi2) {
+        for (i = 0; i < NR_OF_CSI2_VC; i++) {
+            rval = node_pad_create_link(&sd->node, sd->src_pad,
+                    &isys->ici_csi2[csi2->port].asd[i].node,
+                    CSI2_ICI_PAD_SINK, 0);
+            if (rval) {
+                dev_warn(&isys->adev->dev,
+                        "can't create link from external node\n");
+                return rval;
+            }
+
+            isys->ici_csi2[csi2->port].nlanes = csi2->nlanes;
+            isys->ici_csi2[csi2->port].ext_sd = sd;
+        }
+    }
+	return 0;
+}
+
+static int isys_register_ext_subdev(struct ici_isys *isys,
+				    struct ipu_isys_subdev_info *sd_info,
+				    bool acpi_only)
+{
+	struct i2c_adapter *adapter =
+		i2c_get_adapter(sd_info->i2c.i2c_adapter_id);
+	struct ici_ext_subdev *sd;
+	struct i2c_client *client;
+	int rval;
+
+	dev_info(&isys->adev->dev,
+		 "creating new i2c subdev for %s (address %2.2x, bus %d)",
+		 sd_info->i2c.board_info.type, sd_info->i2c.board_info.addr,
+		 sd_info->i2c.i2c_adapter_id);
+
+	if (!adapter) {
+		dev_warn(&isys->adev->dev, "can't find adapter\n");
+		return -ENOENT;
+	}
+	if (sd_info->csi2) {
+		dev_info(&isys->adev->dev, "sensor device on CSI port: %d\n",
+			sd_info->csi2->port);
+		if (sd_info->csi2->port >= IPU_ISYS_MAX_CSI2_PORTS ||
+		    !isys->ici_csi2[sd_info->csi2->port].isys) {
+			dev_warn(&isys->adev->dev, "invalid csi2 port %u\n",
+				 sd_info->csi2->port);
+			rval = -EINVAL;
+			goto skip_put_adapter;
+		}
+	} else {
+		dev_info(&isys->adev->dev, "non camera subdevice\n");
+	}
+
+	client = isys_find_i2c_subdev(adapter, sd_info);
+
+	if (acpi_only) {
+		if (!client) {
+			dev_dbg(&isys->adev->dev,
+				 "Matching ACPI device not found - postpone\n");
+			rval = 0;
+			goto skip_put_adapter;
+		}
+		rval = 0;
+		goto skip_put_adapter;
+		if (!sd_info->acpiname) {
+			dev_dbg(&isys->adev->dev,
+				 "No name in platform data\n");
+			rval = 0;
+			goto skip_put_adapter;
+		}
+		if (strcmp(dev_name(&client->dev), sd_info->acpiname)) {
+			dev_dbg(&isys->adev->dev, "Names don't match: %s != %s",
+				dev_name(&client->dev), sd_info->acpiname);
+			rval = 0;
+			goto skip_put_adapter;
+		}
+		/* Acpi match found. Continue to reprobe */
+	} else if (client) {
+		dev_dbg(&isys->adev->dev, "Device exists\n");
+		rval = 0;
+		goto skip_put_adapter;
+	} 
+	else if (sd_info->acpiname) {
+		dev_dbg(&isys->adev->dev, "ACPI name don't match: %s\n",
+			sd_info->acpiname);
+		rval = 0;
+		goto skip_put_adapter;
+	}
+	if (!client) {
+		dev_info(&isys->adev->dev,
+			 "i2c device not found in ACPI table\n");
+		client = i2c_new_device(adapter,
+			&sd_info->i2c.board_info);
+		sd = i2c_get_clientdata(client);
+	} else {
+		dev_info(&isys->adev->dev, "i2c device found in ACPI table\n");
+		sd = register_acpi_i2c_subdev(sd_info, client);
+	}
+
+	if (!sd) {
+		dev_warn(&isys->adev->dev, "can't create new i2c subdev\n");
+		rval = -EINVAL;
+		goto skip_put_adapter;
+	}
+
+	return isys_complete_ext_device_registration(isys, sd, sd_info->csi2);
+
+skip_put_adapter:
+	i2c_put_adapter(adapter);
+
+	return rval;
+}
+
+static int isys_acpi_add_device(struct device *dev, void *priv,
+				struct ipu_isys_csi2_config *csi2,
+				bool reprobe)
+{
+	struct ici_isys *isys = priv;
+	struct i2c_client *client = i2c_verify_client(dev);
+	struct ici_ext_subdev *sd;
+
+	if (!client)
+		return -ENODEV;
+
+	if (reprobe)
+		if (device_reprobe(&client->dev))
+			return -ENODEV;
+
+	if (!client->dev.driver)
+		return -ENODEV;
+
+	/* Lock the module so we can safely get the v4l2_subdev pointer */
+        if (!try_module_get(client->dev.driver->owner))
+		return -ENODEV;
+
+	sd = i2c_get_clientdata(client);
+        module_put(client->dev.driver->owner);
+	if (!sd) {
+		dev_warn(&isys->adev->dev, "can't create new i2c subdev\n");
+		return -ENODEV;
+	}
+
+	return isys_complete_ext_device_registration(isys, sd, csi2);
+}
+
+static void isys_register_ext_subdevs(struct ici_isys *isys)
+{
+	struct ipu_isys_subdev_pdata *spdata = isys->pdata->spdata;
+	struct ipu_isys_subdev_info **sd_info;
+
+	if (spdata) {
+		/* Scan spdata first to possibly override ACPI data */
+		/* ACPI created devices */
+		for (sd_info = spdata->subdevs; *sd_info; sd_info++)
+			isys_register_ext_subdev(isys, *sd_info, true);
+
+		/* Scan non-acpi devices */
+		for (sd_info = spdata->subdevs; *sd_info; sd_info++)
+			isys_register_ext_subdev(isys, *sd_info, false);
+	} else {
+		dev_info(&isys->adev->dev, "no subdevice info provided\n");
+	}
+
+	/* Handle real ACPI stuff */
+	request_module("ipu4-acpi");
+	ipu_get_acpi_devices(isys, &isys->adev->dev,
+				    isys_acpi_add_device);
+}
+
+static void isys_unregister_subdevices(struct ici_isys *isys)
+{
+	const struct ipu_isys_internal_tpg_pdata *tpg =
+		&isys->pdata->ipdata->tpg;
+	const struct ipu_isys_internal_csi2_pdata *csi2 =
+		&isys->pdata->ipdata->csi2;
+	unsigned int i;
+
+    for (i = 0; i < NR_OF_CSI2_BE_SOC_STREAMS; i++) {
+		ici_isys_csi2_be_cleanup(&isys->ici_csi2_be[i]);
+	}
+
+	for (i = 0; i < tpg->ntpgs; i++) {
+		ici_isys_tpg_cleanup(&isys->ici_tpg[i]);
+	}
+
+	for (i = 0; i < csi2->nports; i++) {
+		ici_isys_csi2_cleanup(&isys->ici_csi2[i]);
+	}
+}
+
+static int isys_register_subdevices(struct ici_isys *isys)
+{
+	const struct ipu_isys_internal_tpg_pdata *tpg =
+		&isys->pdata->ipdata->tpg;
+	const struct ipu_isys_internal_csi2_pdata *csi2 =
+		&isys->pdata->ipdata->csi2;
+
+	unsigned int i, j, k;
+	int rval;
+
+	BUG_ON(csi2->nports > IPU_ISYS_MAX_CSI2_PORTS);
+	BUG_ON(tpg->ntpgs > 2);
+
+	for (i = 0; i < csi2->nports; i++) {
+		rval = ici_isys_csi2_init(
+			&isys->ici_csi2[i], isys,
+			isys->pdata->base + csi2->offsets[i], i);
+		if (rval)
+			goto fail;
+
+		isys->isr_csi2_bits |=
+				IPU_ISYS_UNISPART_IRQ_CSI2(i);
+	}
+
+	for (i = 0; i < tpg->ntpgs; i++) {
+		rval = ici_isys_tpg_init(&isys->ici_tpg[i], isys,
+				isys->pdata->base + tpg->offsets[i],
+				isys->pdata->base + tpg->sels[i], i);
+		if(rval)
+			goto fail;
+	}
+
+	for (i = 0; i < NR_OF_CSI2_BE_SOC_STREAMS; i++) {
+		rval = ici_isys_csi2_be_init(&isys->ici_csi2_be[i],
+				isys, i);
+		if (rval) {
+			goto fail;
+		}
+	}
+
+    for (i = 0; i < csi2->nports; i++) {
+        for (j = 0; j < NR_OF_CSI2_VC; j++ ) {
+            rval = node_pad_create_link(
+                    &isys->ici_csi2[i].asd[j].node, CSI2_ICI_PAD_SOURCE,
+                    &isys->ici_csi2_be[ICI_BE_RAW].asd.node,
+                    CSI2_BE_ICI_PAD_SINK, 0);
+            if (rval) {
+                dev_info(&isys->adev->dev,
+                        "can't create link between csi2 and csi2_be\n");
+                goto fail;
+            }
+
+            for (k = 1; k < NR_OF_CSI2_BE_SOC_STREAMS; k++ ) {
+				rval = node_pad_create_link(
+					&isys->ici_csi2[i].asd[j].node, CSI2_ICI_PAD_SOURCE,
+					&isys->ici_csi2_be[k].asd.node,
+					CSI2_BE_ICI_PAD_SINK, 0);
+				if (rval) {
+					dev_info(&isys->adev->dev,
+						"can't create link between csi2 and csi2_be soc\n");
+					goto fail;
+				}
+       		 	}
+		}
+	}
+
+	for (i = 0; i < tpg->ntpgs; i++) {
+		rval = node_pad_create_link(
+			&isys->ici_tpg[i].asd.node, TPG_PAD_SOURCE,
+			&isys->ici_csi2_be[ICI_BE_RAW].asd.node,
+			CSI2_BE_ICI_PAD_SINK, 0);
+		if (rval) {
+			dev_info(&isys->adev->dev,
+				"can't create link between tpg and csi2_be\n");
+			goto fail;
+		}
+
+        for (j = 1; j < NR_OF_CSI2_BE_SOC_STREAMS; j++) {
+		    rval = node_pad_create_link(
+			    &isys->ici_tpg[i].asd.node, TPG_PAD_SOURCE,
+			    &isys->ici_csi2_be[j].asd.node,
+			    CSI2_BE_ICI_PAD_SINK, 0);
+		    if (rval) {
+			    dev_info(&isys->adev->dev,
+			    	"can't create link between tpg and csi2_be soc\n");
+			    goto fail;
+		    }
+        }
+    }
+
+	return 0;
+
+fail:
+	isys_unregister_subdevices(isys);
+	return rval;
+}
+
+static int isys_register_devices(struct ici_isys *isys)
+{
+	int rval;
+
+/* Pipeline device registration */
+	DEBUGK("Pipeline device registering...\n");
+	rval = pipeline_device_register(&isys->pipeline_dev, isys);
+	if (rval < 0) {
+		dev_info(&isys->pipeline_dev.dev, "can't register pipeline device\n");
+		return rval;
+	}
+
+	rval = isys_register_subdevices(isys);
+	if (rval)
+		goto out_pipeline_device_unregister;
+
+	isys_register_ext_subdevs(isys);
+
+// Latest code structure doesnt do these functions.
+// let it remain to gaugae impact and then remove.
+#if 0
+	rval = isys_determine_legacy_csi_lane_configuration(isys);
+	if (rval)
+		goto out_isys_unregister_subdevices;
+
+	rval = isys_determine_csi_combo_lane_configuration(isys);
+	if (rval)
+		goto out_isys_unregister_subdevices;
+
+#ifndef CONFIG_PM
+	ipu_buttress_csi_port_config(isys->adev->isp,
+					    isys->legacy_port_cfg,
+					    isys->combo_port_cfg);
+#endif
+#endif
+	return 0;
+
+#if 0
+out_isys_unregister_subdevices:
+	isys_unregister_subdevices(isys);
+#endif
+out_pipeline_device_unregister:
+	pipeline_device_unregister(&isys->pipeline_dev);
+
+	return rval;
+}
+
+static void isys_unregister_devices(struct ici_isys *isys)
+{
+	pipeline_device_unregister(&isys->pipeline_dev);
+	DEBUGK("Pipeline device unregistered\n");
+	isys_unregister_subdevices(isys);
+}
+
+static void isys_setup_hw(struct ici_isys *isys)
+{
+	void __iomem *base = isys->pdata->base;
+	u32 irqs;
+	unsigned int i;
+
+	/* Enable irqs for all MIPI busses */
+	irqs = IPU_ISYS_UNISPART_IRQ_CSI2(0) |
+	       IPU_ISYS_UNISPART_IRQ_CSI2(1) |
+	       IPU_ISYS_UNISPART_IRQ_CSI2(2) |
+	       IPU_ISYS_UNISPART_IRQ_CSI2(3) |
+	       IPU_ISYS_UNISPART_IRQ_CSI2(4) |
+	       IPU_ISYS_UNISPART_IRQ_CSI2(5);
+
+	irqs |= IPU_ISYS_UNISPART_IRQ_SW;
+
+	writel(irqs, base + IPU_REG_ISYS_UNISPART_IRQ_EDGE);
+	writel(irqs, base + IPU_REG_ISYS_UNISPART_IRQ_LEVEL_NOT_PULSE);
+	writel(irqs, base + IPU_REG_ISYS_UNISPART_IRQ_CLEAR);
+	writel(irqs, base + IPU_REG_ISYS_UNISPART_IRQ_MASK);
+	writel(irqs, base + IPU_REG_ISYS_UNISPART_IRQ_ENABLE);
+
+	writel(0, base + IPU_REG_ISYS_UNISPART_SW_IRQ_REG);
+	writel(0, base + IPU_REG_ISYS_UNISPART_SW_IRQ_MUX_REG);
+
+	/* Write CDC FIFO threshold values for isys */
+	for (i = 0; i < isys->pdata->ipdata->hw_variant.cdc_fifos; i++)
+		writel(isys->pdata->ipdata->hw_variant.cdc_fifo_threshold[i],
+		       base + IPU_REG_ISYS_CDC_THRESHOLD(i));
+}
+
+#ifdef CONFIG_PM
+static int isys_runtime_pm_resume(struct device *dev)
+{
+	struct ipu_bus_device *adev = to_ipu_bus_device(dev);
+	struct ipu_device *isp = adev->isp;
+	struct ici_isys *isys = ipu_bus_get_drvdata(adev);
+	unsigned long flags;
+	int ret;
+
+	if (!isys) {
+		WARN(1, "%s called before probing. skipping.\n", __func__);
+		return 0;
+	}
+
+	ipu_trace_restore(dev);
+
+	pm_qos_update_request(&isys->pm_qos, ISYS_PM_QOS_VALUE);
+#if 0
+	ipu_buttress_csi_port_config(isp,
+					    isys->legacy_port_cfg,
+					    isys->combo_port_cfg);
+#endif
+	ret = ipu_buttress_start_tsc_sync(isp);
+	if (ret)
+		return ret;
+
+	spin_lock_irqsave(&isys->power_lock, flags);
+	isys->power = 1;
+	spin_unlock_irqrestore(&isys->power_lock, flags);
+
+	isys_setup_hw(isys);
+
+	return 0;
+}
+
+static int isys_runtime_pm_suspend(struct device *dev)
+{
+	struct ipu_bus_device *adev = to_ipu_bus_device(dev);
+	struct ici_isys *isys = ipu_bus_get_drvdata(adev);
+	unsigned long flags;
+
+	if (!isys) {
+		WARN(1, "%s called before probing. skipping.\n", __func__);
+		return 0;
+	}
+
+	spin_lock_irqsave(&isys->power_lock, flags);
+	isys->power = 0;
+	spin_unlock_irqrestore(&isys->power_lock, flags);
+
+	ipu_trace_stop(dev);
+	mutex_lock(&isys->mutex);
+	isys->reset_needed = false;
+	mutex_unlock(&isys->mutex);
+
+	pm_qos_update_request(&isys->pm_qos, PM_QOS_DEFAULT_VALUE);
+
+	return 0;
+}
+
+static int isys_suspend(struct device *dev)
+{
+	struct ipu_bus_device *adev = to_ipu_bus_device(dev);
+	struct ici_isys *isys = ipu_bus_get_drvdata(adev);
+
+	/* If stream is open, refuse to suspend */
+	if (isys->stream_opened)
+		return -EBUSY;
+
+	return 0;
+}
+
+static int isys_resume(struct device *dev)
+{
+	return 0;
+}
+
+static const struct dev_pm_ops isys_pm_ops = {
+	.runtime_suspend = isys_runtime_pm_suspend,
+	.runtime_resume = isys_runtime_pm_resume,
+	.suspend = isys_suspend,
+	.resume = isys_resume,
+};
+#define ISYS_PM_OPS (&isys_pm_ops)
+#else
+#define ISYS_PM_OPS NULL
+#endif
+
+static void isys_remove(struct ipu_bus_device *adev)
+{
+	struct ici_isys *isys = ipu_bus_get_drvdata(adev);
+	struct ipu_device *isp = adev->isp;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0)
+	struct dma_attrs attrs;
+#else
+	unsigned long attrs;
+#endif
+
+	dev_info(&adev->dev, "removed\n");
+	debugfs_remove_recursive(isys->debugfsdir);
+
+	ipu_trace_uninit(&adev->dev);
+	isys_unregister_devices(isys);
+	pm_qos_remove_request(&isys->pm_qos);
+
+	if (!isp->secure_mode) {
+		ipu_cpd_free_pkg_dir(adev, isys->pkg_dir,
+					    isys->pkg_dir_dma_addr,
+					    isys->pkg_dir_size);
+		ipu_buttress_unmap_fw_image(adev, &isys->fw_sgt);
+		release_firmware(isys->fw);
+	}
+
+	mutex_destroy(&isys->stream_mutex);
+	mutex_destroy(&isys->mutex);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0)
+	init_dma_attrs(&attrs);
+	dma_set_attr(DMA_ATTR_NON_CONSISTENT, &attrs);
+	dma_free_attrs(&adev->dev,
+		IPU_ISYS_SHORT_PACKET_TRACE_BUFFER_SIZE,
+		isys->short_packet_trace_buffer,
+		isys->short_packet_trace_buffer_dma_addr, &attrs);
+#else
+	attrs = DMA_ATTR_NON_CONSISTENT;
+	dma_free_attrs(&adev->dev,
+		IPU_ISYS_SHORT_PACKET_TRACE_BUFFER_SIZE,
+		isys->short_packet_trace_buffer,
+		isys->short_packet_trace_buffer_dma_addr, attrs);
+#endif
+}
+
+static int intel_ipu4_isys_icache_prefetch_get(void *data, u64 *val)
+{
+	struct ici_isys *isys = data;
+
+	*val = isys->icache_prefetch;
+	return 0;
+}
+
+static int intel_ipu4_isys_icache_prefetch_set(void *data, u64 val)
+{
+	struct ici_isys *isys = data;
+
+	if (val != !!val)
+		return -EINVAL;
+
+	isys->icache_prefetch = val;
+
+	return 0;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(isys_icache_prefetch_fops,
+			intel_ipu4_isys_icache_prefetch_get,
+			intel_ipu4_isys_icache_prefetch_set,
+			"%llu\n");
+
+static int intel_ipu4_isys_init_debugfs(struct ici_isys *isys)
+{
+	struct dentry *file;
+	struct dentry *dir;
+
+	dir = debugfs_create_dir("isys", isys->adev->isp->ipu_dir);
+	if (IS_ERR(dir))
+		return -ENOMEM;
+
+	file = debugfs_create_file("icache_prefetch", S_IRUSR | S_IWUSR,
+				   dir, isys,
+				   &isys_icache_prefetch_fops);
+	if (IS_ERR(file))
+		goto err;
+
+	isys->debugfsdir = dir;
+
+	return 0;
+err:
+	debugfs_remove_recursive(dir);
+	return -ENOMEM;
+}
+
+static int alloc_fw_msg_buffers(struct ici_isys *isys, int amount)
+{
+        dma_addr_t dma_addr;
+        struct isys_fw_msgs *addr;
+        unsigned int i;
+        unsigned long flags;
+
+        for (i = 0; i < amount; i++) {
+                addr = dma_alloc_attrs(&isys->adev->dev,
+                                       sizeof(struct isys_fw_msgs),
+                                       &dma_addr, GFP_KERNEL,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0)
+                                       NULL
+#else
+                                       0
+#endif
+                    );
+                if (!addr)
+                        break;
+                addr->dma_addr = dma_addr;
+
+                spin_lock_irqsave(&isys->listlock, flags);
+                list_add(&addr->head, &isys->framebuflist);
+                spin_unlock_irqrestore(&isys->listlock, flags);
+        }
+        if (i == amount)
+                return 0;
+        spin_lock_irqsave(&isys->listlock, flags);
+        while (!list_empty(&isys->framebuflist)) {
+                addr = list_first_entry(&isys->framebuflist,
+                                        struct isys_fw_msgs, head);
+                list_del(&addr->head);
+                spin_unlock_irqrestore(&isys->listlock, flags);
+                dma_free_attrs(&isys->adev->dev,
+                               sizeof(struct isys_fw_msgs),
+                               addr, addr->dma_addr,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0)
+                               NULL
+#else
+                               0
+#endif
+                    );
+                spin_lock_irqsave(&isys->listlock, flags);
+        }
+        spin_unlock_irqrestore(&isys->listlock, flags);
+        return -ENOMEM;
+}
+
+static int isys_probe(struct ipu_bus_device *adev)
+{
+	struct ipu_mmu *mmu = dev_get_drvdata(adev->iommu);
+	struct ici_isys *isys;
+	struct ipu_device *isp = adev->isp;
+	const struct firmware *uninitialized_var(fw);
+	int rval = 0;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0)
+	struct dma_attrs attrs;
+#else
+	unsigned long attrs;
+#endif
+
+	trace_printk("B|%d|TMWK\n", current->pid);
+
+	/* Has the domain been attached? */
+	if (!mmu || !isp->pkg_dir_dma_addr) {
+		trace_printk("E|TMWK\n");
+		return -EPROBE_DEFER;
+	}
+
+	isys = devm_kzalloc(&adev->dev, sizeof(*isys), GFP_KERNEL);
+	if (!isys) {
+		trace_printk("E|TMWK\n");
+		return -ENOMEM;
+	}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0)
+	init_dma_attrs(&attrs);
+	dma_set_attr(DMA_ATTR_NON_CONSISTENT, &attrs);
+	isys->short_packet_trace_buffer = dma_alloc_attrs(&adev->dev,
+		IPU_ISYS_SHORT_PACKET_TRACE_BUFFER_SIZE,
+		&isys->short_packet_trace_buffer_dma_addr, GFP_KERNEL, &attrs);
+#else
+	attrs = DMA_ATTR_NON_CONSISTENT;
+	isys->short_packet_trace_buffer = dma_alloc_attrs(&adev->dev,
+		IPU_ISYS_SHORT_PACKET_TRACE_BUFFER_SIZE,
+		&isys->short_packet_trace_buffer_dma_addr, GFP_KERNEL, attrs);
+#endif
+	if (!isys->short_packet_trace_buffer)
+		return -ENOMEM;
+
+	isys->adev = adev;
+	isys->pdata = adev->pdata;
+
+	INIT_LIST_HEAD(&isys->requests);
+
+	spin_lock_init(&isys->lock);
+	spin_lock_init(&isys->power_lock);
+	isys->power = 0;
+
+	mutex_init(&isys->mutex);
+	mutex_init(&isys->stream_mutex);
+	mutex_init(&isys->lib_mutex);
+
+        spin_lock_init(&isys->listlock);
+        INIT_LIST_HEAD(&isys->framebuflist);
+        INIT_LIST_HEAD(&isys->framebuflist_fw);
+
+	dev_info(&adev->dev, "isys probe %p %p\n", adev, &adev->dev);
+	ipu_bus_set_drvdata(adev, isys);
+
+	isys->line_align = IPU_ISYS_2600_MEM_LINE_ALIGN;
+	isys->icache_prefetch = is_ipu_hw_bxtp_e0(isp);
+
+#ifndef CONFIG_PM
+	isys_setup_hw(isys);
+#endif
+
+	if (!isp->secure_mode) {
+		fw = isp->cpd_fw;
+
+		rval = ipu_buttress_map_fw_image(
+			adev, fw, &isys->fw_sgt);
+		if (rval)
+			goto release_firmware;
+
+		isys->pkg_dir = ipu_cpd_create_pkg_dir(
+			adev, isp->cpd_fw->data,
+			sg_dma_address(isys->fw_sgt.sgl),
+			&isys->pkg_dir_dma_addr,
+			&isys->pkg_dir_size);
+		if (isys->pkg_dir == NULL) {
+			rval = -ENOMEM;
+			goto  remove_shared_buffer;
+		}
+	}
+
+	/* Debug fs failure is not fatal. */
+	intel_ipu4_isys_init_debugfs(isys);
+
+	ipu_trace_init(adev->isp, isys->pdata->base, &adev->dev,
+			      isys_trace_blocks);
+
+	pm_qos_add_request(&isys->pm_qos, PM_QOS_CPU_DMA_LATENCY,
+			PM_QOS_DEFAULT_VALUE);
+
+        alloc_fw_msg_buffers(isys, 20);
+
+	pm_runtime_allow(&adev->dev);
+	pm_runtime_enable(&adev->dev);
+
+	rval = isys_register_devices(isys);
+	if (rval)
+		goto out_remove_pkg_dir_shared_buffer;
+
+	trace_printk("E|TMWK\n");
+	return 0;
+
+out_remove_pkg_dir_shared_buffer:
+	if (!isp->secure_mode)
+		ipu_cpd_free_pkg_dir(adev, isys->pkg_dir,
+					    isys->pkg_dir_dma_addr,
+					    isys->pkg_dir_size);
+remove_shared_buffer:
+	if (!isp->secure_mode)
+		ipu_buttress_unmap_fw_image(
+			adev, &isys->fw_sgt);
+release_firmware:
+	if (!isp->secure_mode)
+		release_firmware(isys->fw);
+	ipu_trace_uninit(&adev->dev);
+
+	trace_printk("E|TMWK\n");
+
+	mutex_destroy(&isys->mutex);
+	mutex_destroy(&isys->stream_mutex);
+	mutex_destroy(&isys->lib_mutex);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 8, 0)
+	dma_free_attrs(&adev->dev,
+		IPU_ISYS_SHORT_PACKET_TRACE_BUFFER_SIZE,
+		isys->short_packet_trace_buffer,
+		isys->short_packet_trace_buffer_dma_addr, &attrs);
+#else
+        dma_free_attrs(&adev->dev,
+                IPU_ISYS_SHORT_PACKET_TRACE_BUFFER_SIZE,
+                isys->short_packet_trace_buffer,
+                isys->short_packet_trace_buffer_dma_addr, attrs);
+#endif
+	return rval;
+}
+
+struct fwmsg {
+	int type;
+	char *msg;
+	bool valid_ts;
+};
+
+static const struct fwmsg fw_msg[] = {
+	{ IA_CSS_ISYS_RESP_TYPE_STREAM_OPEN_DONE,    "STREAM_OPEN_DONE", 0 },
+	{ IA_CSS_ISYS_RESP_TYPE_STREAM_CLOSE_ACK,    "STREAM_CLOSE_ACK", 0 },
+	{ IA_CSS_ISYS_RESP_TYPE_STREAM_START_ACK,    "STREAM_START_ACK", 0 },
+	{ IA_CSS_ISYS_RESP_TYPE_STREAM_START_AND_CAPTURE_ACK,
+	  "STREAM_START_AND_CAPTURE_ACK", 0 },
+	{ IA_CSS_ISYS_RESP_TYPE_STREAM_STOP_ACK,     "STREAM_STOP_ACK", 0 },
+	{ IA_CSS_ISYS_RESP_TYPE_STREAM_FLUSH_ACK,    "STREAM_FLUSH_ACK", 0 },
+	{ IA_CSS_ISYS_RESP_TYPE_PIN_DATA_READY,      "PIN_DATA_READY", 1 },
+	{ IA_CSS_ISYS_RESP_TYPE_STREAM_CAPTURE_ACK,  "STREAM_CAPTURE_ACK", 0 },
+	{ IA_CSS_ISYS_RESP_TYPE_STREAM_START_AND_CAPTURE_DONE,
+	  "STREAM_START_AND_CAPTURE_DONE", 1 },
+	{ IA_CSS_ISYS_RESP_TYPE_STREAM_CAPTURE_DONE, "STREAM_CAPTURE_DONE", 1 },
+	{ IA_CSS_ISYS_RESP_TYPE_FRAME_SOF,           "FRAME_SOF", 1 },
+	{ IA_CSS_ISYS_RESP_TYPE_FRAME_EOF,           "FRAME_EOF", 1 },
+	{ -1, "UNKNOWN MESSAGE", 0 },
+};
+
+static int resp_type_to_index(int type)
+{
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(fw_msg); i++)
+		if (fw_msg[i].type == type)
+			return i;
+
+	return i - 1;
+}
+
+
+static u64 extract_time_from_short_packet_msg(
+			struct ici_isys_csi2_monitor_message *msg)
+
+{
+	u64 time_h = msg->timestamp_h << 14;
+	u64 time_l = msg->timestamp_l;
+	u64 time_h_ovl = time_h & 0xc000;
+	u64 time_h_h = time_h & (~0xffff);
+
+	/* Fix possible roll overs. */
+	if (time_h_ovl >= (time_l & 0xc000))
+		return time_h_h | time_l;
+	else
+		return (time_h_h - 0x10000) | time_l;
+}
+static u64 tunit_time_to_us(struct ici_isys *isys, u64 time)
+{
+	struct ipu_bus_device *adev =
+			to_ipu_bus_device(isys->adev->iommu);
+	u64 isys_clk = IS_FREQ_SOURCE / adev->ctrl->divisor / 1000000;
+	return time / isys_clk;
+}
+
+static u64 tsc_time_to_tunit_time(struct ici_isys *isys,
+			u64 tsc_base, u64 tunit_base, u64 tsc_time)
+{
+	struct ipu_bus_device *adev =
+			to_ipu_bus_device(isys->adev->iommu);
+	u64 isys_clk = IS_FREQ_SOURCE / adev->ctrl->divisor / 100000;
+	u64 tsc_clk = IPU_BUTTRESS_TSC_CLK / 100000;
+
+	return (tsc_time - tsc_base) * isys_clk / tsc_clk + tunit_base;
+}
+
+static int isys_isr_one_ici(struct ipu_bus_device *adev)
+{
+	struct ici_isys *isys = ipu_bus_get_drvdata(adev);
+	struct ia_css_isys_resp_info resp;
+	struct ici_isys_pipeline *pipe;
+	u64 ts;
+	int rval;
+	unsigned int i;
+
+	if (!isys->fwcom)
+		return 0;
+
+	rval = ipu_lib_call_notrace_unlocked(stream_handle_response,
+						    isys, &resp);
+	if (rval < 0)
+		return rval;
+
+	ts = (u64)resp.timestamp[1] << 32 | resp.timestamp[0];
+
+
+	if (resp.error == IA_CSS_ISYS_ERROR_STREAM_IN_SUSPENSION)
+		/* Suspension is kind of special case: not enough buffers */
+		dev_dbg(&adev->dev,
+			"hostlib: error resp %02d %s, stream %u, error SUSPENSION, details %d, timestamp 0x%16.16llx, pin %d\n",
+			resp.type,
+			fw_msg[resp_type_to_index(resp.type)].msg,
+			resp.stream_handle,
+			resp.error_details,
+			fw_msg[resp_type_to_index(resp.type)].valid_ts ?
+			ts : 0, resp.pin_id);
+	else if (resp.error)
+		dev_dbg(&adev->dev,
+			"hostlib: error resp %02d %s, stream %u, error %d, details %d, timestamp 0x%16.16llx, pin %d\n",
+			resp.type,
+			fw_msg[resp_type_to_index(resp.type)].msg,
+			resp.stream_handle,
+			resp.error, resp.error_details,
+			fw_msg[resp_type_to_index(resp.type)].valid_ts ?
+			ts : 0, resp.pin_id);
+	else
+		dev_dbg(&adev->dev,
+			"hostlib: resp %02d %s, stream %u, timestamp 0x%16.16llx, pin %d\n",
+			resp.type,
+			fw_msg[resp_type_to_index(resp.type)].msg,
+			resp.stream_handle,
+			fw_msg[resp_type_to_index(resp.type)].valid_ts ?
+			ts : 0, resp.pin_id);
+
+	if (resp.stream_handle >= INTEL_IPU4_ISYS_MAX_STREAMS) {
+		dev_err(&adev->dev, "bad stream handle %u\n",
+			resp.stream_handle);
+		return 0;
+	}
+
+	pipe = isys->ici_pipes[resp.stream_handle];
+	if (!pipe) {
+		dev_err(&adev->dev, "no pipeline for stream %u\n",
+			resp.stream_handle);
+		return 0;
+	}
+	pipe->error = resp.error;
+
+	switch (resp.type) {
+	case IA_CSS_ISYS_RESP_TYPE_STREAM_OPEN_DONE:
+		complete(&pipe->stream_open_completion);
+		break;
+	case IA_CSS_ISYS_RESP_TYPE_STREAM_CLOSE_ACK:
+		complete(&pipe->stream_close_completion);
+		break;
+	case IA_CSS_ISYS_RESP_TYPE_STREAM_START_ACK:
+		complete(&pipe->stream_start_completion);
+		break;
+	case IA_CSS_ISYS_RESP_TYPE_STREAM_START_AND_CAPTURE_ACK:
+		complete(&pipe->stream_start_completion);
+		break;
+	case IA_CSS_ISYS_RESP_TYPE_STREAM_STOP_ACK:
+		complete(&pipe->stream_stop_completion);
+		break;
+	case IA_CSS_ISYS_RESP_TYPE_STREAM_FLUSH_ACK:
+		complete(&pipe->stream_stop_completion);
+		break;
+	case IA_CSS_ISYS_RESP_TYPE_PIN_DATA_READY:
+		if (resp.pin_id <  IPU_ISYS_OUTPUT_PINS &&
+		    pipe->output_pins[resp.pin_id].pin_ready)
+			pipe->output_pins[resp.pin_id].pin_ready(pipe, &resp);
+		else
+			dev_err(&adev->dev,
+				"%d:No data pin ready handler for pin id %d\n",
+				resp.stream_handle, resp.pin_id);
+		break;
+	case IA_CSS_ISYS_RESP_TYPE_STREAM_CAPTURE_ACK:
+		complete(&pipe->capture_ack_completion);
+		break;
+	case IA_CSS_ISYS_RESP_TYPE_STREAM_START_AND_CAPTURE_DONE:
+	case IA_CSS_ISYS_RESP_TYPE_STREAM_CAPTURE_DONE:
+
+		if(pipe->interlaced && pipe->short_packet_source ==
+            IPU_ISYS_SHORT_PACKET_FROM_TUNIT) {
+			unsigned int i = pipe->short_packet_trace_index;
+			bool msg_matched = false;
+			unsigned int monitor_id;
+
+			if(pipe->csi2->index>=	IPU_ISYS_MAX_CSI2_LEGACY_PORTS)
+				monitor_id = TRACE_REG_CSI2_3PH_TM_MONITOR_ID;
+			else
+				monitor_id = TRACE_REG_CSI2_TM_MONITOR_ID;
+
+			dma_sync_single_for_cpu(&isys->adev->dev,
+				isys->short_packet_trace_buffer_dma_addr,
+				IPU_ISYS_SHORT_PACKET_TRACE_BUFFER_SIZE,
+				DMA_BIDIRECTIONAL);
+
+			do {
+				struct ici_isys_csi2_monitor_message msg =	isys->short_packet_trace_buffer[i];
+				u64 sof_time = tsc_time_to_tunit_time(isys,
+					isys->tsc_timer_base, isys->tunit_timer_base,
+					(u64) resp.timestamp[1] << 32 | resp.timestamp[0]);
+				u64 trace_time = extract_time_from_short_packet_msg(&msg);
+				u64 delta_time_us = tunit_time_to_us(isys,
+					(sof_time > trace_time) ?
+					sof_time - trace_time :
+					trace_time - sof_time);
+
+				i = (i + 1) % IPU_ISYS_SHORT_PACKET_TRACE_MSG_NUMBER;
+				if (msg.cmd == TRACE_REG_CMD_TYPE_D64MTS &&
+				    msg.monitor_id == monitor_id &&
+				    msg.fs == 1 &&
+				    msg.port == pipe->csi2->index &&
+				    msg.vc == pipe->vc &&
+				    delta_time_us < IPU_ISYS_SHORT_PACKET_TRACE_MAX_TIMESHIFT) {
+					    pipe->cur_field = (msg.sequence % 2) ?
+                            ICI_FIELD_TOP : ICI_FIELD_BOTTOM;
+					    pipe->short_packet_trace_index = i;
+					    msg_matched = true;
+					    dev_dbg(&isys->adev->dev,"Interlaced field ready. field = %d\n",
+                            pipe->cur_field);
+					break;
+				}
+			} while (i != pipe->short_packet_trace_index);
+
+			if (!msg_matched)
+			/* We have walked through the whole buffer. */
+				dev_dbg(&isys->adev->dev,"No matched trace message found.\n");
+		}
+
+		for (i = 0; i < INTEL_IPU4_NUM_CAPTURE_DONE; i++)
+			if (pipe->capture_done[i])
+				pipe->capture_done[i](pipe, &resp);
+		break;
+	case IA_CSS_ISYS_RESP_TYPE_FRAME_SOF:
+		break;
+	case IA_CSS_ISYS_RESP_TYPE_FRAME_EOF:
+		break;
+	default:
+		dev_err(&adev->dev, "%d:unknown response type %u\n",
+			resp.stream_handle, resp.type);
+		break;
+	}
+
+	return 0;
+}
+
+static irqreturn_t isys_isr(struct ipu_bus_device *adev)
+{
+	struct ici_isys *isys = ipu_bus_get_drvdata(adev);
+	void __iomem *base = isys->pdata->base;
+	u32 status;
+
+	spin_lock(&isys->power_lock);
+	if (!isys->power) {
+		spin_unlock(&isys->power_lock);
+		return IRQ_NONE;
+	}
+
+	status = readl(isys->pdata->base +
+		       IPU_REG_ISYS_UNISPART_IRQ_STATUS);
+	do {
+		writel(status, isys->pdata->base +
+		       IPU_REG_ISYS_UNISPART_IRQ_CLEAR);
+
+		if (isys->isr_csi2_bits & status) {
+			unsigned int i;
+
+			for (i = 0; i < isys->pdata->ipdata->csi2.nports; i++) {
+				if (status &
+				 IPU_ISYS_UNISPART_IRQ_CSI2(i)){
+
+				    ici_isys_csi2_isr(
+						&isys->ici_csi2[i]);
+				}
+			}
+		}
+
+		writel(0, base + IPU_REG_ISYS_UNISPART_SW_IRQ_REG);
+
+		/*
+		 * Handle a single FW event per checking the CSI-2
+		 * receiver SOF status. This is done in order to avoid
+		 * the case where events arrive to the event queue and
+		 * one of them is a SOF event which then could be
+		 * handled before the SOF interrupt. This would pose
+		 * issues in sequence numbering which is based on SOF
+		 * interrupts, always assumed to arrive before FW SOF
+		 * events.
+		 */
+		if (status & IPU_ISYS_UNISPART_IRQ_SW &&
+		    !isys_isr_one_ici(adev))
+			status = IPU_ISYS_UNISPART_IRQ_SW;
+		else
+			status = 0;
+
+		status |= readl(isys->pdata->base +
+				IPU_REG_ISYS_UNISPART_IRQ_STATUS);
+	} while (status & (isys->isr_csi2_bits
+			   | IPU_ISYS_UNISPART_IRQ_SW));
+
+	spin_unlock(&isys->power_lock);
+	return IRQ_HANDLED;
+}
+
+static void isys_isr_poll_ici(struct ipu_bus_device *adev)
+{
+	struct ici_isys *isys = ipu_bus_get_drvdata(adev);
+
+	if (!isys->fwcom) {
+		dev_dbg(&isys->adev->dev,
+			"got interrupt but device not configured yet\n");
+		return;
+	}
+
+	while (!isys_isr_one_ici(adev));
+}
+
+int intel_ipu4_isys_isr_run_ici(void *ptr)
+{
+	struct ici_isys *isys = ptr;
+
+	while (!kthread_should_stop()) {
+		usleep_range(500, 1000);
+		if (isys->ici_stream_opened)
+			isys_isr_poll_ici(isys->adev);
+	}
+
+	return 0;
+}
+
+static struct ipu_bus_driver isys_driver = {
+	.probe = isys_probe,
+	.remove = isys_remove,
+	.isr = isys_isr,
+	.wanted = IPU_ISYS_NAME,
+	.drv = {
+		.name = IPU_ISYS_NAME,
+		.owner = THIS_MODULE,
+		.pm = ISYS_PM_OPS,
+	},
+};
+
+module_ipu_bus_driver(isys_driver);
+
+MODULE_AUTHOR("Scott Kennedy <scottx.m.kennedy@intel.com>");
+MODULE_AUTHOR("Marcin Mozejko <marcinx.mozejko@intel.com>");
+MODULE_AUTHOR("Sakari Ailus <sakari.ailus@linux.intel.com>");
+MODULE_AUTHOR("Samu Onkalo <samu.onkalo@intel.com>");
+MODULE_AUTHOR("Jouni Hgander <jouni.hogander@intel.com>");
+MODULE_AUTHOR("Jouni Ukkonen <jouni.ukkonen@intel.com>");
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_DESCRIPTION("Intel intel_ipu4 ici input system driver");
+
+#endif /* ICI_ENABLED */
+
diff --git a/drivers/media/pci/intel/ici/ici-isys.h b/drivers/media/pci/intel/ici/ici-isys.h
new file mode 100644
index 0000000..ffd21a9
--- /dev/null
+++ b/drivers/media/pci/intel/ici/ici-isys.h
@@ -0,0 +1,212 @@
+/* SPDX-License-Identifier: (BSD-3-Clause OR GPL-2.0) */
+/*
+ * Copyright (C) 2018 Intel Corporation
+ */
+
+#ifndef ICI_ISYS_H
+#define ICI_ISYS_H
+
+#define ICI_ENABLED
+
+#ifdef ICI_ENABLED
+#define IPU4_DEBUG
+
+#include <linux/pm_qos.h>
+#include <linux/spinlock.h>
+
+#include "ipu.h"
+#include "ipu-pdata.h"
+#include "ipu-fw-isys.h"
+#include "ici-fw-isys.h"
+#include "ici-isys-stream.h"
+#include "ici-isys-csi2.h"
+#include "ici-isys-csi2-be.h"
+#include "ici-isys-pipeline-device.h"
+#include "ici-isys-tpg.h"
+#include "ipu-platform.h"
+#include "ipu4/ipu-platform-isys.h"
+#include "ipu4/ipu-platform-regs.h"
+
+#define IPU_ISYS_ENTITY_PREFIX		"Intel IPU4"
+
+#define IPU_ISYS_2600_MEM_LINE_ALIGN	64
+
+#define IPU_ISYS_MAX_CSI2_PORTS IPU_ISYS_MAX_CSI2_LEGACY_PORTS+IPU_ISYS_MAX_CSI2_COMBO_PORTS
+/* for TPG */
+#define INTEL_IPU4_ISYS_FREQ_BXT_FPGA		25000000UL
+#define INTEL_IPU4_ISYS_FREQ_BXT		533000000UL
+
+#define IPU_ISYS_SIZE_RECV_QUEUE 40
+#define IPU_ISYS_SIZE_SEND_QUEUE 40
+#define IPU_ISYS_NUM_RECV_QUEUE 1
+
+/*
+ * Device close takes some time from last ack message to actual stopping
+ * of the SP processor. As long as the SP processor runs we can't proceed with
+ * clean up of resources.
+ */
+#define IPU_ISYS_OPEN_TIMEOUT_US		1000
+#define IPU_ISYS_OPEN_RETRY		1000
+#define IPU_ISYS_TURNOFF_DELAY_US		1000
+#define IPU_ISYS_TURNOFF_TIMEOUT		1000
+#define IPU_LIB_CALL_TIMEOUT_MS		2000
+#define IPU_LIB_CALL_TIMEOUT_JIFFIES \
+	msecs_to_jiffies(IPU_LIB_CALL_TIMEOUT_MS)
+
+#define INTEL_IPU4_ISYS_CSI2_LONG_PACKET_HEADER_SIZE	32
+#define INTEL_IPU4_ISYS_CSI2_LONG_PACKET_FOOTER_SIZE	32
+
+/*
+ * For B0/1: FW support max 6 streams
+ */
+#define INTEL_IPU4_ISYS_MAX_STREAMS		6
+
+
+#define IPU_ISYS_MIN_WIDTH		1U
+#define IPU_ISYS_MIN_HEIGHT		1U
+#define IPU_ISYS_MAX_WIDTH		16384U
+#define IPU_ISYS_MAX_HEIGHT		16384U
+
+struct task_struct;
+
+/*
+ * struct ici_isys
+ *
+ * @media_dev: Media device
+ * @v4l2_dev: V4L2 device
+ * @adev: ISYS ipu4 bus device
+ * @power: Is ISYS powered on or not?
+ * @isr_bits: Which bits does the ISR handle?
+ * @power_lock: Serialise access to power (power state in general)
+ * @lock: serialise access to pipes
+ * @pipes: pipelines per stream ID
+ * @fwcom: fwcom library private pointer
+ * @line_align: line alignment in memory
+ * @legacy_port_cfg: lane mappings for legacy CSI-2 ports
+ * @combo_port_cfg: lane mappings for D/C-PHY ports
+ * @isr_thread: for polling for events if interrupt delivery isn't available
+ * @reset_needed: Isys requires d0i0->i3 transition
+ * @video_opened: total number of opened file handles on video nodes
+ * @mutex: serialise access isys video open/release related operations
+ * @stream_mutex: serialise stream start and stop, queueing requests
+ * @pdata: platform data pointer
+ * @csi2: CSI-2 receivers
+ * @tpg: test pattern generators
+ * @csi2_be: CSI-2 back-ends
+ * @isa: Input system accelerator
+ * @fw: ISYS firmware binary (unsecure firmware)
+ * @fw_sgt: fw scatterlist
+ * @pkg_dir: host pointer to pkg_dir
+ * @pkg_dir_dma_addr: I/O virtual address for pkg_dir
+ * @pkg_dir_size: size of pkg_dir in bytes
+ */
+struct ici_isys {
+	struct ipu_bus_device *adev;
+
+	int power;
+	spinlock_t power_lock;
+	u32 isr_csi2_bits;
+	spinlock_t lock;
+	struct ipu_isys_pipeline *pipes[IPU_ISYS_MAX_STREAMS];
+	void *fwcom;
+	unsigned int line_align;
+	u32 legacy_port_cfg;
+	u32 combo_port_cfg;
+	struct task_struct *isr_thread;
+	bool reset_needed;
+	bool icache_prefetch;
+	unsigned int video_opened;
+	unsigned int stream_opened;
+	struct dentry *debugfsdir;
+	struct mutex mutex;
+	struct mutex stream_mutex;
+	struct mutex lib_mutex;
+
+	struct ipu_isys_pdata *pdata;
+
+	struct ici_isys_pipeline_device pipeline_dev;
+
+	struct ici_isys_pipeline *ici_pipes[IPU_ISYS_MAX_STREAMS];
+	struct ici_isys_csi2 ici_csi2[IPU_ISYS_MAX_CSI2_PORTS];
+	struct ici_isys_tpg ici_tpg[2]; // TODO map to a macro
+	struct ici_isys_csi2_be ici_csi2_be[NR_OF_CSI2_BE_SOC_STREAMS];
+	unsigned int ici_stream_opened;
+
+	const struct firmware *fw;
+	struct sg_table fw_sgt;
+
+	u64 *pkg_dir;
+	dma_addr_t pkg_dir_dma_addr;
+	unsigned pkg_dir_size;
+
+	struct list_head requests;
+	struct pm_qos_request pm_qos;
+	struct ici_isys_csi2_monitor_message *short_packet_trace_buffer;
+	dma_addr_t short_packet_trace_buffer_dma_addr;
+	u64 tsc_timer_base;
+	u64 tunit_timer_base;
+        spinlock_t listlock;    /* Protect framebuflist */
+        struct list_head framebuflist;
+        struct list_head framebuflist_fw;
+};
+
+int intel_ipu4_isys_isr_run_ici(void *ptr);
+
+struct isys_fw_msgs {
+        union {
+                u64 dummy;
+                struct ipu_fw_isys_frame_buff_set_abi frame;
+                struct ipu_fw_isys_stream_cfg_data_abi stream;
+        } fw_msg;
+        struct list_head head;
+        dma_addr_t dma_addr;
+};
+
+#define ipu_lib_call_notrace_unlocked(func, isys, ...)		\
+	({								\
+		 int rval;						\
+									\
+		 rval = -ia_css_isys_##func((isys)->fwcom, ##__VA_ARGS__);\
+									\
+		 rval;							\
+	})
+
+#define ipu_lib_call_notrace(func, isys, ...)			\
+	({								\
+		 int rval;						\
+									\
+		 mutex_lock(&(isys)->lib_mutex);			\
+									\
+		 rval = ipu_lib_call_notrace_unlocked(		\
+			 func, isys, ##__VA_ARGS__);			\
+									\
+		 mutex_unlock(&(isys)->lib_mutex);			\
+									\
+		 rval;							\
+	})
+
+#define ipu_lib_call(func, isys, ...)				\
+	({								\
+		 int rval;						\
+		 dev_dbg(&(isys)->adev->dev, "hostlib: libcall %s\n", #func);\
+		 rval = ipu_lib_call_notrace(func, isys, ##__VA_ARGS__);\
+									\
+		 rval;							\
+	})
+
+#undef DEBUGK
+#ifdef IPU4_DEBUG /* Macro for printing debug infos */
+#	ifdef __KERNEL__	/* for kernel space */
+#		define DEBUGK(fmt, args...) printk(KERN_DEBUG "IPU4: " fmt, ## args)
+#	else				/* for user space */
+#		define DEBUGK(fmt, args...) fprintf(stderr, fmt, ## args)
+#	endif
+#else /* no debug prints */
+#	define DEBUGK(fmt, args...)
+#endif
+
+#else /* ICI_ENABLED */
+#pragma message "IPU ICI version is DISABLED."
+#endif /* ICI_ENABLED */
+
+#endif /* ICI_ISYS_H */
diff --git a/drivers/media/pci/intel/ici/libintel-ipu4_ici.c b/drivers/media/pci/intel/ici/libintel-ipu4_ici.c
new file mode 100644
index 0000000..6858437
--- /dev/null
+++ b/drivers/media/pci/intel/ici/libintel-ipu4_ici.c
@@ -0,0 +1,403 @@
+// SPDX-License_Identifier: GPL-2.0
+// Copyright (C) 2014 - 2018 Intel Corporation
+
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include "ici/ici-isys.h"
+#include "ipu-wrapper.h"
+#include <ia_css_isysapi.h>
+
+#include "ipu-platform.h"
+
+#define ipu_lib_call_notrace_unlocked(func, isys, ...)		\
+	({								\
+		int rval;						\
+									\
+		rval = -ia_css_isys_##func((isys)->fwcom, ##__VA_ARGS__); \
+									\
+		rval;							\
+	})
+
+#define ipu_lib_call_notrace(func, isys, ...)		\
+	({							\
+		int rval;					\
+								\
+		mutex_lock(&(isys)->lib_mutex);			\
+								\
+		rval = ipu_lib_call_notrace_unlocked(	\
+			func, isys, ##__VA_ARGS__);		\
+								\
+		mutex_unlock(&(isys)->lib_mutex);		\
+								\
+		rval;						\
+	})
+
+#define ipu_lib_call(func, isys, ...)				\
+	({								\
+		int rval;						\
+		dev_dbg(&(isys)->adev->dev, "hostlib: libcall %s\n", #func); \
+		rval = ipu_lib_call_notrace(func, isys, ##__VA_ARGS__); \
+									\
+		rval;							\
+	})
+
+static int wrapper_init_done;
+
+int ici_fw_isys_close(struct ici_isys *isys)
+{
+	struct device *dev = &isys->adev->dev;
+	int timeout = IPU_ISYS_TURNOFF_TIMEOUT;
+	int rval;
+	unsigned long flags;
+
+	/*
+	 * Ask library to stop the isys fw. Actual close takes
+	 * some time as the FW must stop its actions including code fetch
+	 * to SP icache.
+	 */
+	spin_lock_irqsave(&isys->power_lock, flags);
+	rval = ipu_lib_call(device_close, isys);
+	spin_unlock_irqrestore(&isys->power_lock, flags);
+	if (rval)
+		dev_err(dev, "Device close failure: %d\n", rval);
+
+	/* release probably fails if the close failed. Let's try still */
+	do {
+		usleep_range(IPU_ISYS_TURNOFF_DELAY_US,
+				2 * IPU_ISYS_TURNOFF_DELAY_US);
+		rval = ipu_lib_call_notrace(device_release, isys, 0);
+		timeout--;
+	} while (rval != 0 && timeout);
+
+	/* Spin lock to wait the interrupt handler to be finished */
+	spin_lock_irqsave(&isys->power_lock, flags);
+	if (!rval)
+		isys->fwcom = NULL; /* No further actions needed */
+	else
+		dev_err(dev, "Device release time out %d\n", rval);
+	spin_unlock_irqrestore(&isys->power_lock, flags);
+	return rval;
+}
+EXPORT_SYMBOL_GPL(ici_fw_isys_close);
+
+int ici_fw_isys_init(struct ici_isys *isys,
+					unsigned int num_streams)
+{
+	int retry = IPU_ISYS_OPEN_RETRY;
+	unsigned int i;
+
+	struct ia_css_isys_device_cfg_data isys_cfg = {
+		.driver_sys = {
+			.ssid = ISYS_SSID,
+			.mmid = ISYS_MMID,
+			.num_send_queues = clamp_t(
+				unsigned int, num_streams, 1,
+				IPU_ISYS_NUM_STREAMS),
+			.num_recv_queues = IPU_ISYS_NUM_RECV_QUEUE,
+			.send_queue_size = IPU_ISYS_SIZE_SEND_QUEUE,
+			.recv_queue_size = IPU_ISYS_SIZE_RECV_QUEUE,
+			.icache_prefetch = isys->icache_prefetch,
+		},
+	};
+	struct device *dev = &isys->adev->dev;
+	int rval;
+
+	if (!wrapper_init_done) {
+		wrapper_init_done = true;
+		ipu_wrapper_init(ISYS_MMID, &isys->adev->dev,
+				 isys->pdata->base);
+	}
+
+	/*
+	 * SRAM partitioning. Initially equal partitioning is set
+	 * TODO: Fine tune the partitining based on the stream pixel load
+	 */
+	for (i = 0; i < min(IPU_NOF_SRAM_BLOCKS_MAX, NOF_SRAM_BLOCKS_MAX); i++) {
+		if (i < isys_cfg.driver_sys.num_send_queues)
+			isys_cfg.buffer_partition.num_gda_pages[i] =
+				(IPU_DEVICE_GDA_NR_PAGES *
+				 IPU_DEVICE_GDA_VIRT_FACTOR) /
+				isys_cfg.driver_sys.num_send_queues;
+		else
+			isys_cfg.buffer_partition.num_gda_pages[i] = 0;
+	}
+
+	rval = -ia_css_isys_device_open(&isys->fwcom, &isys_cfg);
+	if (rval < 0) {
+		dev_err(dev, "isys device open failed %d\n", rval);
+		return rval;
+	}
+
+	do {
+		usleep_range(IPU_ISYS_OPEN_TIMEOUT_US,
+			     IPU_ISYS_OPEN_TIMEOUT_US + 10);
+		rval = ipu_lib_call(device_open_ready, isys);
+		if (!rval)
+			break;
+		retry--;
+	} while (retry > 0);
+
+	if (!retry && rval) {
+		dev_err(dev, "isys device open ready failed %d\n", rval);
+		ici_fw_isys_close(isys);
+	}
+
+	return rval;
+}
+EXPORT_SYMBOL_GPL(ici_fw_isys_init);
+
+void ici_fw_isys_cleanup(struct ici_isys *isys)
+{
+	ipu_lib_call(device_release, isys, 1);
+	isys->fwcom = NULL;
+}
+EXPORT_SYMBOL_GPL(ici_fw_isys_cleanup);
+
+struct ipu_fw_isys_resp_info_abi *ipu_fw_isys_get_resp(
+	void *context, unsigned int queue,
+	struct ipu_fw_isys_resp_info_abi *response)
+{
+	struct ia_css_isys_resp_info apiresp;
+	int rval;
+
+	rval = -ia_css_isys_stream_handle_response(context, &apiresp);
+	if (rval < 0)
+		return NULL;
+
+	response->buf_id = 0;
+	response->type = apiresp.type;
+	response->timestamp[0] = apiresp.timestamp[0];
+	response->timestamp[1] = apiresp.timestamp[1];
+	response->stream_handle = apiresp.stream_handle;
+	response->error_info.error = apiresp.error;
+	response->error_info.error_details = apiresp.error_details;
+	response->pin.out_buf_id = apiresp.pin.out_buf_id;
+	response->pin.addr = apiresp.pin.addr;
+	response->pin_id = apiresp.pin_id;
+	response->process_group_light.param_buf_id =
+		apiresp.process_group_light.param_buf_id;
+	response->process_group_light.addr =
+		apiresp.process_group_light.addr;
+	response->acc_id = apiresp.acc_id;
+#ifdef IPU_OTF_SUPPORT
+	response->frame_counter = apiresp.frame_counter;
+	response->written_direct = apiresp.written_direct;
+#endif
+
+	return response;
+}
+EXPORT_SYMBOL_GPL(ipu_fw_isys_get_resp);
+
+void ipu_fw_isys_put_resp(void *context, unsigned int queue)
+{
+	/* Nothing to do here really */
+}
+EXPORT_SYMBOL_GPL(ipu_fw_isys_put_resp);
+
+int ici_fw_isys_simple_cmd(struct ici_isys *isys,
+			   const unsigned int stream_handle,
+			   enum ipu_fw_isys_send_type send_type)
+{
+	int rval = -1;
+
+	switch (send_type) {
+	case IPU_FW_ISYS_SEND_TYPE_STREAM_START:
+		rval = ipu_lib_call(stream_start, isys, stream_handle,
+					   NULL);
+		break;
+	case IPU_FW_ISYS_SEND_TYPE_STREAM_FLUSH:
+		rval = ipu_lib_call(stream_flush, isys, stream_handle);
+		break;
+	case IPU_FW_ISYS_SEND_TYPE_STREAM_STOP:
+		rval = ipu_lib_call(stream_stop, isys, stream_handle);
+		break;
+	case IPU_FW_ISYS_SEND_TYPE_STREAM_CLOSE:
+		rval = ipu_lib_call(stream_close, isys, stream_handle);
+		break;
+	default:
+		WARN_ON(1);
+	}
+
+	return rval;
+}
+EXPORT_SYMBOL_GPL(ici_fw_isys_simple_cmd);
+
+static void resolution_abi_to_api(const struct ipu_fw_isys_resolution_abi *abi,
+				  struct ia_css_isys_resolution *api)
+{
+	api->width = abi->width;
+	api->height = abi->height;
+}
+
+static void output_pin_payload_abi_to_api(
+	struct ipu_fw_isys_output_pin_payload_abi *abi,
+	struct ia_css_isys_output_pin_payload *api)
+{
+	api->out_buf_id = abi->out_buf_id;
+	api->addr = abi->addr;
+}
+
+static void output_pin_info_abi_to_api(
+	struct ipu_fw_isys_output_pin_info_abi *abi,
+	struct ia_css_isys_output_pin_info *api)
+{
+	api->input_pin_id = abi->input_pin_id;
+	resolution_abi_to_api(&abi->output_res, &api->output_res);
+	api->stride = abi->stride;
+	api->pt = abi->pt;
+	api->watermark_in_lines = abi->watermark_in_lines;
+	api->payload_buf_size = abi->payload_buf_size;
+	api->send_irq = abi->send_irq;
+	api->ft = abi->ft;
+#ifdef IPU_OTF_SUPPORT
+	api->link_id = abi->link_id;
+#endif
+	api->reserve_compression = abi->reserve_compression;
+}
+
+static void param_pin_abi_to_api(struct ipu_fw_isys_param_pin_abi *abi,
+				 struct ia_css_isys_param_pin *api)
+{
+	api->param_buf_id = abi->param_buf_id;
+	api->addr = abi->addr;
+}
+
+static void input_pin_info_abi_to_api(
+	struct ipu_fw_isys_input_pin_info_abi *abi,
+	struct ia_css_isys_input_pin_info *api)
+{
+	resolution_abi_to_api(&abi->input_res, &api->input_res);
+	api->dt = abi->dt;
+	api->mipi_store_mode = abi->mipi_store_mode;
+	api->mapped_dt = abi->mapped_dt;
+}
+
+static void isa_cfg_abi_to_api(const struct ipu_fw_isys_isa_cfg_abi *abi,
+			       struct ia_css_isys_isa_cfg *api)
+{
+	unsigned int i;
+
+  
+	for (i = 0; i < N_IA_CSS_ISYS_RESOLUTION_INFO; i++)
+		resolution_abi_to_api(&abi->isa_res[i], &api->isa_res[i]);
+
+	api->blc_enabled = abi->cfg.blc;
+	api->lsc_enabled = abi->cfg.lsc;
+	api->dpc_enabled = abi->cfg.dpc;
+	api->downscaler_enabled = abi->cfg.downscaler;
+	api->awb_enabled = abi->cfg.awb;
+	api->af_enabled = abi->cfg.af;
+	api->ae_enabled = abi->cfg.ae;
+	api->paf_type = abi->cfg.paf;
+	api->send_irq_stats_ready = abi->cfg.send_irq_stats_ready;
+	api->send_resp_stats_ready = abi->cfg.send_irq_stats_ready;
+}
+
+static void cropping_abi_to_api(struct ipu_fw_isys_cropping_abi *abi,
+				struct ia_css_isys_cropping *api)
+{
+	api->top_offset = abi->top_offset;
+	api->left_offset = abi->left_offset;
+	api->bottom_offset = abi->bottom_offset;
+	api->right_offset = abi->right_offset;
+}
+
+static void stream_cfg_abi_to_api(struct ipu_fw_isys_stream_cfg_data_abi *abi,
+				  struct ia_css_isys_stream_cfg_data *api)
+{
+	unsigned int i;
+
+	api->src = abi->src;
+	api->vc = abi->vc;
+	api->isl_use = abi->isl_use;
+	api->compfmt = abi->compfmt;
+	isa_cfg_abi_to_api(&abi->isa_cfg, &api->isa_cfg);
+	for (i = 0; i < N_IA_CSS_ISYS_CROPPING_LOCATION; i++)
+		cropping_abi_to_api(&abi->crop[i], &api->crop[i]);
+
+	api->send_irq_sof_discarded = abi->send_irq_sof_discarded;
+	api->send_irq_eof_discarded = abi->send_irq_eof_discarded;
+	api->send_resp_sof_discarded = abi->send_irq_sof_discarded;
+	api->send_resp_eof_discarded = abi->send_irq_eof_discarded;
+	api->nof_input_pins = abi->nof_input_pins;
+	api->nof_output_pins = abi->nof_output_pins;
+	for (i = 0; i < abi->nof_input_pins; i++)
+		input_pin_info_abi_to_api(&abi->input_pins[i],
+					  &api->input_pins[i]);
+
+	for (i = 0; i < abi->nof_output_pins; i++)
+		output_pin_info_abi_to_api(&abi->output_pins[i],
+					   &api->output_pins[i]);
+}
+
+static void frame_buff_set_abi_to_api(
+	struct ipu_fw_isys_frame_buff_set_abi *abi,
+	struct ia_css_isys_frame_buff_set *api)
+{
+	int i;
+
+	for (i = 0; i < min(IPU_MAX_OPINS, MAX_OPINS); i++)
+		output_pin_payload_abi_to_api(&abi->output_pins[i],
+					      &api->output_pins[i]);
+
+	param_pin_abi_to_api(&abi->process_group_light,
+			     &api->process_group_light);
+
+	api->send_irq_sof = abi->send_irq_sof;
+	api->send_irq_eof = abi->send_irq_eof;
+}
+
+int ici_fw_isys_complex_cmd(struct ici_isys *isys,
+					   const unsigned int stream_handle,
+					   void *cpu_mapped_buf,
+					   dma_addr_t dma_mapped_buf,
+					   size_t size,
+					   enum ipu_fw_isys_send_type send_type)
+{
+	union {
+		struct ia_css_isys_stream_cfg_data stream_cfg;
+		struct ia_css_isys_frame_buff_set buf;
+	} param;
+	int rval = -1;
+
+	memset(&param, 0, sizeof(param));
+
+	switch (send_type) {
+	case IPU_FW_ISYS_SEND_TYPE_STREAM_CAPTURE:
+		frame_buff_set_abi_to_api(cpu_mapped_buf, &param.buf);
+		rval = ipu_lib_call(stream_capture_indication,
+				    isys, stream_handle, &param.buf);
+		break;
+	case IPU_FW_ISYS_SEND_TYPE_STREAM_OPEN:
+		stream_cfg_abi_to_api(cpu_mapped_buf, &param.stream_cfg);
+		rval = ipu_lib_call(stream_open, isys, stream_handle,
+				    &param.stream_cfg);
+		break;
+	case IPU_FW_ISYS_SEND_TYPE_STREAM_START_AND_CAPTURE:
+		frame_buff_set_abi_to_api(cpu_mapped_buf, &param.buf);
+		rval = ipu_lib_call(stream_start, isys, stream_handle,
+				    &param.buf);
+		break;
+	default:
+		WARN_ON(1);
+	}
+
+	return rval;
+}
+EXPORT_SYMBOL_GPL(ici_fw_isys_complex_cmd);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Intel ipu library");
+EXPORT_SYMBOL_GPL(ia_css_isys_device_open);
+EXPORT_SYMBOL_GPL(ia_css_isys_device_open_ready);
+EXPORT_SYMBOL_GPL(ia_css_isys_device_close);
+EXPORT_SYMBOL_GPL(ia_css_isys_device_release);
+EXPORT_SYMBOL_GPL(ia_css_isys_stream_open);
+EXPORT_SYMBOL_GPL(ia_css_isys_stream_close);
+EXPORT_SYMBOL_GPL(ia_css_isys_stream_start);
+EXPORT_SYMBOL_GPL(ia_css_isys_stream_stop);
+EXPORT_SYMBOL_GPL(ia_css_isys_stream_flush);
+EXPORT_SYMBOL_GPL(ia_css_isys_stream_capture_indication);
+EXPORT_SYMBOL_GPL(ia_css_isys_stream_handle_response);
+
diff --git a/include/media/ici.h b/include/media/ici.h
new file mode 100644
index 0000000..bf5a542
--- /dev/null
+++ b/include/media/ici.h
@@ -0,0 +1,141 @@
+/* SPDX-License-Identifier: (BSD-3-Clause OR GPL-2.0) */
+/*
+ * Copyright (C) 2018 Intel Corporation
+ */
+
+#ifndef __ICI_PRIV_H__
+#define __ICI_PRIV_H__
+
+#include <linux/list.h>
+#include <uapi/linux/ici.h>
+
+struct ici_isys_node;
+struct ici_isys_pipeline_device;
+
+struct node_pad {
+	struct ici_isys_node *node;
+	unsigned pad_id;
+	unsigned flags;
+};
+
+struct node_pipe {
+	struct node_pad *src_pad;
+	struct node_pad *sink_pad;
+	struct list_head list_entry;
+	unsigned flags;
+	struct node_pipe *rev_pipe;
+};
+
+struct node_pipeline {
+};
+
+struct ici_isys_node {
+	struct list_head node_entry;
+	struct list_head iterate_node;
+	struct ici_isys_pipeline_device *parent;
+	unsigned node_id;
+	char name[ICI_MAX_NODE_NAME];
+	void *sd;
+	bool external;
+	struct node_pad *node_pad;
+	unsigned nr_pads;
+	struct list_head node_pipes;
+	unsigned nr_pipes;
+	unsigned stream_count;
+	unsigned use_count;
+	struct node_pipeline *pipe;	/* Pipeline this node belongs to. */
+	int (*node_pipeline_validate)(struct node_pipeline *inp,
+		struct ici_isys_node *node);
+	int (*node_set_power)(struct ici_isys_node* node,
+		int power);
+	int (*node_set_streaming)(struct ici_isys_node* node,
+		void* ip,
+		int streaming);
+	int (*node_get_pad_supported_format)(
+		struct ici_isys_node* node,
+		struct ici_pad_supported_format_desc* psfd);
+	int (*node_set_pad_ffmt)(struct ici_isys_node* node,
+		struct ici_pad_framefmt* pff);
+	int (*node_get_pad_ffmt)(struct ici_isys_node* node,
+		struct ici_pad_framefmt* pff);
+	int (*node_set_pad_sel)(struct ici_isys_node* node,
+		struct ici_pad_selection* ps);
+	int (*node_get_pad_sel)(struct ici_isys_node* node,
+		struct ici_pad_selection* ps);
+};
+
+enum ici_ext_sd_param_id {
+	ICI_EXT_SD_PARAM_ID_LINK_FREQ = 1,
+	ICI_EXT_SD_PARAM_ID_PIXEL_RATE,
+	ICI_EXT_SD_PARAM_ID_HFLIP,
+	ICI_EXT_SD_PARAM_ID_VFLIP,
+	ICI_EXT_SD_PARAM_ID_FRAME_LENGTH_LINES,
+	ICI_EXT_SD_PARAM_ID_LINE_LENGTH_PIXELS,
+	ICI_EXT_SD_PARAM_ID_HBLANK,
+	ICI_EXT_SD_PARAM_ID_VBLANK,
+	ICI_EXT_SD_PARAM_ID_SENSOR_MODE,
+	ICI_EXT_SD_PARAM_ID_ANALOGUE_GAIN,
+	ICI_EXT_SD_PARAM_ID_EXPOSURE,
+	ICI_EXT_SD_PARAM_ID_TEST_PATTERN,
+	ICI_EXT_SD_PARAM_ID_GAIN,
+	ICI_EXT_SD_PARAM_ID_THERMAL_DATA,
+	ICI_EXT_SD_PARAM_ID_MIPI_LANES,
+	ICI_EXT_SD_PARAM_ID_WDR_MODE,
+};
+
+enum ici_ext_sd_param_type {
+	ICI_EXT_SD_PARAM_TYPE_INT32 = 0,
+	ICI_EXT_SD_PARAM_TYPE_INT64,
+	ICI_EXT_SD_PARAM_TYPE_STR,
+};
+
+struct ici_ext_sd_param_custom_data {
+	unsigned size;
+	char* data;
+};
+
+struct ici_ext_subdev;
+
+struct ici_ext_sd_param {
+	struct ici_ext_subdev* sd;
+	int id;
+	int type;
+	union {
+		s32 val;
+		s64 s64val;
+		struct ici_ext_sd_param_custom_data custom;
+	};
+};
+
+struct ici_ext_subdev;
+
+struct ici_ext_subdev_register {
+	void* ipu_data;
+	struct ici_ext_subdev* sd;
+	int (*setup_node)(void* ipu_data,
+		struct ici_ext_subdev* sd,
+		const char* name);
+	int (*create_link)(
+		struct ici_isys_node* src,
+		u16 src_pad,
+		struct ici_isys_node* sink,
+		u16 sink_pad,
+		u32 flags);
+};
+
+struct ici_ext_subdev {
+	struct ici_isys_node node;
+	void* client;
+	unsigned num_pads;
+	struct node_pad pads[ICI_MAX_PADS];
+	u16 src_pad;
+	int (*do_register)(
+		struct ici_ext_subdev_register* reg);
+	void (*do_unregister)(struct ici_ext_subdev* sd);
+	int (*set_param)(struct ici_ext_sd_param* param);
+	int (*get_param)(struct ici_ext_sd_param* param);
+	int (*get_menu_item)(struct ici_ext_sd_param* param,
+		unsigned idx);
+};
+
+#endif // __ICI_PRIV_H__
diff --git a/include/uapi/linux/ici.h b/include/uapi/linux/ici.h
new file mode 100644
index 0000000..92cf555
--- /dev/null
+++ b/include/uapi/linux/ici.h
@@ -0,0 +1,203 @@
+/* SPDX-License-Identifier: (BSD-3-Clause OR GPL-2.0) */
+/*
+ * Copyright (C) 2018 Intel Corporation
+ */
+
+#ifndef _UAPI_LINUX_ICI_H
+#define _UAPI_LINUX_ICI_H
+
+#define IPU_MAX_BUF_FRAMES 16
+#define ICI_MAX_PLANES 4
+
+#define ICI_MAX_PADS 4
+#define ICI_MAX_LINKS 64
+#define ICI_MAX_NODE_NAME 64
+
+#define MAJOR_STREAM 'A'
+#define ICI_STREAM_DEVICE_NAME "intel_stream"
+
+#define MAJOR_PIPELINE 'B'
+#define MINOR_PIPELINE 0
+#define ICI_PIPELINE_DEVICE_NAME "intel_pipeline"
+
+#define ici_fourcc_code(a, b, c, d) ((__u32)(a) | ((__u32)(b) << 8) | \
+				 ((__u32)(c) << 16) | ((__u32)(d) << 24))
+
+enum ici_format
+{
+	ICI_FORMAT_RGB888 		 = ici_fourcc_code('X', 'R', '2', '4'),
+	ICI_FORMAT_RGB565 		 = ici_fourcc_code('R', 'G', '1', '6'),
+	ICI_FORMAT_UYVY			 = ici_fourcc_code('U', 'Y', 'V', 'Y'),
+	ICI_FORMAT_YUYV			 = ici_fourcc_code('Y', 'U', 'Y', 'V'),
+	ICI_FORMAT_SBGGR12		 = ici_fourcc_code('B', 'G', '1', '2'),
+	ICI_FORMAT_SGBRG12		 = ici_fourcc_code('G', 'B', '1', '2'),
+	ICI_FORMAT_SGRBG12		 = ici_fourcc_code('B', 'A', '1', '2'),
+	ICI_FORMAT_SRGGB12		 = ici_fourcc_code('R', 'G', '1', '2'),
+	ICI_FORMAT_SBGGR10  	 = ici_fourcc_code('B', 'G', '1', '0'),
+	ICI_FORMAT_SGBRG10  	 = ici_fourcc_code('G', 'B', '1', '0'),
+	ICI_FORMAT_SGRBG10  	 = ici_fourcc_code('B', 'A', '1', '0'),
+	ICI_FORMAT_SRGGB10  	 = ici_fourcc_code('R', 'G', '1', '0'),
+	ICI_FORMAT_SBGGR8   	 = ici_fourcc_code('B', 'A', '8', '1'),
+	ICI_FORMAT_SGBRG8   	 = ici_fourcc_code('G', 'B', 'R', 'G'),
+	ICI_FORMAT_SGRBG8   	 = ici_fourcc_code('G', 'R', 'B', 'G'),
+	ICI_FORMAT_SRGGB8   	 = ici_fourcc_code('R', 'G', 'G', 'B'),
+	ICI_FORMAT_SBGGR10_DPCM8 = ici_fourcc_code('b', 'B', 'A', '8'),
+	ICI_FORMAT_SGBRG10_DPCM8 = ici_fourcc_code('b', 'G', 'A', '8'),
+	ICI_FORMAT_SGRBG10_DPCM8 = ici_fourcc_code('B', 'D', '1', '0'),
+	ICI_FORMAT_SRGGB10_DPCM8 = ici_fourcc_code('b', 'R', 'A', '8'),
+	ICI_FORMAT_NV12 		 = ici_fourcc_code('N', 'V', '1', '2'),
+	ICI_FORMAT_COUNT = 22,
+};
+
+#define ICI_PAD_FLAGS_SINK		(1 << 0)
+#define ICI_PAD_FLAGS_SOURCE	(1 << 1)
+#define ICI_PAD_FLAGS_MUST_CONNECT	(1 << 2)
+
+#define ICI_LINK_FLAG_ENABLED	(1 << 0)
+#define ICI_LINK_FLAG_BACKLINK	(1 << 1)
+
+enum {
+	ICI_MEM_USERPTR = 2,
+	ICI_MEM_DMABUF = 4,
+};
+
+enum {
+	ICI_FIELD_ANY = 0,
+	ICI_FIELD_NONE = 1,
+	ICI_FIELD_TOP = 2,
+	ICI_FIELD_BOTTOM = 3,
+	ICI_FIELD_ALTERNATE = 7,
+};
+
+struct ici_rect {
+	__s32 left;
+	__s32 top;
+	__u32 width;
+	__u32 height;
+};
+
+struct ici_frame_plane {
+	__u32 bytes_used;
+	__u32 length;
+	union {
+		unsigned long userptr;
+		__s32 dmafd;
+	} mem;
+	__u32 data_offset;
+	__u32 reserved[2];
+};
+
+struct ici_frame_info {
+	__u32 frame_type;
+	__u32 field;
+	__u32 flag;
+	__u32 frame_buf_id;
+	struct timeval frame_timestamp;
+	__u32 frame_sequence_id;
+	__u32 mem_type; /* _DMA or _USER_PTR */
+	struct ici_frame_plane frame_planes[ICI_MAX_PLANES]; /* multi-planar */
+	__u32 num_planes; /* =1 single-planar &gt; 1 multi-planar array size */
+	__u32 reserved[2];
+};
+
+#define ICI_IOC_STREAM_ON _IO(MAJOR_STREAM, 1)
+#define ICI_IOC_STREAM_OFF _IO(MAJOR_STREAM, 2)
+#define ICI_IOC_GET_BUF _IOWR(MAJOR_STREAM, 3, struct ici_frame_info)
+#define ICI_IOC_PUT_BUF _IOWR(MAJOR_STREAM, 4, struct ici_frame_info)
+#define ICI_IOC_SET_FORMAT _IOWR(MAJOR_STREAM, 5, struct ici_stream_format)
+
+struct ici_plane_stream_format {
+	__u32 sizeimage;
+	__u32 bytesperline;
+	__u32 bpp;
+	__u16 reserved[6];
+} __attribute__ ((packed));
+
+struct ici_framefmt {
+	__u32 width;
+	__u32 height;
+	__u32 pixelformat;
+	__u32 field;
+	__u32 colorspace;
+	__u8 flags;
+	__u8 reserved[8];
+};
+
+struct ici_planefmt {
+	struct ici_plane_stream_format plane_fmt[ICI_MAX_PLANES];
+	__u8 num_planes;
+} __attribute__ ((packed));
+
+struct ici_stream_format {
+	struct ici_framefmt ffmt;
+	struct ici_planefmt pfmt;
+};
+
+struct ici_pad_desc {
+	__u32 node_id;          /* node ID */
+	__u16 pad_idx;          /* pad index */
+	__u32 flags;
+	__u32 reserved[2];
+};
+
+enum ici_ext_sel_type {
+	ICI_EXT_SEL_TYPE_NATIVE = 1,
+	ICI_EXT_SEL_TYPE_CROP,
+	ICI_EXT_SEL_TYPE_CROP_BOUNDS,
+	ICI_EXT_SEL_TYPE_COMPOSE,
+	ICI_EXT_SEL_TYPE_COMPOSE_BOUNDS,
+};
+
+struct ici_pad_supported_format_desc {
+	__u32 idx;
+	__u32 color_format;
+	__u32 min_width;
+	__u32 max_width;
+	__u32 min_height;
+	__u32 max_height;
+	struct ici_pad_desc pad;
+};
+
+struct ici_pad_framefmt {
+	struct ici_framefmt ffmt;
+	struct ici_pad_desc pad;
+};
+
+struct ici_pad_selection {
+	__u32 sel_type;
+	struct ici_rect rect;
+	struct ici_pad_desc pad;
+};
+
+struct ici_node_desc {
+	__u32 node_count;
+	__s32 node_id;
+	unsigned nr_pads;
+	char name[ICI_MAX_NODE_NAME];
+	struct ici_pad_desc node_pad[ICI_MAX_PADS];
+};
+
+struct ici_link_desc {
+        struct ici_pad_desc source;
+        struct ici_pad_desc sink;
+        __u32 flags;
+        __u32 reserved[2];
+};
+
+struct ici_links_query {
+	struct ici_pad_desc pad; /* pad index */
+	__u16 links_cnt;							/* number of connected links, described below */
+	struct ici_link_desc links[ICI_MAX_LINKS];
+
+};
+
+#define ICI_IOC_ENUM_NODES _IOWR(MAJOR_PIPELINE, 1, struct ici_node_desc)
+#define ICI_IOC_ENUM_LINKS _IOWR(MAJOR_PIPELINE, 2, struct ici_links_query)
+#define ICI_IOC_SETUP_PIPE _IOWR(MAJOR_PIPELINE, 3, struct ici_link_desc)
+#define ICI_IOC_SET_FRAMEFMT _IOWR(MAJOR_PIPELINE, 4, struct ici_pad_framefmt)
+#define ICI_IOC_GET_FRAMEFMT _IOWR(MAJOR_PIPELINE, 5, struct ici_pad_framefmt)
+#define ICI_IOC_GET_SUPPORTED_FRAMEFMT _IOWR(MAJOR_PIPELINE, 6, struct ici_pad_supported_format_desc)
+#define ICI_IOC_SET_SELECTION _IOWR(MAJOR_PIPELINE, 7, struct ici_pad_selection)
+#define ICI_IOC_GET_SELECTION _IOWR(MAJOR_PIPELINE, 8, struct ici_pad_selection)
+
+#endif // _UAPI_LINUX_ICI_H
-- 
2.7.4

